//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/subjects/UnicastSubject.java
//

/*!
 @brief Copyright 2014 Netflix, Inc.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxSubjectsUnicastSubject")
#ifdef RESTRICT_RxSubjectsUnicastSubject
#define INCLUDE_ALL_RxSubjectsUnicastSubject 0
#else
#define INCLUDE_ALL_RxSubjectsUnicastSubject 1
#endif
#undef RESTRICT_RxSubjectsUnicastSubject

#if !defined (RxSubjectsUnicastSubject_) && (INCLUDE_ALL_RxSubjectsUnicastSubject || defined(INCLUDE_RxSubjectsUnicastSubject))
#define RxSubjectsUnicastSubject_

#define RESTRICT_RxSubjectsSubject 1
#define INCLUDE_RxSubjectsSubject 1
#include "rx/subjects/Subject.h"

@class RxSubjectsUnicastSubject_State;
@protocol RxFunctionsAction0;

/*!
 @brief A Subject variant which buffers events until a single Subscriber arrives and replays them to it
 and potentially switches to direct delivery once the Subscriber caught up and requested an unlimited
 amount.
 In this case, the buffered values are no longer retained. If the Subscriber
 requests a limited amount, queueing is involved and only those values are retained which
 weren't requested by the Subscriber at that time.
 */
@interface RxSubjectsUnicastSubject : RxSubjectsSubject {
 @public
  RxSubjectsUnicastSubject_State *state_;
}

#pragma mark Public

/*!
 @brief Constructs an empty UnicastSubject instance with the default capacity hint of 16 elements.
 @return the created UnicastSubject instance
 */
+ (RxSubjectsUnicastSubject *)create;

/*!
 @brief Constructs an empty UnicastSubject instance with a capacity hint.
 <p>The capacity hint determines the internal queue's island size: the larger
 it is the less frequent allocation will happen if there is no subscriber
 or the subscriber hasn't caught up.
 @param capacityHint the capacity hint for the internal queue
 @return the created BufferUntilSubscriber instance
 */
+ (RxSubjectsUnicastSubject *)createWithInt:(jint)capacityHint;

/*!
 @brief Constructs an empty UnicastSubject instance with a capacity hint and
 an Action0 instance to call if the subject reaches its terminal state
 or the single Subscriber unsubscribes mid-sequence.
 <p>The capacity hint determines the internal queue's island size: the larger
 it is the less frequent allocation will happen if there is no subscriber
 or the subscriber hasn't caught up.
 @param capacityHint the capacity hint for the internal queue
 @param onTerminated the optional callback to call when subject reaches its terminal state
 or the single Subscriber unsubscribes mid-sequence. It will be called
 at most once.
 @return the created BufferUntilSubscriber instance
 */
+ (RxSubjectsUnicastSubject *)createWithInt:(jint)capacityHint
                     withRxFunctionsAction0:(id<RxFunctionsAction0>)onTerminated;

- (jboolean)hasObservers;

- (void)onCompleted;

- (void)onErrorWithNSException:(NSException *)e;

- (void)onNextWithId:(id)t;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSubjectsUnicastSubject)

J2OBJC_FIELD_SETTER(RxSubjectsUnicastSubject, state_, RxSubjectsUnicastSubject_State *)

FOUNDATION_EXPORT RxSubjectsUnicastSubject *RxSubjectsUnicastSubject_create();

FOUNDATION_EXPORT RxSubjectsUnicastSubject *RxSubjectsUnicastSubject_createWithInt_(jint capacityHint);

FOUNDATION_EXPORT RxSubjectsUnicastSubject *RxSubjectsUnicastSubject_createWithInt_withRxFunctionsAction0_(jint capacityHint, id<RxFunctionsAction0> onTerminated);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsUnicastSubject)

#endif

#if !defined (RxSubjectsUnicastSubject_State_) && (INCLUDE_ALL_RxSubjectsUnicastSubject || defined(INCLUDE_RxSubjectsUnicastSubject_State))
#define RxSubjectsUnicastSubject_State_

#define RESTRICT_JavaUtilConcurrentAtomicAtomicLong 1
#define INCLUDE_JavaUtilConcurrentAtomicAtomicLong 1
#include "java/util/concurrent/atomic/AtomicLong.h"

#define RESTRICT_RxProducer 1
#define INCLUDE_RxProducer 1
#include "rx/Producer.h"

#define RESTRICT_RxObserver 1
#define INCLUDE_RxObserver 1
#include "rx/Observer.h"

#define RESTRICT_RxObservable 1
#define INCLUDE_RxObservable_OnSubscribe 1
#include "rx/Observable.h"

#define RESTRICT_RxSubscription 1
#define INCLUDE_RxSubscription 1
#include "rx/Subscription.h"

@class JavaUtilConcurrentAtomicAtomicReference;
@class RxInternalOperatorsNotificationLite;
@class RxSubscriber;
@protocol JavaUtilQueue;
@protocol RxFunctionsAction0;

/*!
 @brief The single-consumption replaying state.
 */
@interface RxSubjectsUnicastSubject_State : JavaUtilConcurrentAtomicAtomicLong < RxProducer, RxObserver, RxObservable_OnSubscribe, RxSubscription > {
 @public
  /*!
   @brief The single subscriber.
   */
  JavaUtilConcurrentAtomicAtomicReference *subscriber_;
  /*!
   @brief The queue holding values until the subscriber arrives and catches up.
   */
  id<JavaUtilQueue> queue_;
  /*!
   @brief JCTools queues don't accept nulls.
   */
  RxInternalOperatorsNotificationLite *nl_;
  /*!
   @brief Atomically set to true on terminal condition.
   */
  JavaUtilConcurrentAtomicAtomicReference *terminateOnce_;
  /*!
   @brief In case the source emitted an error.
   */
  NSException *error_;
  /*!
   @brief Indicates the source has terminated.
   */
  volatile_jboolean done_;
  /*!
   @brief Emitter loop: emitting indicator.
   Guarded by this. 
   */
  jboolean emitting_;
  /*!
   @brief Emitter loop: missed emission indicator.
   Guarded by this. 
   */
  jboolean missed_;
  /*!
   @brief Indicates the queue can be bypassed because the child has caught up with the replay.
   */
  volatile_jboolean caughtUp_;
}

#pragma mark Public

/*!
 @brief Constructor.
 @param capacityHint indicates how large each island in the Spsc queue should be to
 reduce allocation frequency
 @param onTerminated the action to call when the subject reaches its terminal state or
 the single subscriber unsubscribes.
 */
- (instancetype)initWithInt:(jint)capacityHint
     withRxFunctionsAction0:(id<RxFunctionsAction0>)onTerminated;

/*!
 @brief Tries to set the given subscriber if not already set, sending an
 IllegalStateException to the subscriber otherwise.
 @param subscriber
 */
- (void)callWithId:(RxSubscriber *)subscriber;

- (jboolean)isUnsubscribed;

- (void)onCompleted;

- (void)onErrorWithNSException:(NSException *)e;

- (void)onNextWithId:(id)t;

- (void)requestWithLong:(jlong)n;

/*!
 @brief Terminates the state by setting the done flag and tries to clear the queue.
 Should be called only when the child unsubscribes
 */
- (void)unsubscribe;

#pragma mark Package-Private

/*!
 @brief Checks if one of the terminal conditions have been met: child unsubscribed,
 an error happened or the source terminated and the queue is empty
 @param done
 @param empty
 @param s
 */
- (jboolean)checkTerminatedWithBoolean:(jboolean)done
                           withBoolean:(jboolean)empty
                      withRxSubscriber:(RxSubscriber *)s;

/*!
 @brief Call the optional termination action at most once.
 */
- (void)doTerminate;

/*!
 @brief Tries to replay the contents of the queue.
 */
- (void)replay;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSubjectsUnicastSubject_State)

J2OBJC_FIELD_SETTER(RxSubjectsUnicastSubject_State, subscriber_, JavaUtilConcurrentAtomicAtomicReference *)
J2OBJC_FIELD_SETTER(RxSubjectsUnicastSubject_State, queue_, id<JavaUtilQueue>)
J2OBJC_FIELD_SETTER(RxSubjectsUnicastSubject_State, nl_, RxInternalOperatorsNotificationLite *)
J2OBJC_FIELD_SETTER(RxSubjectsUnicastSubject_State, terminateOnce_, JavaUtilConcurrentAtomicAtomicReference *)
J2OBJC_FIELD_SETTER(RxSubjectsUnicastSubject_State, error_, NSException *)

FOUNDATION_EXPORT void RxSubjectsUnicastSubject_State_initWithInt_withRxFunctionsAction0_(RxSubjectsUnicastSubject_State *self, jint capacityHint, id<RxFunctionsAction0> onTerminated);

FOUNDATION_EXPORT RxSubjectsUnicastSubject_State *new_RxSubjectsUnicastSubject_State_initWithInt_withRxFunctionsAction0_(jint capacityHint, id<RxFunctionsAction0> onTerminated) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSubjectsUnicastSubject_State *create_RxSubjectsUnicastSubject_State_initWithInt_withRxFunctionsAction0_(jint capacityHint, id<RxFunctionsAction0> onTerminated);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsUnicastSubject_State)

#endif

#pragma pop_macro("INCLUDE_ALL_RxSubjectsUnicastSubject")
