//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/subjects/ReplaySubject.java
//

/*!
 @brief Copyright 2014 Netflix, Inc.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxSubjectsReplaySubject")
#ifdef RESTRICT_RxSubjectsReplaySubject
#define INCLUDE_ALL_RxSubjectsReplaySubject 0
#else
#define INCLUDE_ALL_RxSubjectsReplaySubject 1
#endif
#undef RESTRICT_RxSubjectsReplaySubject
#ifdef INCLUDE_RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer
#define INCLUDE_RxSubjectsReplaySubject_ReplayBuffer 1
#endif
#ifdef INCLUDE_RxSubjectsReplaySubject_ReplaySizeBoundBuffer
#define INCLUDE_RxSubjectsReplaySubject_ReplayBuffer 1
#endif
#ifdef INCLUDE_RxSubjectsReplaySubject_ReplayUnboundedBuffer
#define INCLUDE_RxSubjectsReplaySubject_ReplayBuffer 1
#endif

#if !defined (RxSubjectsReplaySubject_) && (INCLUDE_ALL_RxSubjectsReplaySubject || defined(INCLUDE_RxSubjectsReplaySubject))
#define RxSubjectsReplaySubject_

#define RESTRICT_RxSubjectsSubject 1
#define INCLUDE_RxSubjectsSubject 1
#include "rx/subjects/Subject.h"

@class IOSObjectArray;
@class JavaUtilConcurrentTimeUnit;
@class RxScheduler;
@class RxSubjectsReplaySubject_ReplayState;

/*!
 @brief Subject that buffers all items it observes and replays them to any <code>Observer</code> that subscribes.
 <p>
 <img width="640" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.ReplaySubject.png" alt="">
 <p>
 Example usage:
 <p>
 @code
   ReplaySubject<Object> subject = ReplaySubject.create();
   subject.onNext("one");
   subject.onNext("two");
   subject.onNext("three");
   subject.onCompleted();
   // both of the following will get the onNext/onCompleted calls from above
   subject.subscribe(observer1);
   subject.subscribe(observer2);
 
@endcode
 */
@interface RxSubjectsReplaySubject : RxSubjectsSubject {
 @public
  /*!
   @brief The state storing the history and the references.
   */
  RxSubjectsReplaySubject_ReplayState *state_;
}

#pragma mark Public

/*!
 @brief Creates an unbounded replay subject.
 <p>
 The internal buffer is backed by an <code>ArrayList</code> and starts with an initial capacity of 16. Once the
 number of items reaches this capacity, it will grow as necessary (usually by 50%). However, as the
 number of items grows, this causes frequent array reallocation and copying, and may hurt performance
 and latency. This can be avoided with the <code>create(int)</code> overload which takes an initial capacity
 parameter and can be tuned to reduce the array reallocation frequency as needed.
 @return the created subject
 */
+ (RxSubjectsReplaySubject *)create;

/*!
 @brief Creates an unbounded replay subject with the specified initial buffer capacity.
 <p>
 Use this method to avoid excessive array reallocation while the internal buffer grows to accommodate new
 items. For example, if you know that the buffer will hold 32k items, you can ask the
 <code>ReplaySubject</code> to preallocate its internal array with a capacity to hold that many items. Once
 the items start to arrive, the internal array won't need to grow, creating less garbage and no overhead
 due to frequent array-copying.
 @param capacity
 the initial buffer capacity
 @return the created subject
 */
+ (RxSubjectsReplaySubject *)createWithInt:(jint)capacity;

/*!
 @brief Creates a size-bounded replay subject.
 <p>
 In this setting, the <code>ReplaySubject</code> holds at most <code>size</code> items in its internal buffer and
 discards the oldest item.
 <p>
 When observers subscribe to a terminated <code>ReplaySubject</code>, they are guaranteed to see at most
 <code>size</code> <code>onNext</code> events followed by a termination event. 
 <p>
 If an observer subscribes while the <code>ReplaySubject</code> is active, it will observe all items in the
 buffer at that point in time and each item observed afterwards, even if the buffer evicts items due to
 the size constraint in the mean time. In other words, once an Observer subscribes, it will receive items
 without gaps in the sequence.
 @param size
 the maximum number of buffered items
 @return the created subject
 */
+ (RxSubjectsReplaySubject *)createWithSizeWithInt:(jint)size;

/*!
 @brief Creates a time-bounded replay subject.
 <p>
 In this setting, the <code>ReplaySubject</code> internally tags each observed item with a timestamp value
 supplied by the <code>Scheduler</code> and keeps only those whose age is less than the supplied time value
 converted to milliseconds. For example, an item arrives at T=0 and the max age is set to 5; at T&gt;=5
 this first item is then evicted by any subsequent item or termination event, leaving the buffer empty. 
 <p>
 Once the subject is terminated, observers subscribing to it will receive items that remained in the
 buffer after the terminal event, regardless of their age. 
 <p>
 If an observer subscribes while the <code>ReplaySubject</code> is active, it will observe only those items
 from within the buffer that have an age less than the specified time, and each item observed thereafter,
 even if the buffer evicts items due to the time constraint in the mean time. In other words, once an
 observer subscribes, it observes items without gaps in the sequence except for any outdated items at the
 beginning of the sequence.
 <p>
 Note that terminal notifications (<code>onError</code> and <code>onCompleted</code>) trigger eviction as well. For
 example, with a max age of 5, the first item is observed at T=0, then an <code>onCompleted</code> notification
 arrives at T=10. If an observer subscribes at T=11, it will find an empty <code>ReplaySubject</code> with just
 an <code>onCompleted</code> notification.
 @param time
 the maximum age of the contained items
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the <code>Scheduler</code> that provides the current time
 @return the created subject
 */
+ (RxSubjectsReplaySubject *)createWithTimeWithLong:(jlong)time
                     withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                    withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Creates a time- and size-bounded replay subject.
 <p>
 In this setting, the <code>ReplaySubject</code> internally tags each received item with a timestamp value
 supplied by the <code>Scheduler</code> and holds at most <code>size</code> items in its internal buffer. It evicts
 items from the start of the buffer if their age becomes less-than or equal to the supplied age in
 milliseconds or the buffer reaches its <code>size</code> limit.
 <p>
 When observers subscribe to a terminated <code>ReplaySubject</code>, they observe the items that remained in
 the buffer after the terminal notification, regardless of their age, but at most <code>size</code> items.
 <p>
 If an observer subscribes while the <code>ReplaySubject</code> is active, it will observe only those items
 from within the buffer that have age less than the specified time and each subsequent item, even if the
 buffer evicts items due to the time constraint in the mean time. In other words, once an observer
 subscribes, it observes items without gaps in the sequence except for the outdated items at the beginning
 of the sequence.
 <p>
 Note that terminal notifications (<code>onError</code> and <code>onCompleted</code>) trigger eviction as well. For
 example, with a max age of 5, the first item is observed at T=0, then an <code>onCompleted</code> notification
 arrives at T=10. If an observer subscribes at T=11, it will find an empty <code>ReplaySubject</code> with just
 an <code>onCompleted</code> notification.
 @param time
 the maximum age of the contained items
 @param unit
 the time unit of <code>time</code>
 @param size
 the maximum number of buffered items
 @param scheduler
 the <code>Scheduler</code> that provides the current time
 @return the created subject
 */
+ (RxSubjectsReplaySubject *)createWithTimeAndSizeWithLong:(jlong)time
                            withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                                   withInt:(jint)size
                                           withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns the Throwable that terminated the Subject.
 @return the Throwable that terminated the Subject or <code>null</code> if the
 subject hasn't terminated yet or it terminated normally.
 */
- (NSException *)getThrowable;

- (id)getValue;

/*!
 @brief Returns a snapshot of the currently buffered non-terminal events.
 <p>The operation is threadsafe.
 @return a snapshot of the currently buffered non-terminal events.
 @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
 */
- (IOSObjectArray *)getValues;

/*!
 @brief Returns a snapshot of the currently buffered non-terminal events into 
 the provided <code>a</code> array or creates a new array if it has not enough capacity.
 @param a the array to fill in
 @return the array <code>a</code> if it had enough capacity or a new array containing the available values
 */
- (IOSObjectArray *)getValuesWithNSObjectArray:(IOSObjectArray *)a;

/*!
 @return true if the Subject holds at least one non-terminal event available for replay
 */
- (jboolean)hasAnyValue;

/*!
 @brief Check if the Subject has terminated normally.
 @return true if the subject completed normally via <code>onCompleted</code>
 */
- (jboolean)hasCompleted;

- (jboolean)hasObservers;

/*!
 @brief Check if the Subject has terminated with an exception.
 @return true if the subject has received a throwable through <code>onError</code>.
 */
- (jboolean)hasThrowable;

- (jboolean)hasValue;

- (void)onCompleted;

- (void)onErrorWithNSException:(NSException *)e;

- (void)onNextWithId:(id)t;

/*!
 @brief Returns the current number of items (non-terminal events) available for replay.
 @return the number of items available
 */
- (jint)size;

#pragma mark Package-Private

- (instancetype)initWithRxSubjectsReplaySubject_ReplayState:(RxSubjectsReplaySubject_ReplayState *)state;

/*!
 @brief Creates an unbounded replay subject with the bounded-implementation for testing purposes.
 <p>
 This variant behaves like the regular unbounded <code>ReplaySubject</code> created via <code>create()</code> but
 uses the structures of the bounded-implementation. This is by no means intended for the replacement of
 the original, array-backed and unbounded <code>ReplaySubject</code> due to the additional overhead of the
 linked-list based internal buffer. The sole purpose is to allow testing and reasoning about the behavior
 of the bounded implementations without the interference of the eviction policies.
 @return the created subject
 */
+ (RxSubjectsReplaySubject *)createUnbounded;

/*!
 @return Returns the number of subscribers.
 */
- (jint)subscriberCount;

@end

J2OBJC_STATIC_INIT(RxSubjectsReplaySubject)

J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject, state_, RxSubjectsReplaySubject_ReplayState *)

FOUNDATION_EXPORT RxSubjectsReplaySubject *RxSubjectsReplaySubject_create();

FOUNDATION_EXPORT RxSubjectsReplaySubject *RxSubjectsReplaySubject_createWithInt_(jint capacity);

FOUNDATION_EXPORT RxSubjectsReplaySubject *RxSubjectsReplaySubject_createUnbounded();

FOUNDATION_EXPORT RxSubjectsReplaySubject *RxSubjectsReplaySubject_createWithSizeWithInt_(jint size);

FOUNDATION_EXPORT RxSubjectsReplaySubject *RxSubjectsReplaySubject_createWithTimeWithLong_withJavaUtilConcurrentTimeUnit_withRxScheduler_(jlong time, JavaUtilConcurrentTimeUnit *unit, RxScheduler *scheduler);

FOUNDATION_EXPORT RxSubjectsReplaySubject *RxSubjectsReplaySubject_createWithTimeAndSizeWithLong_withJavaUtilConcurrentTimeUnit_withInt_withRxScheduler_(jlong time, JavaUtilConcurrentTimeUnit *unit, jint size, RxScheduler *scheduler);

FOUNDATION_EXPORT void RxSubjectsReplaySubject_initWithRxSubjectsReplaySubject_ReplayState_(RxSubjectsReplaySubject *self, RxSubjectsReplaySubject_ReplayState *state);

FOUNDATION_EXPORT RxSubjectsReplaySubject *new_RxSubjectsReplaySubject_initWithRxSubjectsReplaySubject_ReplayState_(RxSubjectsReplaySubject_ReplayState *state) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSubjectsReplaySubject *create_RxSubjectsReplaySubject_initWithRxSubjectsReplaySubject_ReplayState_(RxSubjectsReplaySubject_ReplayState *state);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsReplaySubject)

#endif

#if !defined (RxSubjectsReplaySubject_ReplayState_) && (INCLUDE_ALL_RxSubjectsReplaySubject || defined(INCLUDE_RxSubjectsReplaySubject_ReplayState))
#define RxSubjectsReplaySubject_ReplayState_

#define RESTRICT_JavaUtilConcurrentAtomicAtomicReference 1
#define INCLUDE_JavaUtilConcurrentAtomicAtomicReference 1
#include "java/util/concurrent/atomic/AtomicReference.h"

#define RESTRICT_RxObservable 1
#define INCLUDE_RxObservable_OnSubscribe 1
#include "rx/Observable.h"

#define RESTRICT_RxObserver 1
#define INCLUDE_RxObserver 1
#include "rx/Observer.h"

@class IOSObjectArray;
@class RxSubjectsReplaySubject_ReplayProducer;
@class RxSubscriber;
@protocol RxSubjectsReplaySubject_ReplayBuffer;

/*!
 @brief Holds onto the array of Subscriber-wrapping ReplayProducers and
 the buffer that holds values to be replayed; it manages
 subscription and signal dispatching.
 */
@interface RxSubjectsReplaySubject_ReplayState : JavaUtilConcurrentAtomicAtomicReference < RxObservable_OnSubscribe, RxObserver > {
 @public
  id<RxSubjectsReplaySubject_ReplayBuffer> buffer_;
}

+ (IOSObjectArray *)EMPTY;

+ (IOSObjectArray *)TERMINATED;

#pragma mark Public

- (instancetype)initWithRxSubjectsReplaySubject_ReplayBuffer:(id<RxSubjectsReplaySubject_ReplayBuffer>)buffer;

- (void)callWithId:(RxSubscriber *)t;

- (IOSObjectArray *)get;

- (IOSObjectArray *)getAndSetWithId:(IOSObjectArray *)arg0;

- (void)onCompleted;

- (void)onErrorWithNSException:(NSException *)e;

- (void)onNextWithId:(id)t;

#pragma mark Package-Private

- (jboolean)addWithRxSubjectsReplaySubject_ReplayProducer:(RxSubjectsReplaySubject_ReplayProducer *)rp;

- (jboolean)isTerminated;

- (void)removeWithRxSubjectsReplaySubject_ReplayProducer:(RxSubjectsReplaySubject_ReplayProducer *)rp;

@end

J2OBJC_STATIC_INIT(RxSubjectsReplaySubject_ReplayState)

J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplayState, buffer_, id<RxSubjectsReplaySubject_ReplayBuffer>)

inline IOSObjectArray *RxSubjectsReplaySubject_ReplayState_get_EMPTY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *RxSubjectsReplaySubject_ReplayState_EMPTY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxSubjectsReplaySubject_ReplayState, EMPTY, IOSObjectArray *)

inline IOSObjectArray *RxSubjectsReplaySubject_ReplayState_get_TERMINATED();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *RxSubjectsReplaySubject_ReplayState_TERMINATED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxSubjectsReplaySubject_ReplayState, TERMINATED, IOSObjectArray *)

FOUNDATION_EXPORT void RxSubjectsReplaySubject_ReplayState_initWithRxSubjectsReplaySubject_ReplayBuffer_(RxSubjectsReplaySubject_ReplayState *self, id<RxSubjectsReplaySubject_ReplayBuffer> buffer);

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplayState *new_RxSubjectsReplaySubject_ReplayState_initWithRxSubjectsReplaySubject_ReplayBuffer_(id<RxSubjectsReplaySubject_ReplayBuffer> buffer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplayState *create_RxSubjectsReplaySubject_ReplayState_initWithRxSubjectsReplaySubject_ReplayBuffer_(id<RxSubjectsReplaySubject_ReplayBuffer> buffer);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsReplaySubject_ReplayState)

#endif

#if !defined (RxSubjectsReplaySubject_ReplayBuffer_) && (INCLUDE_ALL_RxSubjectsReplaySubject || defined(INCLUDE_RxSubjectsReplaySubject_ReplayBuffer))
#define RxSubjectsReplaySubject_ReplayBuffer_

@class IOSObjectArray;
@class RxSubjectsReplaySubject_ReplayProducer;

/*!
 @brief The base interface for buffering signals to be replayed to individual
 Subscribers.
 */
@protocol RxSubjectsReplaySubject_ReplayBuffer < JavaObject >

- (void)nextWithId:(id)t;

- (void)errorWithNSException:(NSException *)e;

- (void)complete;

- (jboolean)drainWithRxSubjectsReplaySubject_ReplayProducer:(RxSubjectsReplaySubject_ReplayProducer *)rp;

- (jboolean)isComplete;

- (NSException *)error;

- (id)last;

- (jint)size;

- (jboolean)isEmpty;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSubjectsReplaySubject_ReplayBuffer)

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsReplaySubject_ReplayBuffer)

#endif

#if !defined (RxSubjectsReplaySubject_ReplayUnboundedBuffer_) && (INCLUDE_ALL_RxSubjectsReplaySubject || defined(INCLUDE_RxSubjectsReplaySubject_ReplayUnboundedBuffer))
#define RxSubjectsReplaySubject_ReplayUnboundedBuffer_

@class IOSObjectArray;
@class RxSubjectsReplaySubject_ReplayProducer;

/*!
 @brief An unbounded ReplayBuffer implementation that uses linked-arrays
 to avoid copy-on-grow situation with ArrayList.
 */
@interface RxSubjectsReplaySubject_ReplayUnboundedBuffer : NSObject < RxSubjectsReplaySubject_ReplayBuffer > {
 @public
  jint capacity_;
  volatile_jint size_;
  IOSObjectArray *head_;
  IOSObjectArray *tail_;
  jint tailIndex_;
  volatile_jboolean done_;
  NSException *error_;
}

#pragma mark Public

- (instancetype)initWithInt:(jint)capacity;

- (void)complete;

- (jboolean)drainWithRxSubjectsReplaySubject_ReplayProducer:(RxSubjectsReplaySubject_ReplayProducer *)rp;

- (NSException *)error;

- (void)errorWithNSException:(NSException *)e;

- (jboolean)isComplete;

- (jboolean)isEmpty;

- (id)last;

- (void)nextWithId:(id)t;

- (jint)size;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSubjectsReplaySubject_ReplayUnboundedBuffer)

J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplayUnboundedBuffer, head_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplayUnboundedBuffer, tail_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplayUnboundedBuffer, error_, NSException *)

FOUNDATION_EXPORT void RxSubjectsReplaySubject_ReplayUnboundedBuffer_initWithInt_(RxSubjectsReplaySubject_ReplayUnboundedBuffer *self, jint capacity);

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplayUnboundedBuffer *new_RxSubjectsReplaySubject_ReplayUnboundedBuffer_initWithInt_(jint capacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplayUnboundedBuffer *create_RxSubjectsReplaySubject_ReplayUnboundedBuffer_initWithInt_(jint capacity);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsReplaySubject_ReplayUnboundedBuffer)

#endif

#if !defined (RxSubjectsReplaySubject_ReplaySizeBoundBuffer_) && (INCLUDE_ALL_RxSubjectsReplaySubject || defined(INCLUDE_RxSubjectsReplaySubject_ReplaySizeBoundBuffer))
#define RxSubjectsReplaySubject_ReplaySizeBoundBuffer_

@class IOSObjectArray;
@class RxSubjectsReplaySubject_ReplayProducer;
@class RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node;

@interface RxSubjectsReplaySubject_ReplaySizeBoundBuffer : NSObject < RxSubjectsReplaySubject_ReplayBuffer > {
 @public
  jint limit_;
  volatile_id head_;
  RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node *tail_;
  jint size_;
  volatile_jboolean done_;
  NSException *error_;
}

#pragma mark Public

- (instancetype)initWithInt:(jint)limit;

- (void)complete;

- (jboolean)drainWithRxSubjectsReplaySubject_ReplayProducer:(RxSubjectsReplaySubject_ReplayProducer *)rp;

- (NSException *)error;

- (void)errorWithNSException:(NSException *)ex;

- (jboolean)isComplete;

- (jboolean)isEmpty;

- (id)last;

- (void)nextWithId:(id)value;

- (jint)size;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSubjectsReplaySubject_ReplaySizeBoundBuffer)

J2OBJC_VOLATILE_FIELD_SETTER(RxSubjectsReplaySubject_ReplaySizeBoundBuffer, head_, RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node *)
J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplaySizeBoundBuffer, tail_, RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node *)
J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplaySizeBoundBuffer, error_, NSException *)

FOUNDATION_EXPORT void RxSubjectsReplaySubject_ReplaySizeBoundBuffer_initWithInt_(RxSubjectsReplaySubject_ReplaySizeBoundBuffer *self, jint limit);

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplaySizeBoundBuffer *new_RxSubjectsReplaySubject_ReplaySizeBoundBuffer_initWithInt_(jint limit) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplaySizeBoundBuffer *create_RxSubjectsReplaySubject_ReplaySizeBoundBuffer_initWithInt_(jint limit);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsReplaySubject_ReplaySizeBoundBuffer)

#endif

#if !defined (RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node_) && (INCLUDE_ALL_RxSubjectsReplaySubject || defined(INCLUDE_RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node))
#define RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node_

#define RESTRICT_JavaUtilConcurrentAtomicAtomicReference 1
#define INCLUDE_JavaUtilConcurrentAtomicAtomicReference 1
#include "java/util/concurrent/atomic/AtomicReference.h"

@interface RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node : JavaUtilConcurrentAtomicAtomicReference {
 @public
  id value_Node_;
}

#pragma mark Public

- (instancetype)initWithId:(id)value;

- (RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node *)get;

- (RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node *)getAndSetWithId:(RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node *)arg0;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node)

J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node, value_Node_, id)

FOUNDATION_EXPORT void RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node_initWithId_(RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node *self, id value);

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node *new_RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node_initWithId_(id value) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node *create_RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node_initWithId_(id value);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsReplaySubject_ReplaySizeBoundBuffer_Node)

#endif

#if !defined (RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_) && (INCLUDE_ALL_RxSubjectsReplaySubject || defined(INCLUDE_RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer))
#define RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_

@class IOSObjectArray;
@class RxScheduler;
@class RxSubjectsReplaySubject_ReplayProducer;
@class RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode;

@interface RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer : NSObject < RxSubjectsReplaySubject_ReplayBuffer > {
 @public
  jint limit_;
  jlong maxAgeMillis_;
  RxScheduler *scheduler_;
  volatile_id head_;
  RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *tail_;
  jint size_;
  volatile_jboolean done_;
  NSException *error_;
}

#pragma mark Public

- (instancetype)initWithInt:(jint)limit
                   withLong:(jlong)maxAgeMillis
            withRxScheduler:(RxScheduler *)scheduler;

- (void)complete;

- (jboolean)drainWithRxSubjectsReplaySubject_ReplayProducer:(RxSubjectsReplaySubject_ReplayProducer *)rp;

- (NSException *)error;

- (void)errorWithNSException:(NSException *)ex;

- (jboolean)isComplete;

- (jboolean)isEmpty;

- (id)last;

- (void)nextWithId:(id)value;

- (jint)size;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

#pragma mark Package-Private

- (void)evictFinal;

- (RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *)latestHead;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer)

J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer, scheduler_, RxScheduler *)
J2OBJC_VOLATILE_FIELD_SETTER(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer, head_, RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *)
J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer, tail_, RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *)
J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer, error_, NSException *)

FOUNDATION_EXPORT void RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_initWithInt_withLong_withRxScheduler_(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer *self, jint limit, jlong maxAgeMillis, RxScheduler *scheduler);

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer *new_RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_initWithInt_withLong_withRxScheduler_(jint limit, jlong maxAgeMillis, RxScheduler *scheduler) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer *create_RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_initWithInt_withLong_withRxScheduler_(jint limit, jlong maxAgeMillis, RxScheduler *scheduler);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer)

#endif

#if !defined (RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode_) && (INCLUDE_ALL_RxSubjectsReplaySubject || defined(INCLUDE_RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode))
#define RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode_

#define RESTRICT_JavaUtilConcurrentAtomicAtomicReference 1
#define INCLUDE_JavaUtilConcurrentAtomicAtomicReference 1
#include "java/util/concurrent/atomic/AtomicReference.h"

@interface RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode : JavaUtilConcurrentAtomicAtomicReference {
 @public
  id value_TimedNode_;
  jlong timestamp_;
}

#pragma mark Public

- (instancetype)initWithId:(id)value
                  withLong:(jlong)timestamp;

- (RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *)get;

- (RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *)getAndSetWithId:(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *)arg0;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode)

J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode, value_TimedNode_, id)

FOUNDATION_EXPORT void RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode_initWithId_withLong_(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *self, id value, jlong timestamp);

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *new_RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode_initWithId_withLong_(id value, jlong timestamp) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode *create_RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode_initWithId_withLong_(id value, jlong timestamp);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsReplaySubject_ReplaySizeAndTimeBoundBuffer_TimedNode)

#endif

#if !defined (RxSubjectsReplaySubject_ReplayProducer_) && (INCLUDE_ALL_RxSubjectsReplaySubject || defined(INCLUDE_RxSubjectsReplaySubject_ReplayProducer))
#define RxSubjectsReplaySubject_ReplayProducer_

#define RESTRICT_JavaUtilConcurrentAtomicAtomicInteger 1
#define INCLUDE_JavaUtilConcurrentAtomicAtomicInteger 1
#include "java/util/concurrent/atomic/AtomicInteger.h"

#define RESTRICT_RxProducer 1
#define INCLUDE_RxProducer 1
#include "rx/Producer.h"

#define RESTRICT_RxSubscription 1
#define INCLUDE_RxSubscription 1
#include "rx/Subscription.h"

@class JavaUtilConcurrentAtomicAtomicLong;
@class RxSubjectsReplaySubject_ReplayState;
@class RxSubscriber;

/*!
 @brief A producer and subscription implementation that tracks the current
 replay position of a particular subscriber.
 <p>
 The this holds the current work-in-progress indicator used by serializing
 replays.
 */
@interface RxSubjectsReplaySubject_ReplayProducer : JavaUtilConcurrentAtomicAtomicInteger < RxProducer, RxSubscription > {
 @public
  /*!
   @brief The wrapped Subscriber instance.
   */
  RxSubscriber *actual_;
  /*!
   @brief Holds the current requested amount.
   */
  JavaUtilConcurrentAtomicAtomicLong *requested_;
  /*!
   @brief Holds the back-reference to the replay state object.
   */
  RxSubjectsReplaySubject_ReplayState *state_;
  /*!
   @brief Indicates this Subscriber runs unbounded and the <b>source</b>-triggered
 buffer.drain() has emitted all available values.
   <p>
 This field has to be read and written from the source emitter's thread only.
   */
  jboolean caughtUp_;
  /*!
   @brief Unbounded buffer.drain() uses this field to remember the absolute index of
 values replayed to this Subscriber.
   */
  jint index_;
  /*!
   @brief Unbounded buffer.drain() uses this index within its current node to indicate
 how many items were replayed from that particular node so far.
   */
  jint tailIndex_;
  /*!
   @brief Stores the current replay node of the buffer to be used by buffer.drain().
   */
  id node_;
}

#pragma mark Public

- (instancetype)initWithRxSubscriber:(RxSubscriber *)actual
withRxSubjectsReplaySubject_ReplayState:(RxSubjectsReplaySubject_ReplayState *)state;

- (jboolean)isUnsubscribed;

- (void)requestWithLong:(jlong)n;

- (void)unsubscribe;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSubjectsReplaySubject_ReplayProducer)

J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplayProducer, actual_, RxSubscriber *)
J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplayProducer, requested_, JavaUtilConcurrentAtomicAtomicLong *)
J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplayProducer, state_, RxSubjectsReplaySubject_ReplayState *)
J2OBJC_FIELD_SETTER(RxSubjectsReplaySubject_ReplayProducer, node_, id)

FOUNDATION_EXPORT void RxSubjectsReplaySubject_ReplayProducer_initWithRxSubscriber_withRxSubjectsReplaySubject_ReplayState_(RxSubjectsReplaySubject_ReplayProducer *self, RxSubscriber *actual, RxSubjectsReplaySubject_ReplayState *state);

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplayProducer *new_RxSubjectsReplaySubject_ReplayProducer_initWithRxSubscriber_withRxSubjectsReplaySubject_ReplayState_(RxSubscriber *actual, RxSubjectsReplaySubject_ReplayState *state) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSubjectsReplaySubject_ReplayProducer *create_RxSubjectsReplaySubject_ReplayProducer_initWithRxSubscriber_withRxSubjectsReplaySubject_ReplayState_(RxSubscriber *actual, RxSubjectsReplaySubject_ReplayState *state);

J2OBJC_TYPE_LITERAL_HEADER(RxSubjectsReplaySubject_ReplayProducer)

#endif

#pragma pop_macro("INCLUDE_ALL_RxSubjectsReplaySubject")
