//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/Observable.java
//

/*!
 @brief Copyright 2014 Netflix, Inc.
 Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
 compliance with the License. You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software distributed under the License is
 distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 the License for the specific language governing permissions and limitations under the License.
 */
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxObservable")
#ifdef RESTRICT_RxObservable
#define INCLUDE_ALL_RxObservable 0
#else
#define INCLUDE_ALL_RxObservable 1
#endif
#undef RESTRICT_RxObservable
#ifdef INCLUDE_RxObservable_OnSubscribeExtend
#define INCLUDE_RxObservable_OnSubscribe 1
#endif

#if !defined (RxObservable_) && (INCLUDE_ALL_RxObservable || defined(INCLUDE_RxObservable))
#define RxObservable_

@class IOSClass;
@class IOSObjectArray;
@class JavaUtilConcurrentTimeUnit;
@class RxCompletable;
@class RxObservablesAsyncOnSubscribe;
@class RxObservablesBlockingObservable;
@class RxObservablesConnectableObservable;
@class RxObservablesSyncOnSubscribe;
@class RxPluginsRxJavaObservableExecutionHook;
@class RxScheduler;
@class RxSingle;
@class RxSubscriber;
@protocol JavaLangIterable;
@protocol JavaUtilConcurrentCallable;
@protocol JavaUtilConcurrentFuture;
@protocol JavaUtilList;
@protocol RxBackpressureOverflow_Strategy;
@protocol RxFunctionsAction0;
@protocol RxFunctionsAction1;
@protocol RxFunctionsAction2;
@protocol RxFunctionsFunc0;
@protocol RxFunctionsFunc1;
@protocol RxFunctionsFunc2;
@protocol RxFunctionsFunc3;
@protocol RxFunctionsFunc4;
@protocol RxFunctionsFunc5;
@protocol RxFunctionsFunc6;
@protocol RxFunctionsFunc7;
@protocol RxFunctionsFunc8;
@protocol RxFunctionsFunc9;
@protocol RxFunctionsFuncN;
@protocol RxObservable_OnSubscribe;
@protocol RxObservable_Operator;
@protocol RxObservable_Transformer;
@protocol RxObserver;
@protocol RxSubscription;

/*!
 @brief The Observable class that implements the Reactive Pattern.
 <p>
 This class provides methods for subscribing to the Observable as well as delegate methods to the various
 Observers.
 <p>
 The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:
 <p>
 <img width="640" height="301" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/legend.png" alt="">
 <p>
 For more information see the <a href="http://reactivex.io/documentation/observable.html">ReactiveX
 documentation</a>.
 */
@interface RxObservable : NSObject {
 @public
  id<RxObservable_OnSubscribe> onSubscribe_;
}

+ (RxPluginsRxJavaObservableExecutionHook *)hook;

#pragma mark Public

/*!
 @brief Returns an Observable that emits a Boolean that indicates whether all of the items emitted by the source
 Observable satisfy a condition.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>all</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 a function that evaluates an item and returns a Boolean
 @return an Observable that emits <code>true</code> if all items emitted by the source Observable satisfy the
 predicate; otherwise, <code>false</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/all.html">ReactiveX operators documentation: All</a>
 */
- (RxObservable *)allWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Mirrors the one Observable in an Iterable of several Observables that first either emits an item or sends
 a termination notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources
 an Iterable of Observable sources competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
+ (RxObservable *)ambWithJavaLangIterable:(id<JavaLangIterable>)sources;

/*!
 @brief Given two Observables, mirrors the one that first either emits an item or sends a termination
 notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 an Observable competing to react first
 @param o2
 an Observable competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
+ (RxObservable *)ambWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2;

/*!
 @brief Given three Observables, mirrors the one that first either emits an item or sends a termination
 notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 an Observable competing to react first
 @param o2
 an Observable competing to react first
 @param o3
 an Observable competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
+ (RxObservable *)ambWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3;

/*!
 @brief Given four Observables, mirrors the one that first either emits an item or sends a termination
 notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 an Observable competing to react first
 @param o2
 an Observable competing to react first
 @param o3
 an Observable competing to react first
 @param o4
 an Observable competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
+ (RxObservable *)ambWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4;

/*!
 @brief Given five Observables, mirrors the one that first either emits an item or sends a termination
 notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 an Observable competing to react first
 @param o2
 an Observable competing to react first
 @param o3
 an Observable competing to react first
 @param o4
 an Observable competing to react first
 @param o5
 an Observable competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
+ (RxObservable *)ambWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5;

/*!
 @brief Given six Observables, mirrors the one that first either emits an item or sends a termination
 notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 an Observable competing to react first
 @param o2
 an Observable competing to react first
 @param o3
 an Observable competing to react first
 @param o4
 an Observable competing to react first
 @param o5
 an Observable competing to react first
 @param o6
 an Observable competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
+ (RxObservable *)ambWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5
                     withRxObservable:(RxObservable *)o6;

/*!
 @brief Given seven Observables, mirrors the one that first either emits an item or sends a termination
 notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 an Observable competing to react first
 @param o2
 an Observable competing to react first
 @param o3
 an Observable competing to react first
 @param o4
 an Observable competing to react first
 @param o5
 an Observable competing to react first
 @param o6
 an Observable competing to react first
 @param o7
 an Observable competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
+ (RxObservable *)ambWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5
                     withRxObservable:(RxObservable *)o6
                     withRxObservable:(RxObservable *)o7;

/*!
 @brief Given eight Observables, mirrors the one that first either emits an item or sends a termination
 notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 an Observable competing to react first
 @param o2
 an Observable competing to react first
 @param o3
 an Observable competing to react first
 @param o4
 an Observable competing to react first
 @param o5
 an Observable competing to react first
 @param o6
 an Observable competing to react first
 @param o7
 an Observable competing to react first
 @param o8
 an observable competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
+ (RxObservable *)ambWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5
                     withRxObservable:(RxObservable *)o6
                     withRxObservable:(RxObservable *)o7
                     withRxObservable:(RxObservable *)o8;

/*!
 @brief Given nine Observables, mirrors the one that first either emits an item or sends a termination
 notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 an Observable competing to react first
 @param o2
 an Observable competing to react first
 @param o3
 an Observable competing to react first
 @param o4
 an Observable competing to react first
 @param o5
 an Observable competing to react first
 @param o6
 an Observable competing to react first
 @param o7
 an Observable competing to react first
 @param o8
 an Observable competing to react first
 @param o9
 an Observable competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
+ (RxObservable *)ambWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5
                     withRxObservable:(RxObservable *)o6
                     withRxObservable:(RxObservable *)o7
                     withRxObservable:(RxObservable *)o8
                     withRxObservable:(RxObservable *)o9;

/*!
 @brief Mirrors the Observable (current or provided) that first either emits an item or sends a termination
 notification.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>amb</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable competing to react first
 @return an Observable that emits the same sequence as whichever of the source Observables first
 emitted an item or sent a termination notification
 - seealso: <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>
 */
- (RxObservable *)ambWithWithRxObservable:(RxObservable *)t1;

/*!
 @brief Portrays a object of an Observable subclass as a simple Observable object.
 This is useful, for instance,
 when you have an implementation of a subclass of Observable but you want to hide the properties and
 methods of this subclass from whomever you are passing the Observable to.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>asObservable</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that hides the identity of this Observable
 */
- (RxObservable *)asObservable;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a
 new buffer whenever the Observable produced by the specified <code>bufferClosingSelector</code> emits an item.
 <p>
 <img width="640" height="395" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer1.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it is instead controlled by the given Observables and
 buffers data. It requests <code>Long.MAX_VALUE</code> upstream and does not obey downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>buffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param bufferClosingSelector
 a <code>Func0</code> that produces an Observable that governs the boundary between buffers.
 Whenever this <code>Observable</code> emits an item, <code>buffer</code> emits the current buffer and
 begins to fill a new one
 @return an Observable that emits a connected, non-overlapping buffer of items from the source Observable
 each time the Observable created with the <code>bufferClosingSelector</code> argument emits an item
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithRxFunctionsFunc0:(id<RxFunctionsFunc0>)bufferClosingSelector;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping buffers, each containing <code>count</code> items. When the source
 Observable completes or encounters an error, the resulting Observable emits the current buffer and
 propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer3.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>buffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum number of items in each buffer before it should be emitted
 @return an Observable that emits connected, non-overlapping buffers, each containing at most
 <code>count</code> items from the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithInt:(jint)count;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable emits buffers every <code>skip</code> items, each containing <code>count</code> items. When the source
 Observable completes or encounters an error, the resulting Observable emits the current buffer and
 propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer4.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>buffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum size of each buffer before it should be emitted
 @param skip
 how many items emitted by the source Observable should be skipped before starting a new
 buffer. Note that when <code>skip</code> and <code>count</code> are equal, this is the same operation as
 <code>buffer(int)</code>.
 @return an Observable that emits buffers for every <code>skip</code> item from the source Observable and
 containing at most <code>count</code> items
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithInt:(jint)count
                        withInt:(jint)skip;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable starts a new buffer periodically, as determined by the <code>timeshift</code> argument. It emits
 each buffer after a fixed timespan, specified by the <code>timespan</code> argument. When the source
 Observable completes or encounters an error, the resulting Observable emits the current buffer and
 propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. It requests <code>Long.MAX_VALUE</code>
 upstream and does not obey downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>buffer</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timespan
 the period of time each buffer collects items before it is emitted
 @param timeshift
 the period of time after which a new buffer will be created
 @param unit
 the unit of time that applies to the <code>timespan</code> and <code>timeshift</code> arguments
 @return an Observable that emits new buffers of items emitted by the source Observable periodically after
 a fixed timespan has elapsed
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithLong:(jlong)timespan
                        withLong:(jlong)timeshift
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable starts a new buffer periodically, as determined by the <code>timeshift</code> argument, and on the
 specified <code>scheduler</code>. It emits each buffer after a fixed timespan, specified by the
 <code>timespan</code> argument. When the source Observable completes or encounters an error, the resulting
 Observable emits the current buffer and propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. It requests <code>Long.MAX_VALUE</code>
 upstream and does not obey downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timespan
 the period of time each buffer collects items before it is emitted
 @param timeshift
 the period of time after which a new buffer will be created
 @param unit
 the unit of time that applies to the <code>timespan</code> and <code>timeshift</code> arguments
 @param scheduler
 the <code>Scheduler</code> to use when determining the end and start of a buffer
 @return an Observable that emits new buffers of items emitted by the source Observable periodically after
 a fixed timespan has elapsed
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithLong:(jlong)timespan
                        withLong:(jlong)timeshift
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
 <code>timespan</code> argument. When the source Observable completes or encounters an error, the resulting
 Observable emits the current buffer and propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. It requests <code>Long.MAX_VALUE</code>
 upstream and does not obey downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>buffer</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timespan
 the period of time each buffer collects items before it is emitted and replaced with a new
 buffer
 @param unit
 the unit of time that applies to the <code>timespan</code> argument
 @return an Observable that emits connected, non-overlapping buffers of items emitted by the source
 Observable within a fixed duration
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithLong:(jlong)timespan
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
 <code>timespan</code> argument or a maximum size specified by the <code>count</code> argument (whichever is reached
 first). When the source Observable completes or encounters an error, the resulting Observable emits the
 current buffer and propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. It requests <code>Long.MAX_VALUE</code>
 upstream and does not obey downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>buffer</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timespan
 the period of time each buffer collects items before it is emitted and replaced with a new
 buffer
 @param unit
 the unit of time which applies to the <code>timespan</code> argument
 @param count
 the maximum size of each buffer before it is emitted
 @return an Observable that emits connected, non-overlapping buffers of items emitted by the source
 Observable, after a fixed duration or when the buffer reaches maximum capacity (whichever occurs
 first)
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithLong:(jlong)timespan
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                         withInt:(jint)count;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
 <code>timespan</code> argument as measured on the specified <code>scheduler</code>, or a maximum size specified by
 the <code>count</code> argument (whichever is reached first). When the source Observable completes or
 encounters an error, the resulting Observable emits the current buffer and propagates the notification
 from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. It requests <code>Long.MAX_VALUE</code>
 upstream and does not obey downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timespan
 the period of time each buffer collects items before it is emitted and replaced with a new
 buffer
 @param unit
 the unit of time which applies to the <code>timespan</code> argument
 @param count
 the maximum size of each buffer before it is emitted
 @param scheduler
 the <code>Scheduler</code> to use when determining the end and start of a buffer
 @return an Observable that emits connected, non-overlapping buffers of items emitted by the source
 Observable after a fixed duration or when the buffer reaches maximum capacity (whichever occurs
 first)
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithLong:(jlong)timespan
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                         withInt:(jint)count
                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
 <code>timespan</code> argument and on the specified <code>scheduler</code>. When the source Observable completes or
 encounters an error, the resulting Observable emits the current buffer and propagates the notification
 from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. It requests <code>Long.MAX_VALUE</code>
 upstream and does not obey downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timespan
 the period of time each buffer collects items before it is emitted and replaced with a new
 buffer
 @param unit
 the unit of time which applies to the <code>timespan</code> argument
 @param scheduler
 the <code>Scheduler</code> to use when determining the end and start of a buffer
 @return an Observable that emits connected, non-overlapping buffers of items emitted by the source
 Observable within a fixed duration
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithLong:(jlong)timespan
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits buffers of items it collects from the source Observable.
 The resulting
 Observable emits buffers that it creates when the specified <code>bufferOpenings</code> Observable emits an
 item, and closes when the Observable returned from <code>bufferClosingSelector</code> emits an item.
 <p>
 <img width="640" height="470" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it is instead controlled by the given Observables and
 buffers data. It requests <code>Long.MAX_VALUE</code> upstream and does not obey downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>buffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param bufferOpenings
 the Observable that, when it emits an item, causes a new buffer to be created
 @param bufferClosingSelector
 the <code>Func1</code> that is used to produce an Observable for every buffer created. When this
 Observable emits an item, the associated buffer is emitted.
 @return an Observable that emits buffers, containing items from the source Observable, that are created
 and closed when the specified Observables emit items
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithRxObservable:(RxObservable *)bufferOpenings
                    withRxFunctionsFunc1:(id<RxFunctionsFunc1>)bufferClosingSelector;

/*!
 @brief Returns an Observable that emits non-overlapping buffered items from the source Observable each time the
 specified boundary Observable emits an item.
 <p>
 <img width="640" height="395" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.png" alt="">
 <p>
 Completion of either the source or the boundary Observable causes the returned Observable to emit the
 latest buffer and complete.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it is instead controlled by the <code>Observable</code>
 <code>boundary</code> and buffers data. It requests <code>Long.MAX_VALUE</code> upstream and does not obey
 downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>buffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param boundary
 the boundary Observable
 @return an Observable that emits buffered items from the source Observable when the boundary Observable
 emits an item
 - seealso: #buffer(rx.Observable,int)
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 */
- (RxObservable *)bufferWithRxObservable:(RxObservable *)boundary;

/*!
 @brief Returns an Observable that emits non-overlapping buffered items from the source Observable each time the
 specified boundary Observable emits an item.
 <p>
 <img width="640" height="395" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.png" alt="">
 <p>
 Completion of either the source or the boundary Observable causes the returned Observable to emit the
 latest buffer and complete.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it is instead controlled by the <code>Observable</code>
 <code>boundary</code> and buffers data. It requests <code>Long.MAX_VALUE</code> upstream and does not obey
 downstream requests.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>buffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param boundary
 the boundary Observable
 @param initialCapacity
 the initial capacity of each buffer chunk
 @return an Observable that emits buffered items from the source Observable when the boundary Observable
 emits an item
 - seealso: <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
 - seealso: #buffer(rx.Observable,int)
 */
- (RxObservable *)bufferWithRxObservable:(RxObservable *)boundary
                                 withInt:(jint)initialCapacity;

/*!
 @brief Caches the emissions from the source Observable and replays them in order to any subsequent Subscribers.
 This method has similar behavior to <code>replay</code> except that this auto-subscribes to the source
 Observable rather than returning a <code>ConnectableObservable</code> for which you must call
 <code>connect</code> to activate the subscription.
 <p>
 <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cache.png" alt="">
 <p>
 This is useful when you want an Observable to cache responses and you can't control the
 subscribe/unsubscribe behavior of all the <code>Subscriber</code>s.
 <p>
 When you call <code>cache</code>, it does not yet subscribe to the source Observable and so does not yet
 begin caching items. This only happens when the first Subscriber calls the resulting Observable's
 <code>subscribe</code> method.
 <p>
 <em>Note:</em> You sacrifice the ability to unsubscribe from the origin when you use the <code>cache</code>
 Observer so be careful not to use this Observer on Observables that emit an infinite or very large number
 of items that will use up memory.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support upstream backpressure as it is purposefully requesting and caching
 everything emitted.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>cache</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that, when first subscribed to, caches all of its items and notifications for the
 benefit of subsequent subscribers
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)cache;

/*!
 - seealso: #cacheWithInitialCapacity(int)
 */
- (RxObservable *)cacheWithInt:(jint)initialCapacity;

/*!
 @brief Caches emissions from the source Observable and replays them in order to any subsequent Subscribers.
 This method has similar behavior to <code>replay</code> except that this auto-subscribes to the source
 Observable rather than returning a <code>ConnectableObservable</code> for which you must call
 <code>connect</code> to activate the subscription.
 <p>
 <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cache.png" alt="">
 <p>
 This is useful when you want an Observable to cache responses and you can't control the
 subscribe/unsubscribe behavior of all the <code>Subscriber</code>s.
 <p>
 When you call <code>cache</code>, it does not yet subscribe to the source Observable and so does not yet
 begin caching items. This only happens when the first Subscriber calls the resulting Observable's
 <code>subscribe</code> method.
 <p>
 <em>Note:</em> You sacrifice the ability to unsubscribe from the origin when you use the <code>cache</code>
 Observer so be careful not to use this Observer on Observables that emit an infinite or very large number
 of items that will use up memory.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support upstream backpressure as it is purposefully requesting and caching
 everything emitted.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>cache</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 <p>
 <em>Note:</em> The capacity hint is not an upper bound on cache size. For that, consider
 <code>replay(int)</code> in combination with <code>ConnectableObservable.autoConnect()</code> or similar.
 @param initialCapacity hint for number of items to cache (for optimizing underlying data structure)
 @return an Observable that, when first subscribed to, caches all of its items and notifications for the
 benefit of subsequent subscribers
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)cacheWithInitialCapacityWithInt:(jint)initialCapacity;

/*!
 @brief Returns an Observable that emits the items emitted by the source Observable, converted to the specified
 type.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cast.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>cast</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param klass
 the target class type that <code>cast</code> will cast the items emitted by the source Observable
 into before emitting them from the resulting Observable
 @return an Observable that emits each item from the source Observable after converting it to the
 specified type
 - seealso: <a href="http://reactivex.io/documentation/operators/map.html">ReactiveX operators documentation: Map</a>
 */
- (RxObservable *)castWithIOSClass:(IOSClass *)klass;

/*!
 @brief Collects items emitted by the source Observable into a single mutable data structure and returns an
 Observable that emits this structure.
 <p>
 <img width="640" height="330" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collect.png" alt="">
 <p>
 This is a simplified version of <code>reduce</code> that does not need to return the state on each pass.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure because by intent it will receive all values and reduce
 them to a single <code>onNext</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>collect</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param stateFactory
 the mutable data structure that will collect the items
 @param collector
 a function that accepts the <code>state</code> and an emitted item, and modifies <code>state</code>
 accordingly
 @return an Observable that emits the result of collecting the values emitted by the source Observable
 into a single mutable data structure
 - seealso: <a href="http://reactivex.io/documentation/operators/reduce.html">ReactiveX operators documentation: Reduce</a>
 */
- (RxObservable *)collectWithRxFunctionsFunc0:(id<RxFunctionsFunc0>)stateFactory
                       withRxFunctionsAction2:(id<RxFunctionsAction2>)collector;

/*!
 @brief Combines a collection of source Observables by emitting an item that aggregates the latest values of each of
 the source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources
 the collection of source Observables
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithJavaLangIterable:(id<JavaLangIterable>)sources
                               withRxFunctionsFuncN:(id<RxFunctionsFuncN>)combineFunction;

/*!
 @brief Combines a list of source Observables by emitting an item that aggregates the latest values of each of
 the source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources
 the list of source Observables
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithJavaUtilList:(id<JavaUtilList>)sources
                           withRxFunctionsFuncN:(id<RxFunctionsFuncN>)combineFunction;

/*!
 @brief Combines two source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from either of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 the second source Observable
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithRxObservable:(RxObservable *)o1
                               withRxObservable:(RxObservable *)o2
                           withRxFunctionsFunc2:(id<RxFunctionsFunc2>)combineFunction;

/*!
 @brief Combines three source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 the second source Observable
 @param o3
 the third source Observable
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithRxObservable:(RxObservable *)o1
                               withRxObservable:(RxObservable *)o2
                               withRxObservable:(RxObservable *)o3
                           withRxFunctionsFunc3:(id<RxFunctionsFunc3>)combineFunction;

/*!
 @brief Combines four source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 the second source Observable
 @param o3
 the third source Observable
 @param o4
 the fourth source Observable
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithRxObservable:(RxObservable *)o1
                               withRxObservable:(RxObservable *)o2
                               withRxObservable:(RxObservable *)o3
                               withRxObservable:(RxObservable *)o4
                           withRxFunctionsFunc4:(id<RxFunctionsFunc4>)combineFunction;

/*!
 @brief Combines five source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 the second source Observable
 @param o3
 the third source Observable
 @param o4
 the fourth source Observable
 @param o5
 the fifth source Observable
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithRxObservable:(RxObservable *)o1
                               withRxObservable:(RxObservable *)o2
                               withRxObservable:(RxObservable *)o3
                               withRxObservable:(RxObservable *)o4
                               withRxObservable:(RxObservable *)o5
                           withRxFunctionsFunc5:(id<RxFunctionsFunc5>)combineFunction;

/*!
 @brief Combines six source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 the second source Observable
 @param o3
 the third source Observable
 @param o4
 the fourth source Observable
 @param o5
 the fifth source Observable
 @param o6
 the sixth source Observable
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithRxObservable:(RxObservable *)o1
                               withRxObservable:(RxObservable *)o2
                               withRxObservable:(RxObservable *)o3
                               withRxObservable:(RxObservable *)o4
                               withRxObservable:(RxObservable *)o5
                               withRxObservable:(RxObservable *)o6
                           withRxFunctionsFunc6:(id<RxFunctionsFunc6>)combineFunction;

/*!
 @brief Combines seven source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 the second source Observable
 @param o3
 the third source Observable
 @param o4
 the fourth source Observable
 @param o5
 the fifth source Observable
 @param o6
 the sixth source Observable
 @param o7
 the seventh source Observable
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithRxObservable:(RxObservable *)o1
                               withRxObservable:(RxObservable *)o2
                               withRxObservable:(RxObservable *)o3
                               withRxObservable:(RxObservable *)o4
                               withRxObservable:(RxObservable *)o5
                               withRxObservable:(RxObservable *)o6
                               withRxObservable:(RxObservable *)o7
                           withRxFunctionsFunc7:(id<RxFunctionsFunc7>)combineFunction;

/*!
 @brief Combines eight source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 the second source Observable
 @param o3
 the third source Observable
 @param o4
 the fourth source Observable
 @param o5
 the fifth source Observable
 @param o6
 the sixth source Observable
 @param o7
 the seventh source Observable
 @param o8
 the eighth source Observable
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithRxObservable:(RxObservable *)o1
                               withRxObservable:(RxObservable *)o2
                               withRxObservable:(RxObservable *)o3
                               withRxObservable:(RxObservable *)o4
                               withRxObservable:(RxObservable *)o5
                               withRxObservable:(RxObservable *)o6
                               withRxObservable:(RxObservable *)o7
                               withRxObservable:(RxObservable *)o8
                           withRxFunctionsFunc8:(id<RxFunctionsFunc8>)combineFunction;

/*!
 @brief Combines nine source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 the second source Observable
 @param o3
 the third source Observable
 @param o4
 the fourth source Observable
 @param o5
 the fifth source Observable
 @param o6
 the sixth source Observable
 @param o7
 the seventh source Observable
 @param o8
 the eighth source Observable
 @param o9
 the ninth source Observable
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestWithRxObservable:(RxObservable *)o1
                               withRxObservable:(RxObservable *)o2
                               withRxObservable:(RxObservable *)o3
                               withRxObservable:(RxObservable *)o4
                               withRxObservable:(RxObservable *)o5
                               withRxObservable:(RxObservable *)o6
                               withRxObservable:(RxObservable *)o7
                               withRxObservable:(RxObservable *)o8
                               withRxObservable:(RxObservable *)o9
                           withRxFunctionsFunc9:(id<RxFunctionsFunc9>)combineFunction;

/*!
 @brief Combines a collection of source Observables by emitting an item that aggregates the latest values of each of
 the source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function and delays any error from the sources until
 all source Observables terminate.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>combineLatest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources
 the collection of source Observables
 @param combineFunction
 the aggregation function used to combine the items emitted by the source Observables
 @return an Observable that emits items that are the result of combining the items emitted by the source
 Observables by means of the given aggregation function
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
+ (RxObservable *)combineLatestDelayErrorWithJavaLangIterable:(id<JavaLangIterable>)sources
                                         withRxFunctionsFuncN:(id<RxFunctionsFuncN>)combineFunction;

/*!
 @brief Transform an Observable by applying a particular Transformer function to it.
 <p>
 This method operates on the Observable itself whereas <code>lift</code> operates on the Observable's
 Subscribers or Observers.
 <p>
 If the operator you are creating is designed to act on the individual items emitted by a source
 Observable, use <code>lift</code>. If your operator is designed to transform the source Observable as a whole
 (for instance, by applying a particular set of existing RxJava operators to it) use <code>compose</code>.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>compose</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param transformer implements the function that transforms the source Observable
 @return the source Observable, transformed by the transformer function
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators">RxJava wiki: Implementing Your Own Operators</a>
 */
- (RxObservable *)composeWithRxObservable_Transformer:(id<RxObservable_Transformer>)transformer;

/*!
 @brief Returns an Observable that emits the items emitted by each of the Observables emitted by the source
 Observable, one after the other, without interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param observables
 an Observable that emits Observables
 @return an Observable that emits items all of the items emitted by the Observables emitted by
 <code>observables</code>, one after the other, without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
+ (RxObservable *)concatWithRxObservable:(RxObservable *)observables;

/*!
 @brief Returns an Observable that emits the items emitted by two Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be concatenated
 @param t2
 an Observable to be concatenated
 @return an Observable that emits items emitted by the two source Observables, one after the other,
 without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
+ (RxObservable *)concatWithRxObservable:(RxObservable *)t1
                        withRxObservable:(RxObservable *)t2;

/*!
 @brief Returns an Observable that emits the items emitted by three Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be concatenated
 @param t2
 an Observable to be concatenated
 @param t3
 an Observable to be concatenated
 @return an Observable that emits items emitted by the three source Observables, one after the other,
 without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
+ (RxObservable *)concatWithRxObservable:(RxObservable *)t1
                        withRxObservable:(RxObservable *)t2
                        withRxObservable:(RxObservable *)t3;

/*!
 @brief Returns an Observable that emits the items emitted by four Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be concatenated
 @param t2
 an Observable to be concatenated
 @param t3
 an Observable to be concatenated
 @param t4
 an Observable to be concatenated
 @return an Observable that emits items emitted by the four source Observables, one after the other,
 without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
+ (RxObservable *)concatWithRxObservable:(RxObservable *)t1
                        withRxObservable:(RxObservable *)t2
                        withRxObservable:(RxObservable *)t3
                        withRxObservable:(RxObservable *)t4;

/*!
 @brief Returns an Observable that emits the items emitted by five Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be concatenated
 @param t2
 an Observable to be concatenated
 @param t3
 an Observable to be concatenated
 @param t4
 an Observable to be concatenated
 @param t5
 an Observable to be concatenated
 @return an Observable that emits items emitted by the five source Observables, one after the other,
 without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
+ (RxObservable *)concatWithRxObservable:(RxObservable *)t1
                        withRxObservable:(RxObservable *)t2
                        withRxObservable:(RxObservable *)t3
                        withRxObservable:(RxObservable *)t4
                        withRxObservable:(RxObservable *)t5;

/*!
 @brief Returns an Observable that emits the items emitted by six Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be concatenated
 @param t2
 an Observable to be concatenated
 @param t3
 an Observable to be concatenated
 @param t4
 an Observable to be concatenated
 @param t5
 an Observable to be concatenated
 @param t6
 an Observable to be concatenated
 @return an Observable that emits items emitted by the six source Observables, one after the other,
 without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
+ (RxObservable *)concatWithRxObservable:(RxObservable *)t1
                        withRxObservable:(RxObservable *)t2
                        withRxObservable:(RxObservable *)t3
                        withRxObservable:(RxObservable *)t4
                        withRxObservable:(RxObservable *)t5
                        withRxObservable:(RxObservable *)t6;

/*!
 @brief Returns an Observable that emits the items emitted by seven Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be concatenated
 @param t2
 an Observable to be concatenated
 @param t3
 an Observable to be concatenated
 @param t4
 an Observable to be concatenated
 @param t5
 an Observable to be concatenated
 @param t6
 an Observable to be concatenated
 @param t7
 an Observable to be concatenated
 @return an Observable that emits items emitted by the seven source Observables, one after the other,
 without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
+ (RxObservable *)concatWithRxObservable:(RxObservable *)t1
                        withRxObservable:(RxObservable *)t2
                        withRxObservable:(RxObservable *)t3
                        withRxObservable:(RxObservable *)t4
                        withRxObservable:(RxObservable *)t5
                        withRxObservable:(RxObservable *)t6
                        withRxObservable:(RxObservable *)t7;

/*!
 @brief Returns an Observable that emits the items emitted by eight Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be concatenated
 @param t2
 an Observable to be concatenated
 @param t3
 an Observable to be concatenated
 @param t4
 an Observable to be concatenated
 @param t5
 an Observable to be concatenated
 @param t6
 an Observable to be concatenated
 @param t7
 an Observable to be concatenated
 @param t8
 an Observable to be concatenated
 @return an Observable that emits items emitted by the eight source Observables, one after the other,
 without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
+ (RxObservable *)concatWithRxObservable:(RxObservable *)t1
                        withRxObservable:(RxObservable *)t2
                        withRxObservable:(RxObservable *)t3
                        withRxObservable:(RxObservable *)t4
                        withRxObservable:(RxObservable *)t5
                        withRxObservable:(RxObservable *)t6
                        withRxObservable:(RxObservable *)t7
                        withRxObservable:(RxObservable *)t8;

/*!
 @brief Returns an Observable that emits the items emitted by nine Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be concatenated
 @param t2
 an Observable to be concatenated
 @param t3
 an Observable to be concatenated
 @param t4
 an Observable to be concatenated
 @param t5
 an Observable to be concatenated
 @param t6
 an Observable to be concatenated
 @param t7
 an Observable to be concatenated
 @param t8
 an Observable to be concatenated
 @param t9
 an Observable to be concatenated
 @return an Observable that emits items emitted by the nine source Observables, one after the other,
 without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
+ (RxObservable *)concatWithRxObservable:(RxObservable *)t1
                        withRxObservable:(RxObservable *)t2
                        withRxObservable:(RxObservable *)t3
                        withRxObservable:(RxObservable *)t4
                        withRxObservable:(RxObservable *)t5
                        withRxObservable:(RxObservable *)t6
                        withRxObservable:(RxObservable *)t7
                        withRxObservable:(RxObservable *)t8
                        withRxObservable:(RxObservable *)t9;

/*!
 @brief Concatenates the Iterable sequence of Observables into a single sequence by subscribing to each Observable,
 one after the other, one at a time and delays any errors till the all inner Observables terminate.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd><code>concatDelayError</code> fully supports backpressure.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concatDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources the Iterable sequence of Observables
 @return the new Observable with the concatenating behavior
 */
+ (RxObservable *)concatDelayErrorWithJavaLangIterable:(id<JavaLangIterable>)sources;

/*!
 @brief Concatenates the Observable sequence of Observables into a single sequence by subscribing to each inner Observable,
 one after the other, one at a time and delays any errors till the all inner and the outer Observables terminate.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd><code>concatDelayError</code> fully supports backpressure.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concatDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources the Observable sequence of Observables
 @return the new Observable with the concatenating behavior
 */
+ (RxObservable *)concatDelayErrorWithRxObservable:(RxObservable *)sources;

/*!
 @brief Concatenates a sequence of Observables eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources a sequence of Observables that need to be eagerly concatenated
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithJavaLangIterable:(id<JavaLangIterable>)sources;

/*!
 @brief Concatenates a sequence of Observables eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources a sequence of Observables that need to be eagerly concatenated
 @param capacityHint hints about the number of expected source sequence values
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithJavaLangIterable:(id<JavaLangIterable>)sources
                                          withInt:(jint)capacityHint;

/*!
 @brief Concatenates an Observable sequence of Observables eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 emitted source Observables as they are observed. The operator buffers the values emitted by these
 Observables and then drains them in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources a sequence of Observables that need to be eagerly concatenated
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)sources;

/*!
 @brief Concatenates an Observable sequence of Observables eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 emitted source Observables as they are observed. The operator buffers the values emitted by these
 Observables and then drains them in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sources a sequence of Observables that need to be eagerly concatenated
 @param capacityHint hints about the number of expected source sequence values
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)sources
                                      withInt:(jint)capacityHint;

/*!
 @brief Concatenates two source Observables eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1 the first source
 @param o2 the second source
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)o1
                             withRxObservable:(RxObservable *)o2;

/*!
 @brief Concatenates three sources eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1 the first source
 @param o2 the second source
 @param o3 the third source
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)o1
                             withRxObservable:(RxObservable *)o2
                             withRxObservable:(RxObservable *)o3;

/*!
 @brief Concatenates four sources eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1 the first source
 @param o2 the second source
 @param o3 the third source
 @param o4 the fourth source
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)o1
                             withRxObservable:(RxObservable *)o2
                             withRxObservable:(RxObservable *)o3
                             withRxObservable:(RxObservable *)o4;

/*!
 @brief Concatenates five sources eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1 the first source
 @param o2 the second source
 @param o3 the third source
 @param o4 the fourth source
 @param o5 the fifth source
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)o1
                             withRxObservable:(RxObservable *)o2
                             withRxObservable:(RxObservable *)o3
                             withRxObservable:(RxObservable *)o4
                             withRxObservable:(RxObservable *)o5;

/*!
 @brief Concatenates six sources eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1 the first source
 @param o2 the second source
 @param o3 the third source
 @param o4 the fourth source
 @param o5 the fifth source
 @param o6 the sixth source
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)o1
                             withRxObservable:(RxObservable *)o2
                             withRxObservable:(RxObservable *)o3
                             withRxObservable:(RxObservable *)o4
                             withRxObservable:(RxObservable *)o5
                             withRxObservable:(RxObservable *)o6;

/*!
 @brief Concatenates seven sources eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1 the first source
 @param o2 the second source
 @param o3 the third source
 @param o4 the fourth source
 @param o5 the fifth source
 @param o6 the sixth source
 @param o7 the seventh source
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)o1
                             withRxObservable:(RxObservable *)o2
                             withRxObservable:(RxObservable *)o3
                             withRxObservable:(RxObservable *)o4
                             withRxObservable:(RxObservable *)o5
                             withRxObservable:(RxObservable *)o6
                             withRxObservable:(RxObservable *)o7;

/*!
 @brief Concatenates eight sources eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1 the first source
 @param o2 the second source
 @param o3 the third source
 @param o4 the fourth source
 @param o5 the fifth source
 @param o6 the sixth source
 @param o7 the seventh source
 @param o8 the eighth source
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)o1
                             withRxObservable:(RxObservable *)o2
                             withRxObservable:(RxObservable *)o3
                             withRxObservable:(RxObservable *)o4
                             withRxObservable:(RxObservable *)o5
                             withRxObservable:(RxObservable *)o6
                             withRxObservable:(RxObservable *)o7
                             withRxObservable:(RxObservable *)o8;

/*!
 @brief Concatenates nine sources eagerly into a single stream of values.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them
 in order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1 the first source
 @param o2 the second source
 @param o3 the third source
 @param o4 the fourth source
 @param o5 the fifth source
 @param o6 the sixth source
 @param o7 the seventh source
 @param o8 the eighth source
 @param o9 the ninth source
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)concatEagerWithRxObservable:(RxObservable *)o1
                             withRxObservable:(RxObservable *)o2
                             withRxObservable:(RxObservable *)o3
                             withRxObservable:(RxObservable *)o4
                             withRxObservable:(RxObservable *)o5
                             withRxObservable:(RxObservable *)o6
                             withRxObservable:(RxObservable *)o7
                             withRxObservable:(RxObservable *)o8
                             withRxObservable:(RxObservable *)o9;

/*!
 @brief Returns a new Observable that emits items resulting from applying a function that you supply to each item
 emitted by the source Observable, where that function returns an Observable, and then emitting the items
 that result from concatenating those resulting Observables.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concatMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param func
 a function that, when applied to an item emitted by the source Observable, returns an
 Observable
 @return an Observable that emits the result of applying the transformation function to each item emitted
 by the source Observable and concatenating the Observables obtained from this transformation
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 */
- (RxObservable *)concatMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)func;

/*!
 @brief Maps each of the items into an Observable, subscribes to them one after the other,
 one at a time and emits their values in order
 while delaying any error from either this or any of the inner Observables
 till all of them terminate.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd><code>concatMapDelayError</code> fully supports backpressure.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concatMapDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param func the function that maps the items of this Observable into the inner Observables.
 @return the new Observable instance with the concatenation behavior
 */
- (RxObservable *)concatMapDelayErrorWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)func;

/*!
 @brief Maps a sequence of values into Observables and concatenates these Observables eagerly into a single
 Observable.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them in
 order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param mapper the function that maps a sequence of values into a sequence of Observables that will be
 eagerly concatenated
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)concatMapEagerWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)mapper;

/*!
 @brief Maps a sequence of values into Observables and concatenates these Observables eagerly into a single
 Observable.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them in
 order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param mapper the function that maps a sequence of values into a sequence of Observables that will be
 eagerly concatenated
 @param capacityHint hints about the number of expected source sequence values
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)concatMapEagerWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)mapper
                                             withInt:(jint)capacityHint;

/*!
 @brief Maps a sequence of values into Observables and concatenates these Observables eagerly into a single
 Observable.
 <p>
 Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
 source Observables. The operator buffers the values emitted by these Observables and then drains them in
 order, each one after the previous one completes.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
 are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param mapper the function that maps a sequence of values into a sequence of Observables that will be
 eagerly concatenated
 @param capacityHint hints about the number of expected source sequence values
 @param maxConcurrent the maximum number of concurrent subscribed observables
  javadoc fails to describe the return value
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)concatMapEagerWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)mapper
                                             withInt:(jint)capacityHint
                                             withInt:(jint)maxConcurrent;

/*!
 @brief Returns an Observable that concatenate each item emitted by the source Observable with the values in an
 Iterable corresponding to that item that is generated by a selector.
 <p>
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concatMapIterable</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param collectionSelector
 a function that returns an Iterable sequence of values for when given an item emitted by the
 source Observable
 @return an Observable that emits the results of concatenating the items emitted by the source Observable with
 the values in the Iterables corresponding to those items, as generated by <code>collectionSelector</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 */
- (RxObservable *)concatMapIterableWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)collectionSelector;

/*!
 @brief Returns an Observable that emits the items emitted from the current Observable, then the next, one after
 the other, without interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>concat</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be concatenated after the current
 @return an Observable that emits items emitted by the two source Observables, one after the other,
 without interleaving them
 - seealso: <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
 */
- (RxObservable *)concatWithWithRxObservable:(RxObservable *)t1;

/*!
 @brief Returns an Observable that emits a Boolean that indicates whether the source Observable emitted a
 specified item.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/contains.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>contains</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param element
 the item to search for in the emissions from the source Observable
 @return an Observable that emits <code>true</code> if the specified item is emitted by the source Observable,
 or <code>false</code> if the source Observable completes without emitting that item
 - seealso: <a href="http://reactivex.io/documentation/operators/contains.html">ReactiveX operators documentation: Contains</a>
 */
- (RxObservable *)containsWithId:(id)element;

/*!
 @brief Returns an Observable that emits the count of the total number of items emitted by the source Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/count.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure because by intent it will receive all values and reduce
 them to a single <code>onNext</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>count</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits a single item: the number of elements emitted by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/count.html">ReactiveX operators documentation: Count</a>
 - seealso: #countLong()
 */
- (RxObservable *)count;

/*!
 @brief Returns an Observable that counts the total number of items emitted by the source Observable and emits
 this count as a 64-bit Long.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/longCount.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure because by intent it will receive all values and reduce
 them to a single <code>onNext</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>countLong</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits a single item: the number of items emitted by the source Observable as a
 64-bit Long item
 - seealso: <a href="http://reactivex.io/documentation/operators/count.html">ReactiveX operators documentation: Count</a>
 - seealso: #count()
 */
- (RxObservable *)countLong;

/*!
 @brief Returns an Observable that respects the back-pressure semantics.
 When the returned Observable is 
 subscribed to it will initiate the given <code>AsyncOnSubscribe</code>'s life cycle for 
 generating events. 
 <p><b>Note:</b> the <code>AsyncOnSubscribe</code> is useful for observable sources of data that are 
 necessarily asynchronous (RPC, external services, etc). Typically most use cases can be solved 
 with the <code>synchronous overload</code>.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/create-async.png" alt="">
 <p>
 See <a href="http://go.microsoft.com/fwlink/?LinkID=205219">Rx Design Guidelines (PDF)</a> for detailed
 information.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>create</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param asyncOnSubscribe
 an implementation of <code>AsyncOnSubscribe</code>. There are many static creation methods 
 on the class for convenience.
 @return an Observable that, when a <code>Subscriber</code> subscribes to it, will execute the specified
 function
 - seealso: <code>AsyncOnSubscribe</code> <code>static create*</code> methods
 - seealso: <a href="http://reactivex.io/documentation/operators/create.html">ReactiveX operators documentation: Create</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)createWithRxObservablesAsyncOnSubscribe:(RxObservablesAsyncOnSubscribe *)asyncOnSubscribe;

/*!
 @brief Returns an Observable that will execute the specified function when a <code>Subscriber</code> subscribes to
 it.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/create.png" alt="">
 <p>
 Write the function you pass to <code>create</code> so that it behaves as an Observable: It should invoke the
 Subscriber's <code>onNext</code>, <code>onError</code>, and
 <code>onCompleted</code> methods appropriately.
 <p>
 A well-formed Observable must invoke either the Subscriber's <code>onCompleted</code> method exactly once or
 its <code>onError</code> method exactly once.
 <p>
 See <a href="http://go.microsoft.com/fwlink/?LinkID=205219">Rx Design Guidelines (PDF)</a> for detailed
 information.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>create</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param f
 a function that accepts an <code>Subscriber<T></code>, and invokes its <code>onNext</code>,
 <code>onError</code>, and <code>onCompleted</code> methods as appropriate
 @return an Observable that, when a <code>Subscriber</code> subscribes to it, will execute the specified
 function
 - seealso: <a href="http://reactivex.io/documentation/operators/create.html">ReactiveX operators documentation: Create</a>
 */
+ (RxObservable *)createWithRxObservable_OnSubscribe:(id<RxObservable_OnSubscribe>)f;

/*!
 @brief Returns an Observable that respects the back-pressure semantics.
 When the returned Observable is 
 subscribed to it will initiate the given <code>SyncOnSubscribe</code>'s life cycle for 
 generating events. 
 <p><b>Note:</b> the <code>SyncOnSubscribe</code> provides a generic way to fulfill data by iterating 
 over a (potentially stateful) function (e.g. reading data off of a channel, a parser, ). If your 
 data comes directly from an asynchronous/potentially concurrent source then consider using the
 <code>asynchronous overload</code>.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/create-sync.png" alt="">
 <p>
 See <a href="http://go.microsoft.com/fwlink/?LinkID=205219">Rx Design Guidelines (PDF)</a> for detailed
 information.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>create</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param syncOnSubscribe
 an implementation of <code>SyncOnSubscribe</code>. There are many static creation methods 
 on the class for convenience.
 @return an Observable that, when a <code>Subscriber</code> subscribes to it, will execute the specified
 function
 - seealso: <code>SyncOnSubscribe</code> <code>static create*</code> methods
 - seealso: <a href="http://reactivex.io/documentation/operators/create.html">ReactiveX operators documentation: Create</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)createWithRxObservablesSyncOnSubscribe:(RxObservablesSyncOnSubscribe *)syncOnSubscribe;

/*!
 @brief Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
 source Observable that are followed by another item within a computed debounce duration.
 <p>
 <img width="640" height="425" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.f.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses the <code>debounceSelector</code> to mark
 boundaries.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>debounce</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param debounceSelector
 function to retrieve a sequence that indicates the throttle duration for each item
 @return an Observable that omits items emitted by the source Observable that are followed by another item
 within a computed debounce duration
 - seealso: <a href="http://reactivex.io/documentation/operators/debounce.html">ReactiveX operators documentation: Debounce</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 */
- (RxObservable *)debounceWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)debounceSelector;

/*!
 @brief Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
 source Observable that are followed by newer items before a timeout value expires.
 The timer resets on
 each emission.
 <p>
 <em>Note:</em> If items keep being emitted by the source Observable faster than the timeout then no items
 will be emitted by the resulting Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.png" alt="">
 <p>
 Information on debounce vs throttle:
 <p>
 <ul>
 <li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">Debounce and Throttle: visual explanation</a></li>
 <li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/">Debouncing: javascript methods</a></li>
 <li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/">Javascript - don't spam your server: debounce and throttle</a></li>
 </ul>
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>debounce</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timeout
 the time each item has to be "the most recent" of those emitted by the source Observable to
 ensure that it's not dropped
 @param unit
 the <code>TimeUnit</code> for the timeout
 @return an Observable that filters out items from the source Observable that are too quickly followed by
 newer items
 - seealso: <a href="http://reactivex.io/documentation/operators/debounce.html">ReactiveX operators documentation: Debounce</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 - seealso: #throttleWithTimeout(long,TimeUnit)
 */
- (RxObservable *)debounceWithLong:(jlong)timeout
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
 source Observable that are followed by newer items before a timeout value expires on a specified
 Scheduler.
 The timer resets on each emission.
 <p>
 <em>Note:</em> If items keep being emitted by the source Observable faster than the timeout then no items
 will be emitted by the resulting Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.s.png" alt="">
 <p>
 Information on debounce vs throttle:
 <p>
 <ul>
 <li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">Debounce and Throttle: visual explanation</a></li>
 <li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/">Debouncing: javascript methods</a></li>
 <li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/">Javascript - don't spam your server: debounce and throttle</a></li>
 </ul>
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timeout
 the time each item has to be "the most recent" of those emitted by the source Observable to
 ensure that it's not dropped
 @param unit
 the unit of time for the specified timeout
 @param scheduler
 the <code>Scheduler</code> to use internally to manage the timers that handle the timeout for each
 item
 @return an Observable that filters out items from the source Observable that are too quickly followed by
 newer items
 - seealso: <a href="http://reactivex.io/documentation/operators/debounce.html">ReactiveX operators documentation: Debounce</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 - seealso: #throttleWithTimeout(long,TimeUnit,Scheduler)
 */
- (RxObservable *)debounceWithLong:(jlong)timeout
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                   withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits the items emitted by the source Observable or a specified default item
 if the source Observable is empty.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defaultIfEmpty.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>defaultIfEmpty</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param defaultValue
 the item to emit if the source Observable emits no items
 @return an Observable that emits either the specified default item if the source Observable emits no
 items, or the items emitted by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/defaultifempty.html">ReactiveX operators documentation: DefaultIfEmpty</a>
 */
- (RxObservable *)defaultIfEmptyWithId:(id)defaultValue;

/*!
 @brief Returns an Observable that calls an Observable factory to create an Observable for each new Observer
 that subscribes.
 That is, for each subscriber, the actual Observable that subscriber observes is
 determined by the factory function.
 <p>
 <img width="640" height="340" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defer.png" alt="">
 <p>
 The defer Observer allows you to defer or delay emitting items from an Observable until such time as an
 Observer subscribes to the Observable. This allows an <code>Observer</code> to easily obtain updates or a
 refreshed version of the sequence.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>defer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param observableFactory
 the Observable factory function to invoke for each <code>Observer</code> that subscribes to the
 resulting Observable
 @return an Observable whose <code>Observer</code>s' subscriptions trigger an invocation of the given
 Observable factory function
 - seealso: <a href="http://reactivex.io/documentation/operators/defer.html">ReactiveX operators documentation: Defer</a>
 */
+ (RxObservable *)deferWithRxFunctionsFunc0:(id<RxFunctionsFunc0>)observableFactory;

/*!
 @brief Returns an Observable that delays the subscription to and emissions from the source Observable via another
 Observable on a per-item basis.
 <p>
 <img width="640" height="450" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.oo.png" alt="">
 <p>
 <em>Note:</em> the resulting Observable will immediately propagate any <code>onError</code> notification
 from the source Observable.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>delay</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param subscriptionDelay
 a function that returns an Observable that triggers the subscription to the source Observable
 once it emits any item
 @param itemDelay
 a function that returns an Observable for each item emitted by the source Observable, which is
 then used to delay the emission of that item by the resulting Observable until the Observable
 returned from <code>itemDelay</code> emits an item
 @return an Observable that delays the subscription and emissions of the source Observable via another
 Observable on a per-item basis
 - seealso: <a href="http://reactivex.io/documentation/operators/delay.html">ReactiveX operators documentation: Delay</a>
 */
- (RxObservable *)delayWithRxFunctionsFunc0:(id<RxFunctionsFunc0>)subscriptionDelay
                       withRxFunctionsFunc1:(id<RxFunctionsFunc1>)itemDelay;

/*!
 @brief Returns an Observable that delays the emissions of the source Observable via another Observable on a
 per-item basis.
 <p>
 <img width="640" height="450" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.o.png" alt="">
 <p>
 <em>Note:</em> the resulting Observable will immediately propagate any <code>onError</code> notification
 from the source Observable.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>delay</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param itemDelay
 a function that returns an Observable for each item emitted by the source Observable, which is
 then used to delay the emission of that item by the resulting Observable until the Observable
 returned from <code>itemDelay</code> emits an item
 @return an Observable that delays the emissions of the source Observable via another Observable on a
 per-item basis
 - seealso: <a href="http://reactivex.io/documentation/operators/delay.html">ReactiveX operators documentation: Delay</a>
 */
- (RxObservable *)delayWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)itemDelay;

/*!
 @brief Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
 specified delay.
 Error notifications from the source Observable are not delayed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>delay</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param delay
 the delay to shift the source by
 @param unit
 the <code>TimeUnit</code> in which <code>period</code> is defined
 @return the source Observable shifted in time by the specified delay
 - seealso: <a href="http://reactivex.io/documentation/operators/delay.html">ReactiveX operators documentation: Delay</a>
 */
- (RxObservable *)delayWithLong:(jlong)delay
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
 specified delay.
 Error notifications from the source Observable are not delayed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.s.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param delay
 the delay to shift the source by
 @param unit
 the time unit of <code>delay</code>
 @param scheduler
 the <code>Scheduler</code> to use for delaying
 @return the source Observable shifted in time by the specified delay
 - seealso: <a href="http://reactivex.io/documentation/operators/delay.html">ReactiveX operators documentation: Delay</a>
 */
- (RxObservable *)delayWithLong:(jlong)delay
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that delays the subscription to the source Observable until a second Observable
 emits an item.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.o.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param subscriptionDelay
 a function that returns an Observable that triggers the subscription to the source Observable
 once it emits any item
 @return an Observable that delays the subscription to the source Observable until the Observable returned
 by <code>subscriptionDelay</code> emits an item
 - seealso: <a href="http://reactivex.io/documentation/operators/delay.html">ReactiveX operators documentation: Delay</a>
 */
- (RxObservable *)delaySubscriptionWithRxFunctionsFunc0:(id<RxFunctionsFunc0>)subscriptionDelay;

/*!
 @brief Returns an Observable that delays the subscription to the source Observable by a given amount of time.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>delay</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param delay
 the time to delay the subscription
 @param unit
 the time unit of <code>delay</code>
 @return an Observable that delays the subscription to the source Observable by the given amount
 - seealso: <a href="http://reactivex.io/documentation/operators/delay.html">ReactiveX operators documentation: Delay</a>
 */
- (RxObservable *)delaySubscriptionWithLong:(jlong)delay
             withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that delays the subscription to the source Observable by a given amount of time,
 both waiting and subscribing on a given Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.s.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param delay
 the time to delay the subscription
 @param unit
 the time unit of <code>delay</code>
 @param scheduler
 the Scheduler on which the waiting and subscription will happen
 @return an Observable that delays the subscription to the source Observable by a given
 amount, waiting and subscribing on the given Scheduler
 - seealso: <a href="http://reactivex.io/documentation/operators/delay.html">ReactiveX operators documentation: Delay</a>
 */
- (RxObservable *)delaySubscriptionWithLong:(jlong)delay
             withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                            withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that delays the subscription to this Observable
 until the other Observable emits an element or completes normally.
 <p>
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>The operator forwards the backpressure requests to this Observable once
 the subscription happens and requests Long.MAX_VALUE from the other Observable</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This method does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param other the other Observable that should trigger the subscription
 to this Observable.
 @return an Observable that delays the subscription to this Observable
 until the other Observable emits an element or completes normally.
 */
- (RxObservable *)delaySubscriptionWithRxObservable:(RxObservable *)other;

/*!
 @brief Returns an Observable that reverses the effect of <code>materialize</code> by transforming the
 <code>Notification</code> objects emitted by the source Observable into the items or notifications they
 represent.
 <p>
 <img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/dematerialize.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>dematerialize</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits the items and notifications embedded in the <code>Notification</code> objects
 emitted by the source Observable
 @throws OnErrorNotImplementedException
 if the source Observable is not of type <code>Observable<Notification<T>></code>
 - seealso: <a href="http://reactivex.io/documentation/operators/materialize-dematerialize.html">ReactiveX operators documentation: Dematerialize</a>
 */
- (RxObservable *)dematerialize;

/*!
 @brief Returns an Observable that emits all items emitted by the source Observable that are distinct.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>distinct</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits only those items emitted by the source Observable that are distinct from
 each other
 - seealso: <a href="http://reactivex.io/documentation/operators/distinct.html">ReactiveX operators documentation: Distinct</a>
 */
- (RxObservable *)distinct;

/*!
 @brief Returns an Observable that emits all items emitted by the source Observable that are distinct according
 to a key selector function.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.key.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>distinct</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 a function that projects an emitted item to a key value that is used to decide whether an item
 is distinct from another one or not
 @return an Observable that emits those items emitted by the source Observable that have distinct keys
 - seealso: <a href="http://reactivex.io/documentation/operators/distinct.html">ReactiveX operators documentation: Distinct</a>
 */
- (RxObservable *)distinctWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector;

/*!
 @brief Returns an Observable that emits all items emitted by the source Observable that are distinct from their
 immediate predecessors.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>distinctUntilChanged</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits those items from the source Observable that are distinct from their
 immediate predecessors
 - seealso: <a href="http://reactivex.io/documentation/operators/distinct.html">ReactiveX operators documentation: Distinct</a>
 */
- (RxObservable *)distinctUntilChanged;

/*!
 @brief Returns an Observable that emits all items emitted by the source Observable that are distinct from their
 immediate predecessors, according to a key selector function.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.key.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>distinctUntilChanged</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 a function that projects an emitted item to a key value that is used to decide whether an item
 is distinct from another one or not
 @return an Observable that emits those items from the source Observable whose keys are distinct from
 those of their immediate predecessors
 - seealso: <a href="http://reactivex.io/documentation/operators/distinct.html">ReactiveX operators documentation: Distinct</a>
 */
- (RxObservable *)distinctUntilChangedWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector;

/*!
 @brief Registers an <code>Action0</code> to be called when this Observable invokes either
 <code>onCompleted</code> or <code>onError</code>.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/finallyDo.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doAfterTerminate</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param action
 an <code>Action0</code> to be invoked when the source Observable finishes
 @return an Observable that emits the same items as the source Observable, then invokes the
 <code>Action0</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 - seealso: #doOnTerminate(Action0)
 */
- (RxObservable *)doAfterTerminateWithRxFunctionsAction0:(id<RxFunctionsAction0>)action;

/*!
 @brief Modifies the source Observable so that it invokes an action when it calls <code>onCompleted</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnCompleted.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doOnCompleted</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onCompleted
 the action to invoke when the source Observable calls <code>onCompleted</code>
 @return the source Observable with the side-effecting behavior applied
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 */
- (RxObservable *)doOnCompletedWithRxFunctionsAction0:(id<RxFunctionsAction0>)onCompleted;

/*!
 @brief Modifies the source Observable so that it invokes an action for each item it emits.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doOnEach</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNotification
 the action to invoke for each item emitted by the source Observable
 @return the source Observable with the side-effecting behavior applied
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 */
- (RxObservable *)doOnEachWithRxFunctionsAction1:(id<RxFunctionsAction1>)onNotification;

/*!
 @brief Modifies the source Observable so that it notifies an Observer for each item it emits.
 <p>
 In case the <code>onError</code> of the supplied observer throws, the downstream will receive a composite
 exception containing the original exception and the exception thrown by <code>onError</code>. If either the
 <code>onNext</code> or the <code>onCompleted</code> method of the supplied observer throws, the downstream will be
 terminated and will receive this thrown exception.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doOnEach</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param observer
 the action to invoke for each item emitted by the source Observable
 @return the source Observable with the side-effecting behavior applied
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 */
- (RxObservable *)doOnEachWithRxObserver:(id<RxObserver>)observer;

/*!
 @brief Modifies the source Observable so that it invokes an action if it calls <code>onError</code>.
 <p>
 In case the <code>onError</code> action throws, the downstream will receive a composite exception containing
 the original exception and the exception thrown by <code>onError</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doOnError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onError
 the action to invoke if the source Observable calls <code>onError</code>
 @return the source Observable with the side-effecting behavior applied
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 */
- (RxObservable *)doOnErrorWithRxFunctionsAction1:(id<RxFunctionsAction1>)onError;

/*!
 @brief Modifies the source Observable so that it invokes an action when it calls <code>onNext</code>.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doOnNext</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNext
 the action to invoke when the source Observable calls <code>onNext</code>
 @return the source Observable with the side-effecting behavior applied
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 */
- (RxObservable *)doOnNextWithRxFunctionsAction1:(id<RxFunctionsAction1>)onNext;

/*!
 @brief Modifies the source <code>Observable</code> so that it invokes the given action when it receives a
 request for more items.
 <p>
 <b>Note:</b> This operator is for tracing the internal behavior of back-pressure request
 patterns and generally intended for debugging use.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doOnRequest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onRequest
 the action that gets called when an observer requests items from this
 <code>Observable</code>
 @return the source <code>Observable</code> modified so as to call this Action when appropriate
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators
     *      documentation: Do</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
 with the release number)
 */
- (RxObservable *)doOnRequestWithRxFunctionsAction1:(id<RxFunctionsAction1>)onRequest;

/*!
 @brief Modifies the source <code>Observable</code> so that it invokes the given action when it is subscribed from
 its subscribers.
 Each subscription will result in an invocation of the given action except when the
 source <code>Observable</code> is reference counted, in which case the source <code>Observable</code> will invoke
 the given action for the first subscription.
 <p>
 <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSubscribe.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doOnSubscribe</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param subscribe
 the action that gets called when an observer subscribes to this <code>Observable</code>
 @return the source <code>Observable</code> modified so as to call this Action when appropriate
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 */
- (RxObservable *)doOnSubscribeWithRxFunctionsAction0:(id<RxFunctionsAction0>)subscribe;

/*!
 @brief Modifies the source Observable so that it invokes an action when it calls <code>onCompleted</code> or
 <code>onError</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.png" alt="">
 <p>
 This differs from <code>finallyDo</code> in that this happens <em>before</em> the <code>onCompleted</code> or
 <code>onError</code> notification.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doOnTerminate</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onTerminate
 the action to invoke when the source Observable calls <code>onCompleted</code> or <code>onError</code>
 @return the source Observable with the side-effecting behavior applied
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 - seealso: #finallyDo(Action0)
 */
- (RxObservable *)doOnTerminateWithRxFunctionsAction0:(id<RxFunctionsAction0>)onTerminate;

/*!
 @brief Calls the unsubscribe <code>Action0</code> if the downstream unsubscribes the sequence.
 <p>
 The action is shared between subscriptions and thus may be called concurrently from multiple
 threads; the action must be thread safe.
 <p>
 If the action throws a runtime exception, that exception is rethrown by the <code>unsubscribe()</code> call,
 sometimes as a <code>CompositeException</code> if there were multiple exceptions along the way.
 <p>
 Note that terminal events trigger the action unless the <code>Observable</code> is subscribed to via <code>unsafeSubscribe()</code>.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnUnsubscribe.png" alt="">
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd><code>doOnUnsubscribe</code> does not interact with backpressure requests or value delivery; backpressure
 behavior is preserved between its upstream and its downstream.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>doOnUnsubscribe</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param unsubscribe
 the action that gets called when this <code>Observable</code> is unsubscribed
 @return the source <code>Observable</code> modified so as to call this Action when appropriate
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 */
- (RxObservable *)doOnUnsubscribeWithRxFunctionsAction0:(id<RxFunctionsAction0>)unsubscribe;

/*!
 @brief Returns an Observable that emits the single item at a specified index in a sequence of emissions from a
 source Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>elementAt</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param index
 the zero-based index of the item to retrieve
 @return an Observable that emits a single item: the item at the specified position in the sequence of
 those emitted by the source Observable
 @throws IndexOutOfBoundsException
 if <code>index</code> is greater than or equal to the number of items emitted by the source
 Observable, or
 if <code>index</code> is less than 0
 - seealso: <a href="http://reactivex.io/documentation/operators/elementat.html">ReactiveX operators documentation: ElementAt</a>
 */
- (RxObservable *)elementAtWithInt:(jint)index;

/*!
 @brief Returns an Observable that emits the item found at a specified index in a sequence of emissions from a
 source Observable, or a default item if that index is out of range.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrDefault.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>elementAtOrDefault</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param index
 the zero-based index of the item to retrieve
 @param defaultValue
 the default item
 @return an Observable that emits the item at the specified position in the sequence emitted by the source
 Observable, or the default item if that index is outside the bounds of the source sequence
 @throws IndexOutOfBoundsException
 if <code>index</code> is less than 0
 - seealso: <a href="http://reactivex.io/documentation/operators/elementat.html">ReactiveX operators documentation: ElementAt</a>
 */
- (RxObservable *)elementAtOrDefaultWithInt:(jint)index
                                     withId:(id)defaultValue;

/*!
 @brief Returns an Observable that emits no items to the <code>Observer</code> and immediately invokes its
 <code>onCompleted</code> method.
 <p>
 <img width="640" height="190" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/empty.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>empty</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits no items to the <code>Observer</code> but immediately invokes the
 <code>Observer</code>'s <code>onCompleted</code> method
 - seealso: <a href="http://reactivex.io/documentation/operators/empty-never-throw.html">ReactiveX operators documentation: Empty</a>
 */
+ (RxObservable *)empty;

/*!
 @brief Returns an Observable that invokes an <code>Observer</code>'s <code>onError</code> method when the
 Observer subscribes to it.
 <p>
 <img width="640" height="190" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>error</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param exception
 the particular Throwable to pass to <code>onError</code>
 @return an Observable that invokes the <code>Observer</code>'s <code>onError</code> method when
 the Observer subscribes to it
 - seealso: <a href="http://reactivex.io/documentation/operators/empty-never-throw.html">ReactiveX operators documentation: Throw</a>
 */
+ (RxObservable *)errorWithNSException:(NSException *)exception;

/*!
 @brief Returns an Observable that emits <code>true</code> if any item emitted by the source Observable satisfies a
 specified condition, otherwise <code>false</code>.
 <em>Note:</em> this always emits <code>false</code> if the
 source Observable is empty.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/exists.png" alt="">
 <p>
 In Rx.Net this is the <code>any</code> Observer but we renamed it in RxJava to better match Java naming
 idioms.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>exists</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 the condition to test items emitted by the source Observable
 @return an Observable that emits a Boolean that indicates whether any item emitted by the source
 Observable satisfies the <code>predicate</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/contains.html">ReactiveX operators documentation: Contains</a>
 */
- (RxObservable *)existsWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Passes all emitted values from this Observable to the provided conversion function to be collected and
 returned as a single value.
 Note that it is legal for a conversion function to return an Observable
 (enabling chaining). 
 @param conversion a function that converts from this <code>Observable<T></code> to an <code>R</code>
 @return an instance of R created by the provided conversion function
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (id)extendWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)conversion;

/*!
 @brief Filters items emitted by an Observable by only emitting those that satisfy a specified predicate.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/filter.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>filter</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 a function that evaluates each item emitted by the source Observable, returning <code>true</code>
 if it passes the filter
 @return an Observable that emits only those items emitted by the source Observable that the filter
 evaluates as <code>true</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/filter.html">ReactiveX operators documentation: Filter</a>
 */
- (RxObservable *)filterWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Registers an <code>Action0</code> to be called when this Observable invokes either
 <code>onCompleted</code> or <code>onError</code>.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/finallyDo.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>finallyDo</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param action
 an <code>Action0</code> to be invoked when the source Observable finishes
 @return an Observable that emits the same items as the source Observable, then invokes the
 <code>Action0</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
 - seealso: #doOnTerminate(Action0)
 */
- (RxObservable *)finallyDoWithRxFunctionsAction0:(id<RxFunctionsAction0>)action;

/*!
 @brief Returns an Observable that emits only the very first item emitted by the source Observable, or notifies
 of an <code>NoSuchElementException</code> if the source Observable is empty.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>first</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits only the very first item emitted by the source Observable, or raises an
 <code>NoSuchElementException</code> if the source Observable is empty
 - seealso: <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
 */
- (RxObservable *)first;

/*!
 @brief Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
 a specified condition, or notifies of an <code>NoSuchElementException</code> if no such items are emitted.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstN.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>first</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 the condition that an item emitted by the source Observable has to satisfy
 @return an Observable that emits only the very first item emitted by the source Observable that satisfies
 the <code>predicate</code>, or raises an <code>NoSuchElementException</code> if no such items are emitted
 - seealso: <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
 */
- (RxObservable *)firstWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Returns an Observable that emits only the very first item emitted by the source Observable, or a default
 item if the source Observable completes without emitting anything.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrDefault.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>firstOrDefault</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param defaultValue
 the default item to emit if the source Observable doesn't emit anything
 @return an Observable that emits only the very first item from the source, or a default item if the
 source Observable completes without emitting any items
 - seealso: <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
 */
- (RxObservable *)firstOrDefaultWithId:(id)defaultValue;

/*!
 @brief Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
 a specified condition, or a default item if the source Observable emits no such items.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrDefaultN.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>firstOrDefault</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 the condition any item emitted by the source Observable has to satisfy
 @param defaultValue
 the default item to emit if the source Observable doesn't emit anything that satisfies the
 <code>predicate</code>
 @return an Observable that emits only the very first item emitted by the source Observable that satisfies
 the <code>predicate</code>, or a default item if the source Observable emits no such items
 - seealso: <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
 */
- (RxObservable *)firstOrDefaultWithId:(id)defaultValue
                  withRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Returns an Observable that emits items based on applying a function that you supply to each item emitted
 by the source Observable, where that function returns an Observable, and then merging those resulting
 Observables and emitting the results of this merger.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param func
 a function that, when applied to an item emitted by the source Observable, returns an
 Observable
 @return an Observable that emits the result of applying the transformation function to each item emitted
 by the source Observable and merging the results of the Observables obtained from this
 transformation
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 */
- (RxObservable *)flatMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)func;

/*!
 @brief Returns an Observable that applies a function to each item emitted or notification raised by the source
 Observable and then flattens the Observables returned from these functions and emits the resulting items.
 <p>
 <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNext
 a function that returns an Observable to merge for each item emitted by the source Observable
 @param onError
 a function that returns an Observable to merge for an onError notification from the source
 Observable
 @param onCompleted
 a function that returns an Observable to merge for an onCompleted notification from the source
 Observable
 @return an Observable that emits the results of merging the Observables returned from applying the
 specified functions to the emissions and notifications of the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 */
- (RxObservable *)flatMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)onNext
                         withRxFunctionsFunc1:(id<RxFunctionsFunc1>)onError
                         withRxFunctionsFunc0:(id<RxFunctionsFunc0>)onCompleted;

/*!
 @brief Returns an Observable that applies a function to each item emitted or notification raised by the source
 Observable and then flattens the Observables returned from these functions and emits the resulting items, 
 while limiting the maximum number of concurrent subscriptions to these Observables.
 <p>
 <!-- <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.png" alt=""> -->
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNext
 a function that returns an Observable to merge for each item emitted by the source Observable
 @param onError
 a function that returns an Observable to merge for an onError notification from the source
 Observable
 @param onCompleted
 a function that returns an Observable to merge for an onCompleted notification from the source
 Observable
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits the results of merging the Observables returned from applying the
 specified functions to the emissions and notifications of the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)flatMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)onNext
                         withRxFunctionsFunc1:(id<RxFunctionsFunc1>)onError
                         withRxFunctionsFunc0:(id<RxFunctionsFunc0>)onCompleted
                                      withInt:(jint)maxConcurrent;

/*!
 @brief Returns an Observable that emits items based on applying a function that you supply to each item emitted
 by the source Observable, where that function returns an Observable, and then merging those resulting
 Observables and emitting the results of this merger, while limiting the maximum number of concurrent
 subscriptions to these Observables.
 <p>
 <!-- <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png" alt=""> -->
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param func
 a function that, when applied to an item emitted by the source Observable, returns an
 Observable
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits the result of applying the transformation function to each item emitted
 by the source Observable and merging the results of the Observables obtained from this
 transformation
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)flatMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)func
                                      withInt:(jint)maxConcurrent;

/*!
 @brief Returns an Observable that emits the results of a specified function to the pair of values emitted by the
 source Observable and a specified collection Observable.
 <p>
 <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param collectionSelector
 a function that returns an Observable for each item emitted by the source Observable
 @param resultSelector
 a function that combines one item emitted by each of the source and collection Observables and
 returns an item to be emitted by the resulting Observable
 @return an Observable that emits the results of applying a function to a pair of values emitted by the
 source Observable and the collection Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 */
- (RxObservable *)flatMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)collectionSelector
                         withRxFunctionsFunc2:(id<RxFunctionsFunc2>)resultSelector;

/*!
 @brief Returns an Observable that emits the results of a specified function to the pair of values emitted by the
 source Observable and a specified collection Observable, while limiting the maximum number of concurrent
 subscriptions to these Observables.
 <p>
 <!-- <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png" alt=""> -->
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param collectionSelector
 a function that returns an Observable for each item emitted by the source Observable
 @param resultSelector
 a function that combines one item emitted by each of the source and collection Observables and
 returns an item to be emitted by the resulting Observable
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits the results of applying a function to a pair of values emitted by the
 source Observable and the collection Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)flatMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)collectionSelector
                         withRxFunctionsFunc2:(id<RxFunctionsFunc2>)resultSelector
                                      withInt:(jint)maxConcurrent;

/*!
 @brief Returns an Observable that merges each item emitted by the source Observable with the values in an
 Iterable corresponding to that item that is generated by a selector.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMapIterable</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param collectionSelector
 a function that returns an Iterable sequence of values for when given an item emitted by the
 source Observable
 @return an Observable that emits the results of merging the items emitted by the source Observable with
 the values in the Iterables corresponding to those items, as generated by <code>collectionSelector</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 */
- (RxObservable *)flatMapIterableWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)collectionSelector;

/*!
 @brief Returns an Observable that merges each item emitted by the source Observable with the values in an
 Iterable corresponding to that item that is generated by a selector, while limiting the number of concurrent
 subscriptions to these Observables.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMapIterable</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param collectionSelector
 a function that returns an Iterable sequence of values for when given an item emitted by the
 source Observable
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits the results of merging the items emitted by the source Observable with
 the values in the Iterables corresponding to those items, as generated by <code>collectionSelector</code>
 @throws IllegalArgumentException
 if <code>maxConcurrent</code> is less than or equal to 0
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)flatMapIterableWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)collectionSelector
                                              withInt:(jint)maxConcurrent;

/*!
 @brief Returns an Observable that emits the results of applying a function to the pair of values from the source
 Observable and an Iterable corresponding to that item that is generated by a selector.
 <p>
 <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.r.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMapIterable</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param collectionSelector
 a function that returns an Iterable sequence of values for each item emitted by the source
 Observable
 @param resultSelector
 a function that returns an item based on the item emitted by the source Observable and the
 Iterable returned for that item by the <code>collectionSelector</code>
 @return an Observable that emits the items returned by <code>resultSelector</code> for each item in the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 */
- (RxObservable *)flatMapIterableWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)collectionSelector
                                 withRxFunctionsFunc2:(id<RxFunctionsFunc2>)resultSelector;

/*!
 @brief Returns an Observable that emits the results of applying a function to the pair of values from the source
 Observable and an Iterable corresponding to that item that is generated by a selector, while limiting the
 number of concurrent subscriptions to these Observables.
 <p>
 <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.r.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>flatMapIterable</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param collectionSelector
 a function that returns an Iterable sequence of values for each item emitted by the source
 Observable
 @param resultSelector
 a function that returns an item based on the item emitted by the source Observable and the
 Iterable returned for that item by the <code>collectionSelector</code>
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits the items returned by <code>resultSelector</code> for each item in the source
 Observable
 @throws IllegalArgumentException
 if <code>maxConcurrent</code> is less than or equal to 0
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)flatMapIterableWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)collectionSelector
                                 withRxFunctionsFunc2:(id<RxFunctionsFunc2>)resultSelector
                                              withInt:(jint)maxConcurrent;

/*!
 @brief Subscribes to the <code>Observable</code> and receives notifications for each element.
 <p>
 Alias to <code>subscribe(Action1)</code>
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>forEach</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNext
 <code>Action1</code> to execute for each item.
 @throws IllegalArgumentException
 if <code>onNext</code> is null
 @throws OnErrorNotImplementedException
 if the Observable calls <code>onError</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
 */
- (void)forEachWithRxFunctionsAction1:(id<RxFunctionsAction1>)onNext;

/*!
 @brief Subscribes to the <code>Observable</code> and receives notifications for each element and error events.
 <p>
 Alias to <code>subscribe(Action1,Action1)</code>
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>forEach</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNext
 <code>Action1</code> to execute for each item.
 @param onError
 <code>Action1</code> to execute when an error is emitted.
 @throws IllegalArgumentException
 if <code>onNext</code> is null, or
 if <code>onError</code> is null
 @throws OnErrorNotImplementedException
 if the Observable calls <code>onError</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
 */
- (void)forEachWithRxFunctionsAction1:(id<RxFunctionsAction1>)onNext
               withRxFunctionsAction1:(id<RxFunctionsAction1>)onError;

/*!
 @brief Subscribes to the <code>Observable</code> and receives notifications for each element and the terminal events.
 <p>
 Alias to <code>subscribe(Action1,Action1,Action0)</code>
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>forEach</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNext
 <code>Action1</code> to execute for each item.
 @param onError
 <code>Action1</code> to execute when an error is emitted.
 @param onComplete
 <code>Action0</code> to execute when completion is signalled.
 @throws IllegalArgumentException
 if <code>onNext</code> is null, or
 if <code>onError</code> is null, or
 if <code>onComplete</code> is null
 @throws OnErrorNotImplementedException
 if the Observable calls <code>onError</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
 */
- (void)forEachWithRxFunctionsAction1:(id<RxFunctionsAction1>)onNext
               withRxFunctionsAction1:(id<RxFunctionsAction1>)onError
               withRxFunctionsAction0:(id<RxFunctionsAction0>)onComplete;

/*!
 @brief Converts a <code>Future</code> into an Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.png" alt="">
 <p>
 You can convert any object that supports the <code>Future</code> interface into an Observable that emits the
 return value of the <code>Future.get</code> method of that object, by passing the object into the <code>from</code>
 method.
 <p>
 <em>Important note:</em> This Observable is blocking; you cannot unsubscribe from it.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>from</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param future
 the source <code>Future</code>
 @return an Observable that emits the item from the source <code>Future</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
 */
+ (RxObservable *)fromWithJavaUtilConcurrentFuture:(id<JavaUtilConcurrentFuture>)future;

/*!
 @brief Converts a <code>Future</code> into an Observable, with a timeout on the Future.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.png" alt="">
 <p>
 You can convert any object that supports the <code>Future</code> interface into an Observable that emits the
 return value of the <code>Future.get</code> method of that object, by passing the object into the <code>from</code>
 method.
 <p>
 <em>Important note:</em> This Observable is blocking; you cannot unsubscribe from it.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>from</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param future
 the source <code>Future</code>
 @param timeout
 the maximum time to wait before calling <code>get</code>
 @param unit
 the <code>TimeUnit</code> of the <code>timeout</code> argument
 @return an Observable that emits the item from the source <code>Future</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
 */
+ (RxObservable *)fromWithJavaUtilConcurrentFuture:(id<JavaUtilConcurrentFuture>)future
                                          withLong:(jlong)timeout
                    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Converts a <code>Future</code>, operating on a specified <code>Scheduler</code>, into an Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.s.png" alt="">
 <p>
 You can convert any object that supports the <code>Future</code> interface into an Observable that emits the
 return value of the <code>Future.get</code> method of that object, by passing the object into the <code>from</code>
 method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param future
 the source <code>Future</code>
 @param scheduler
 the <code>Scheduler</code> to wait for the Future on. Use a Scheduler such as
 <code>Schedulers.io()</code> that can block and wait on the Future
 @return an Observable that emits the item from the source <code>Future</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
 */
+ (RxObservable *)fromWithJavaUtilConcurrentFuture:(id<JavaUtilConcurrentFuture>)future
                                   withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Converts an <code>Iterable</code> sequence into an Observable that emits the items in the sequence.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>from</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param iterable
 the source <code>Iterable</code> sequence
 @return an Observable that emits each item in the source <code>Iterable</code> sequence
 - seealso: <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
 */
+ (RxObservable *)fromWithJavaLangIterable:(id<JavaLangIterable>)iterable;

/*!
 @brief Converts an Array into an Observable that emits the items in the Array.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>from</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param array
 the source Array
 @return an Observable that emits each item in the source Array
 - seealso: <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
 */
+ (RxObservable *)fromWithNSObjectArray:(IOSObjectArray *)array;

/*!
 @brief Returns an Observable that, when an observer subscribes to it, invokes a function you specify and then
 emits the value returned from that function.
 <p>
 <img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCallable.png" alt="">
 <p>
 This allows you to defer the execution of the function you specify until an observer subscribes to the
 Observable. That is to say, it makes the function "lazy."
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>fromCallable</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param func
 a function, the execution of which should be deferred; <code>fromCallable</code> will invoke this
 function only when an observer subscribes to the Observable that <code>fromCallable</code> returns
 @return an Observable whose <code>Observer</code>s' subscriptions trigger an invocation of the given function
 - seealso: #defer(Func0)
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)fromCallableWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable>)func;

/*!
 @brief Groups the items emitted by an <code>Observable</code> according to a specified criterion, and emits these
 grouped items as <code>GroupedObservable</code>s.
 The emitted <code>GroupedObservable</code> allows only a single 
 <code>Subscriber</code> during its lifetime and if this <code>Subscriber</code> unsubscribes before the 
 source terminates, the next emission by the source having the same key will trigger a new 
 <code>GroupedObservable</code> emission.
 <p>
 <img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png" alt="">
 <p>
 <em>Note:</em> A <code>GroupedObservable</code> will cache the items it is to emit until such time as it
 is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
 <code>GroupedObservable</code>s that do not concern you. Instead, you can signal to them that they may
 discard their buffers by applying an operator like <code>ignoreElements</code> to them.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>groupBy</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 a function that extracts the key for each item
 @return an <code>Observable</code> that emits <code>GroupedObservable</code>s, each of which corresponds to a
 unique key value and each of which emits those items from the source Observable that share that
 key value
 - seealso: <a href="http://reactivex.io/documentation/operators/groupby.html">ReactiveX operators documentation: GroupBy</a>
 */
- (RxObservable *)groupByWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector;

/*!
 @brief Groups the items emitted by an <code>Observable</code> according to a specified criterion, and emits these
 grouped items as <code>GroupedObservable</code>s.
 The emitted <code>GroupedObservable</code> allows only a single 
 <code>Subscriber</code> during its lifetime and if this <code>Subscriber</code> unsubscribes before the 
 source terminates, the next emission by the source having the same key will trigger a new 
 <code>GroupedObservable</code> emission.
 <p>
 <img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png" alt="">
 <p>
 <em>Note:</em> A <code>GroupedObservable</code> will cache the items it is to emit until such time as it
 is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
 <code>GroupedObservable</code>s that do not concern you. Instead, you can signal to them that they may
 discard their buffers by applying an operator like <code>ignoreElements</code> to them.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>groupBy</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 a function that extracts the key for each item
 @param elementSelector
 a function that extracts the return element for each item
 @return an <code>Observable</code> that emits <code>GroupedObservable</code>s, each of which corresponds to a
 unique key value and each of which emits those items from the source Observable that share that
 key value
 - seealso: <a href="http://reactivex.io/documentation/operators/groupby.html">ReactiveX operators documentation: GroupBy</a>
 */
- (RxObservable *)groupByWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector
                         withRxFunctionsFunc1:(id<RxFunctionsFunc1>)elementSelector;

/*!
 @brief Returns an Observable that correlates two Observables when they overlap in time and groups the results.
 <p>
 There are no guarantees in what order the items get combined when multiple
 items from one or both source Observables overlap.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupJoin.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>groupJoin</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param right
 the other Observable to correlate items from the source Observable with
 @param leftDuration
 a function that returns an Observable whose emissions indicate the duration of the values of
 the source Observable
 @param rightDuration
 a function that returns an Observable whose emissions indicate the duration of the values of
 the <code>right</code> Observable
 @param resultSelector
 a function that takes an item emitted by each Observable and returns the value to be emitted
 by the resulting Observable
 @return an Observable that emits items based on combining those items emitted by the source Observables
 whose durations overlap
 - seealso: <a href="http://reactivex.io/documentation/operators/join.html">ReactiveX operators documentation: Join</a>
 */
- (RxObservable *)groupJoinWithRxObservable:(RxObservable *)right
                       withRxFunctionsFunc1:(id<RxFunctionsFunc1>)leftDuration
                       withRxFunctionsFunc1:(id<RxFunctionsFunc1>)rightDuration
                       withRxFunctionsFunc2:(id<RxFunctionsFunc2>)resultSelector;

/*!
 @brief Ignores all items emitted by the source Observable and only calls <code>onCompleted</code> or <code>onError</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ignoreElements.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>ignoreElements</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an empty Observable that only calls <code>onCompleted</code> or <code>onError</code>, based on which one is
 called by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/ignoreelements.html">ReactiveX operators documentation: IgnoreElements</a>
 */
- (RxObservable *)ignoreElements;

/*!
 @brief Returns an Observable that emits a <code>0L</code> after the <code>initialDelay</code> and ever increasing numbers
 after each <code>period</code> of time thereafter.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.p.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate
 it should slow the timer or use something like <code>onBackpressureDrop</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>interval</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param initialDelay
 the initial delay time to wait before emitting the first value of 0L
 @param period
 the period of time between emissions of the subsequent numbers
 @param unit
 the time unit for both <code>initialDelay</code> and <code>period</code>
 @return an Observable that emits a 0L after the <code>initialDelay</code> and ever increasing numbers after
 each <code>period</code> of time thereafter
 - seealso: <a href="http://reactivex.io/documentation/operators/interval.html">ReactiveX operators documentation: Interval</a>
 @since 1.0.12
 */
+ (RxObservable *)intervalWithLong:(jlong)initialDelay
                          withLong:(jlong)period
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits a <code>0L</code> after the <code>initialDelay</code> and ever increasing numbers
 after each <code>period</code> of time thereafter, on a specified <code>Scheduler</code>.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.ps.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate
 it should slow the timer or use something like <code>onBackpressureDrop</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param initialDelay
 the initial delay time to wait before emitting the first value of 0L
 @param period
 the period of time between emissions of the subsequent numbers
 @param unit
 the time unit for both <code>initialDelay</code> and <code>period</code>
 @param scheduler
 the Scheduler on which the waiting happens and items are emitted
 @return an Observable that emits a 0L after the <code>initialDelay</code> and ever increasing numbers after
 each <code>period</code> of time thereafter, while running on the given Scheduler
 - seealso: <a href="http://reactivex.io/documentation/operators/interval.html">ReactiveX operators documentation: Interval</a>
 @since 1.0.12
 */
+ (RxObservable *)intervalWithLong:(jlong)initialDelay
                          withLong:(jlong)period
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                   withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits a sequential number every specified interval of time.
 <p>
 <img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/interval.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>interval</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param interval
 interval size in time units (see below)
 @param unit
 time units to use for the interval size
 @return an Observable that emits a sequential number each time interval
 - seealso: <a href="http://reactivex.io/documentation/operators/interval.html">ReactiveX operators documentation: Interval</a>
 */
+ (RxObservable *)intervalWithLong:(jlong)interval
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits a sequential number every specified interval of time, on a
 specified Scheduler.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/interval.s.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param interval
 interval size in time units (see below)
 @param unit
 time units to use for the interval size
 @param scheduler
 the Scheduler to use for scheduling the items
 @return an Observable that emits a sequential number each time interval
 - seealso: <a href="http://reactivex.io/documentation/operators/interval.html">ReactiveX operators documentation: Interval</a>
 */
+ (RxObservable *)intervalWithLong:(jlong)interval
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                   withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits <code>true</code> if the source Observable is empty, otherwise <code>false</code>.
 <p>
 In Rx.Net this is negated as the <code>any</code> Observer but we renamed this in RxJava to better match Java
 naming idioms.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/isEmpty.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>isEmpty</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits a Boolean
 - seealso: <a href="http://reactivex.io/documentation/operators/contains.html">ReactiveX operators documentation: Contains</a>
 */
- (RxObservable *)isEmpty;

/*!
 @brief Correlates the items emitted by two Observables based on overlapping durations.
 <p>
 There are no guarantees in what order the items get combined when multiple
 items from one or both source Observables overlap.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/join_.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>join</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param right
 the second Observable to join items from
 @param leftDurationSelector
 a function to select a duration for each item emitted by the source Observable, used to
 determine overlap
 @param rightDurationSelector
 a function to select a duration for each item emitted by the <code>right</code> Observable, used to
 determine overlap
 @param resultSelector
 a function that computes an item to be emitted by the resulting Observable for any two
 overlapping items emitted by the two Observables
 @return an Observable that emits items correlating to items emitted by the source Observables that have
 overlapping durations
 - seealso: <a href="http://reactivex.io/documentation/operators/join.html">ReactiveX operators documentation: Join</a>
 */
- (RxObservable *)joinWithRxObservable:(RxObservable *)right
                  withRxFunctionsFunc1:(id<RxFunctionsFunc1>)leftDurationSelector
                  withRxFunctionsFunc1:(id<RxFunctionsFunc1>)rightDurationSelector
                  withRxFunctionsFunc2:(id<RxFunctionsFunc2>)resultSelector;

/*!
 @brief Returns an Observable that emits a single item and then completes.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.png" alt="">
 <p>
 To convert any object into an Observable that emits that object, pass that object into the <code>just</code>
 method.
 <p>
 This is similar to the <code>from(java.lang.Object[])</code> method, except that <code>from</code> will convert
 an <code>Iterable</code> object into an Observable that emits each of the items in the Iterable, one at a
 time, while the <code>just</code> method converts an Iterable into an Observable that emits the entire
 Iterable as a single item.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param value
 the item to emit
 @return an Observable that emits <code>value</code> as a single item and then completes
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)value;

/*!
 @brief Converts two items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 first item
 @param t2
 second item
 @return an Observable that emits each item
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)t1
                      withId:(id)t2;

/*!
 @brief Converts three items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 first item
 @param t2
 second item
 @param t3
 third item
 @return an Observable that emits each item
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)t1
                      withId:(id)t2
                      withId:(id)t3;

/*!
 @brief Converts four items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 first item
 @param t2
 second item
 @param t3
 third item
 @param t4
 fourth item
 @return an Observable that emits each item
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)t1
                      withId:(id)t2
                      withId:(id)t3
                      withId:(id)t4;

/*!
 @brief Converts five items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 first item
 @param t2
 second item
 @param t3
 third item
 @param t4
 fourth item
 @param t5
 fifth item
 @return an Observable that emits each item
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)t1
                      withId:(id)t2
                      withId:(id)t3
                      withId:(id)t4
                      withId:(id)t5;

/*!
 @brief Converts six items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 first item
 @param t2
 second item
 @param t3
 third item
 @param t4
 fourth item
 @param t5
 fifth item
 @param t6
 sixth item
 @return an Observable that emits each item
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)t1
                      withId:(id)t2
                      withId:(id)t3
                      withId:(id)t4
                      withId:(id)t5
                      withId:(id)t6;

/*!
 @brief Converts seven items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 first item
 @param t2
 second item
 @param t3
 third item
 @param t4
 fourth item
 @param t5
 fifth item
 @param t6
 sixth item
 @param t7
 seventh item
 @return an Observable that emits each item
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)t1
                      withId:(id)t2
                      withId:(id)t3
                      withId:(id)t4
                      withId:(id)t5
                      withId:(id)t6
                      withId:(id)t7;

/*!
 @brief Converts eight items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 first item
 @param t2
 second item
 @param t3
 third item
 @param t4
 fourth item
 @param t5
 fifth item
 @param t6
 sixth item
 @param t7
 seventh item
 @param t8
 eighth item
 @return an Observable that emits each item
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)t1
                      withId:(id)t2
                      withId:(id)t3
                      withId:(id)t4
                      withId:(id)t5
                      withId:(id)t6
                      withId:(id)t7
                      withId:(id)t8;

/*!
 @brief Converts nine items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 first item
 @param t2
 second item
 @param t3
 third item
 @param t4
 fourth item
 @param t5
 fifth item
 @param t6
 sixth item
 @param t7
 seventh item
 @param t8
 eighth item
 @param t9
 ninth item
 @return an Observable that emits each item
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)t1
                      withId:(id)t2
                      withId:(id)t3
                      withId:(id)t4
                      withId:(id)t5
                      withId:(id)t6
                      withId:(id)t7
                      withId:(id)t8
                      withId:(id)t9;

/*!
 @brief Converts ten items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>just</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 first item
 @param t2
 second item
 @param t3
 third item
 @param t4
 fourth item
 @param t5
 fifth item
 @param t6
 sixth item
 @param t7
 seventh item
 @param t8
 eighth item
 @param t9
 ninth item
 @param t10
 tenth item
 @return an Observable that emits each item
 - seealso: <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
 */
+ (RxObservable *)justWithId:(id)t1
                      withId:(id)t2
                      withId:(id)t3
                      withId:(id)t4
                      withId:(id)t5
                      withId:(id)t6
                      withId:(id)t7
                      withId:(id)t8
                      withId:(id)t9
                      withId:(id)t10;

/*!
 @brief Returns an Observable that emits the last item emitted by the source Observable or notifies observers of
 a <code>NoSuchElementException</code> if the source Observable is empty.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/last.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>last</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits the last item from the source Observable or notifies observers of an
 error
 - seealso: <a href="http://reactivex.io/documentation/operators/last.html">ReactiveX operators documentation: Last</a>
 */
- (RxObservable *)last;

/*!
 @brief Returns an Observable that emits only the last item emitted by the source Observable that satisfies a
 given condition, or notifies of a <code>NoSuchElementException</code> if no such items are emitted.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/last.p.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>last</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 the condition any source emitted item has to satisfy
 @return an Observable that emits only the last item satisfying the given condition from the source, or an
 <code>NoSuchElementException</code> if no such items are emitted
 @throws IllegalArgumentException
 if no items that match the predicate are emitted by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/last.html">ReactiveX operators documentation: Last</a>
 */
- (RxObservable *)lastWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Returns an Observable that emits only the last item emitted by the source Observable, or a default item
 if the source Observable completes without emitting any items.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrDefault.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>lastOrDefault</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param defaultValue
 the default item to emit if the source Observable is empty
 @return an Observable that emits only the last item emitted by the source Observable, or a default item
 if the source Observable is empty
 - seealso: <a href="http://reactivex.io/documentation/operators/last.html">ReactiveX operators documentation: Last</a>
 */
- (RxObservable *)lastOrDefaultWithId:(id)defaultValue;

/*!
 @brief Returns an Observable that emits only the last item emitted by the source Observable that satisfies a
 specified condition, or a default item if no such item is emitted by the source Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrDefault.p.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>lastOrDefault</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param defaultValue
 the default item to emit if the source Observable doesn't emit anything that satisfies the
 specified <code>predicate</code>
 @param predicate
 the condition any item emitted by the source Observable has to satisfy
 @return an Observable that emits only the last item emitted by the source Observable that satisfies the
 given condition, or a default item if no such item is emitted by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/last.html">ReactiveX operators documentation: Last</a>
 */
- (RxObservable *)lastOrDefaultWithId:(id)defaultValue
                 withRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Lifts a function to the current Observable and returns a new Observable that when subscribed to will pass
 the values of the current Observable through the Operator function.
 <p>
 In other words, this allows chaining Observers together on an Observable for acting on the values within
 the Observable.
 <p> <code>observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe()</code>
 <p>
 If the operator you are creating is designed to act on the individual items emitted by a source
 Observable, use <code>lift</code>. If your operator is designed to transform the source Observable as a whole
 (for instance, by applying a particular set of existing RxJava operators to it) use <code>compose</code>.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>lift</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param operator_ the Operator that implements the Observable-operating function to be applied to the source
 Observable
 @return an Observable that is the result of applying the lifted Operator to the source Observable
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators">RxJava wiki: Implementing Your Own Operators</a>
 */
- (RxObservable *)liftWithRxObservable_Operator:(id<RxObservable_Operator>)operator_;

/*!
 @brief Returns an Observable that emits only the first <code>count</code> items emitted by the source Observable.
 <p>
 Alias of <code>take(int)</code> to match Java 8 Stream API naming convention.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.png" alt="">
 <p>
 This method returns an Observable that will invoke a subscribing <code>Observer</code>'s
 <code>onNext</code> function a maximum of <code>count</code> times before invoking
 <code>onCompleted</code>.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>limit</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum number of items to emit
 @return an Observable that emits only the first <code>count</code> items emitted by the source Observable, or
 all of the items from the source Observable if that Observable emits fewer than <code>count</code> items
 - seealso: <a href="http://reactivex.io/documentation/operators/take.html">ReactiveX operators documentation: Take</a>
 */
- (RxObservable *)limitWithInt:(jint)count;

/*!
 @brief Returns an Observable that applies a specified function to each item emitted by the source Observable and
 emits the results of these function applications.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/map.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>map</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param func
 a function to apply to each item emitted by the Observable
 @return an Observable that emits the items from the source Observable, transformed by the specified
 function
 - seealso: <a href="http://reactivex.io/documentation/operators/map.html">ReactiveX operators documentation: Map</a>
 */
- (RxObservable *)mapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)func;

/*!
 @brief Returns an Observable that represents all of the emissions <em>and</em> notifications from the source
 Observable into emissions marked with their original types within <code>Notification</code> objects.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>materialize</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits items that are the result of materializing the items and notifications
 of the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/materialize-dematerialize.html">ReactiveX operators documentation: Materialize</a>
 */
- (RxObservable *)materialize;

/*!
 @brief Flattens an Iterable of Observables into one Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sequences
 the Iterable of Observables
 @return an Observable that emits items that are the result of flattening the items emitted by the
 Observables in the Iterable
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithJavaLangIterable:(id<JavaLangIterable>)sequences;

/*!
 @brief Flattens an Iterable of Observables into one Observable, without any transformation, while limiting the
 number of concurrent subscriptions to these Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sequences
 the Iterable of Observables
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits items that are the result of flattening the items emitted by the
 Observables in the Iterable
 @throws IllegalArgumentException
 if <code>maxConcurrent</code> is less than or equal to 0
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithJavaLangIterable:(id<JavaLangIterable>)sequences
                                    withInt:(jint)maxConcurrent;

/*!
 @brief Flattens an Observable that emits Observables into a single Observable that emits the items emitted by
 those Observables, without any transformation.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.oo.png" alt="">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param source
 an Observable that emits Observables
 @return an Observable that emits items that are the result of flattening the Observables emitted by the
 <code>source</code> Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)source;

/*!
 @brief Flattens an Observable that emits Observables into a single Observable that emits the items emitted by
 those Observables, without any transformation, while limiting the maximum number of concurrent
 subscriptions to these Observables.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.oo.png" alt="">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param source
 an Observable that emits Observables
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits items that are the result of flattening the Observables emitted by the
 <code>source</code> Observable
 @throws IllegalArgumentException
 if <code>maxConcurrent</code> is less than or equal to 0
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 @since 1.1.0
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)source
                                withInt:(jint)maxConcurrent;

/*!
 @brief Flattens two Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @return an Observable that emits all of the items emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)t1
                       withRxObservable:(RxObservable *)t2;

/*!
 @brief Flattens three Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @return an Observable that emits all of the items emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)t1
                       withRxObservable:(RxObservable *)t2
                       withRxObservable:(RxObservable *)t3;

/*!
 @brief Flattens four Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @return an Observable that emits all of the items emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)t1
                       withRxObservable:(RxObservable *)t2
                       withRxObservable:(RxObservable *)t3
                       withRxObservable:(RxObservable *)t4;

/*!
 @brief Flattens five Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @return an Observable that emits all of the items emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)t1
                       withRxObservable:(RxObservable *)t2
                       withRxObservable:(RxObservable *)t3
                       withRxObservable:(RxObservable *)t4
                       withRxObservable:(RxObservable *)t5;

/*!
 @brief Flattens six Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @param t6
 an Observable to be merged
 @return an Observable that emits all of the items emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)t1
                       withRxObservable:(RxObservable *)t2
                       withRxObservable:(RxObservable *)t3
                       withRxObservable:(RxObservable *)t4
                       withRxObservable:(RxObservable *)t5
                       withRxObservable:(RxObservable *)t6;

/*!
 @brief Flattens seven Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @param t6
 an Observable to be merged
 @param t7
 an Observable to be merged
 @return an Observable that emits all of the items emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)t1
                       withRxObservable:(RxObservable *)t2
                       withRxObservable:(RxObservable *)t3
                       withRxObservable:(RxObservable *)t4
                       withRxObservable:(RxObservable *)t5
                       withRxObservable:(RxObservable *)t6
                       withRxObservable:(RxObservable *)t7;

/*!
 @brief Flattens eight Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @param t6
 an Observable to be merged
 @param t7
 an Observable to be merged
 @param t8
 an Observable to be merged
 @return an Observable that emits all of the items emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)t1
                       withRxObservable:(RxObservable *)t2
                       withRxObservable:(RxObservable *)t3
                       withRxObservable:(RxObservable *)t4
                       withRxObservable:(RxObservable *)t5
                       withRxObservable:(RxObservable *)t6
                       withRxObservable:(RxObservable *)t7
                       withRxObservable:(RxObservable *)t8;

/*!
 @brief Flattens nine Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @param t6
 an Observable to be merged
 @param t7
 an Observable to be merged
 @param t8
 an Observable to be merged
 @param t9
 an Observable to be merged
 @return an Observable that emits all of the items emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservable:(RxObservable *)t1
                       withRxObservable:(RxObservable *)t2
                       withRxObservable:(RxObservable *)t3
                       withRxObservable:(RxObservable *)t4
                       withRxObservable:(RxObservable *)t5
                       withRxObservable:(RxObservable *)t6
                       withRxObservable:(RxObservable *)t7
                       withRxObservable:(RxObservable *)t8
                       withRxObservable:(RxObservable *)t9;

/*!
 @brief Flattens an Array of Observables into one Observable, without any transformation.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.io.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sequences
 the Array of Observables
 @return an Observable that emits all of the items emitted by the Observables in the Array
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeWithRxObservableArray:(IOSObjectArray *)sequences;

/*!
 @brief Flattens an Array of Observables into one Observable, without any transformation, while limiting the
 number of concurrent subscriptions to these Observables.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.io.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>merge</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sequences
 the Array of Observables
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits all of the items emitted by the Observables in the Array
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 @since 1.1.0
 */
+ (RxObservable *)mergeWithRxObservableArray:(IOSObjectArray *)sequences
                                     withInt:(jint)maxConcurrent;

/*!
 @brief Flattens an Iterable of Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from each of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <code>merge(Observable)</code> except that if any of the merged Observables notify of an
 error via <code>onError</code>, <code>mergeDelayError</code> will refrain from propagating that
 error notification until all of the merged Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sequences
 the Iterable of Observables
 @return an Observable that emits items that are the result of flattening the items emitted by the
 Observables in the Iterable
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithJavaLangIterable:(id<JavaLangIterable>)sequences;

/*!
 @brief Flattens an Iterable of Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from each of the source Observables without being interrupted by an error
 notification from one of them, while limiting the number of concurrent subscriptions to these Observables.
 <p>
 This behaves like <code>merge(Observable)</code> except that if any of the merged Observables notify of an
 error via <code>onError</code>, <code>mergeDelayError</code> will refrain from propagating that
 error notification until all of the merged Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sequences
 the Iterable of Observables
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits items that are the result of flattening the items emitted by the
 Observables in the Iterable
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithJavaLangIterable:(id<JavaLangIterable>)sequences
                                              withInt:(jint)maxConcurrent;

/*!
 @brief Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to
 receive all successfully emitted items from all of the source Observables without being interrupted by
 an error notification from one of them.
 <p>
 This behaves like <code>merge(Observable)</code> except that if any of the merged Observables notify of an
 error via <code>onError</code>, <code>mergeDelayError</code> will refrain from propagating that
 error notification until all of the merged Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param source
 an Observable that emits Observables
 @return an Observable that emits all of the items emitted by the Observables emitted by the
 <code>source</code> Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)source;

/*!
 @brief Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to
 receive all successfully emitted items from all of the source Observables without being interrupted by
 an error notification from one of them, while limiting the
 number of concurrent subscriptions to these Observables.
 <p>
 This behaves like <code>merge(Observable)</code> except that if any of the merged Observables notify of an
 error via <code>onError</code>, <code>mergeDelayError</code> will refrain from propagating that
 error notification until all of the merged Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param source
 an Observable that emits Observables
 @param maxConcurrent
 the maximum number of Observables that may be subscribed to concurrently
 @return an Observable that emits all of the items emitted by the Observables emitted by the
 <code>source</code> Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)source
                                          withInt:(jint)maxConcurrent;

/*!
 @brief Flattens two Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from each of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <code>merge(Observable,Observable)</code> except that if any of the merged Observables
 notify of an error via <code>onError</code>, <code>mergeDelayError</code> will refrain from
 propagating that error notification until all of the merged Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if both merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @return an Observable that emits all of the items that are emitted by the two source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)t1
                                 withRxObservable:(RxObservable *)t2;

/*!
 @brief Flattens three Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <code>merge(Observable,Observable,Observable)</code> except that if any of the merged
 Observables notify of an error via <code>onError</code>, <code>mergeDelayError</code> will refrain
 from propagating that error notification until all of the merged Observables have finished emitting
 items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @return an Observable that emits all of the items that are emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)t1
                                 withRxObservable:(RxObservable *)t2
                                 withRxObservable:(RxObservable *)t3;

/*!
 @brief Flattens four Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <code>merge(Observable,Observable,Observable,Observable)</code> except that if any of
 the merged Observables notify of an error via <code>onError</code>, <code>mergeDelayError</code>
 will refrain from propagating that error notification until all of the merged Observables have finished
 emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @return an Observable that emits all of the items that are emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)t1
                                 withRxObservable:(RxObservable *)t2
                                 withRxObservable:(RxObservable *)t3
                                 withRxObservable:(RxObservable *)t4;

/*!
 @brief Flattens five Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <code>merge(Observable,Observable,Observable,Observable,Observable)</code> except that
 if any of the merged Observables notify of an error via <code>onError</code>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @return an Observable that emits all of the items that are emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)t1
                                 withRxObservable:(RxObservable *)t2
                                 withRxObservable:(RxObservable *)t3
                                 withRxObservable:(RxObservable *)t4
                                 withRxObservable:(RxObservable *)t5;

/*!
 @brief Flattens six Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <code>merge(Observable,Observable,Observable,Observable,Observable,Observable)</code>
 except that if any of the merged Observables notify of an error via <code>onError</code>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @param t6
 an Observable to be merged
 @return an Observable that emits all of the items that are emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)t1
                                 withRxObservable:(RxObservable *)t2
                                 withRxObservable:(RxObservable *)t3
                                 withRxObservable:(RxObservable *)t4
                                 withRxObservable:(RxObservable *)t5
                                 withRxObservable:(RxObservable *)t6;

/*!
 @brief Flattens seven Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like
 <code>merge(Observable,Observable,Observable,Observable,Observable,Observable,Observable)</code>
 except that if any of the merged Observables notify of an error via <code>onError</code>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @param t6
 an Observable to be merged
 @param t7
 an Observable to be merged
 @return an Observable that emits all of the items that are emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)t1
                                 withRxObservable:(RxObservable *)t2
                                 withRxObservable:(RxObservable *)t3
                                 withRxObservable:(RxObservable *)t4
                                 withRxObservable:(RxObservable *)t5
                                 withRxObservable:(RxObservable *)t6
                                 withRxObservable:(RxObservable *)t7;

/*!
 @brief Flattens eight Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <code>merge(Observable,Observable,Observable,Observable,Observable,Observable,Observable,Observable)</code>
 except that if any of the merged Observables notify of an error via <code>onError</code>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @param t6
 an Observable to be merged
 @param t7
 an Observable to be merged
 @param t8
 an Observable to be merged
 @return an Observable that emits all of the items that are emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)t1
                                 withRxObservable:(RxObservable *)t2
                                 withRxObservable:(RxObservable *)t3
                                 withRxObservable:(RxObservable *)t4
                                 withRxObservable:(RxObservable *)t5
                                 withRxObservable:(RxObservable *)t6
                                 withRxObservable:(RxObservable *)t7
                                 withRxObservable:(RxObservable *)t8;

/*!
 @brief Flattens nine Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <code>merge(Observable,Observable,Observable,Observable,Observable,Observable,Observable,Observable,Observable)</code>
 except that if any of the merged Observables notify of an error via <code>onError</code>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeDelayError</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @param t2
 an Observable to be merged
 @param t3
 an Observable to be merged
 @param t4
 an Observable to be merged
 @param t5
 an Observable to be merged
 @param t6
 an Observable to be merged
 @param t7
 an Observable to be merged
 @param t8
 an Observable to be merged
 @param t9
 an Observable to be merged
 @return an Observable that emits all of the items that are emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
+ (RxObservable *)mergeDelayErrorWithRxObservable:(RxObservable *)t1
                                 withRxObservable:(RxObservable *)t2
                                 withRxObservable:(RxObservable *)t3
                                 withRxObservable:(RxObservable *)t4
                                 withRxObservable:(RxObservable *)t5
                                 withRxObservable:(RxObservable *)t6
                                 withRxObservable:(RxObservable *)t7
                                 withRxObservable:(RxObservable *)t8
                                 withRxObservable:(RxObservable *)t9;

/*!
 @brief Flattens this and another Observable into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>mergeWith</code> method.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>mergeWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 an Observable to be merged
 @return an Observable that emits all of the items emitted by the source Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
 */
- (RxObservable *)mergeWithWithRxObservable:(RxObservable *)t1;

/*!
 @brief Converts the source <code>Observable<T></code> into an <code>Observable<Observable<T>></code> that emits the
 source Observable as its single emission.
 <p>
 <img width="640" height="350" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/nest.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>nest</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits a single item: the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)nest;

/*!
 @brief Returns an Observable that never sends any items or notifications to an <code>Observer</code>.
 <p>
 <img width="640" height="185" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/never.png" alt="">
 <p>
 This Observable is useful primarily for testing purposes.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>never</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that never emits any items or sends any notifications to an <code>Observer</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/empty-never-throw.html">ReactiveX operators documentation: Never</a>
 */
+ (RxObservable *)never;

/*!
 @brief Modifies an Observable to perform its emissions and notifications on a specified <code>Scheduler</code>,
 asynchronously with a bounded buffer of <code>RxRingBuffer.SIZE</code> slots.
 <p>Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly
 asynchronous. If strict event ordering is required, consider using the <code>observeOn(Scheduler,boolean)</code> overload.
 <p>
 <img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler
 the <code>Scheduler</code> to notify <code>Observer</code>s on
 @return the source Observable modified so that its <code>Observer</code>s are notified on the specified
 <code>Scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/observeon.html">ReactiveX operators documentation: ObserveOn</a>
 - seealso: <a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/">RxJava Threading Examples</a>
 - seealso: #subscribeOn
 - seealso: #observeOn(Scheduler,int)
 - seealso: #observeOn(Scheduler,boolean)
 - seealso: #observeOn(Scheduler,boolean,int)
 */
- (RxObservable *)observeOnWithRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Modifies an Observable to perform its emissions and notifications on a specified <code>Scheduler</code>,
 asynchronously with a bounded buffer and optionally delays onError notifications.
 <p>
 <img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler
 the <code>Scheduler</code> to notify <code>Observer</code>s on
 @param delayError
 indicates if the onError notification may not cut ahead of onNext notification on the other side of the
 scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received
 from upstream
 @return the source Observable modified so that its <code>Observer</code>s are notified on the specified
 <code>Scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/observeon.html">ReactiveX operators documentation: ObserveOn</a>
 - seealso: <a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/">RxJava Threading Examples</a>
 - seealso: #subscribeOn
 - seealso: #observeOn(Scheduler)
 - seealso: #observeOn(Scheduler,int)
 - seealso: #observeOn(Scheduler,boolean,int)
 */
- (RxObservable *)observeOnWithRxScheduler:(RxScheduler *)scheduler
                               withBoolean:(jboolean)delayError;

/*!
 @brief Modifies an Observable to perform its emissions and notifications on a specified <code>Scheduler</code>,
 asynchronously with a bounded buffer of configurable size other than the <code>RxRingBuffer.SIZE</code>
 default, and optionally delays onError notifications.
 <p>
 <img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler
 the <code>Scheduler</code> to notify <code>Observer</code>s on
 @param delayError
 indicates if the onError notification may not cut ahead of onNext notification on the other side of the
 scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received
 from upstream
 @param bufferSize the size of the buffer.
 @return the source Observable modified so that its <code>Observer</code>s are notified on the specified
 <code>Scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/observeon.html">ReactiveX operators documentation: ObserveOn</a>
 - seealso: <a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/">RxJava Threading Examples</a>
 - seealso: #subscribeOn
 - seealso: #observeOn(Scheduler)
 - seealso: #observeOn(Scheduler,int)
 - seealso: #observeOn(Scheduler,boolean)
 */
- (RxObservable *)observeOnWithRxScheduler:(RxScheduler *)scheduler
                               withBoolean:(jboolean)delayError
                                   withInt:(jint)bufferSize;

/*!
 @brief Modifies an Observable to perform its emissions and notifications on a specified <code>Scheduler</code>,
 asynchronously with a bounded buffer of configurable size other than the <code>RxRingBuffer.SIZE</code>
 default.
 <p>Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly
 asynchronous. If strict event ordering is required, consider using the <code>observeOn(Scheduler,boolean)</code> overload.
 <p>
 <img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler the <code>Scheduler</code> to notify <code>Observer</code>s on
 @param bufferSize the size of the buffer.
 @return the source Observable modified so that its <code>Observer</code>s are notified on the specified
 <code>Scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/observeon.html">ReactiveX operators documentation: ObserveOn</a>
 - seealso: <a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/">RxJava Threading Examples</a>
 - seealso: #subscribeOn
 - seealso: #observeOn(Scheduler)
 - seealso: #observeOn(Scheduler,boolean)
 - seealso: #observeOn(Scheduler,boolean,int)
 */
- (RxObservable *)observeOnWithRxScheduler:(RxScheduler *)scheduler
                                   withInt:(jint)bufferSize;

/*!
 @brief Filters the items emitted by an Observable, only emitting those of the specified type.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ofClass.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>ofType</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param klass
 the class type to filter the items emitted by the source Observable
 @return an Observable that emits items from the source Observable of type <code>klass</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/filter.html">ReactiveX operators documentation: Filter</a>
 */
- (RxObservable *)ofTypeWithIOSClass:(IOSClass *)klass;

/*!
 @brief Instructs an Observable that is emitting items faster than its observer can consume them to buffer these
 items indefinitely until they can be emitted.
 <p>
 <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onBackpressureBuffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return the source Observable modified to buffer items to the extent system resources allow
 - seealso: <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
 */
- (RxObservable *)onBackpressureBuffer;

/*!
 @brief Instructs an Observable that is emitting items faster than its observer can consume them to buffer up to
 a given amount of items until they can be emitted.
 The resulting Observable will <code>onError</code> emitting
 a <code>BufferOverflowException</code> as soon as the buffer's capacity is exceeded, dropping all undelivered
 items, and unsubscribing from the source.
 <p>
 <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onBackpressureBuffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param capacity number of slots available in the buffer.
 @return the source <code>Observable</code> modified to buffer items up to the given capacity.
 - seealso: <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
 @since 1.1.0
 */
- (RxObservable *)onBackpressureBufferWithLong:(jlong)capacity;

/*!
 @brief Instructs an Observable that is emitting items faster than its observer can consume them to buffer up to
 a given amount of items until they can be emitted.
 The resulting Observable will <code>onError</code> emitting
 a <code>BufferOverflowException</code> as soon as the buffer's capacity is exceeded, dropping all undelivered
 items, unsubscribing from the source, and notifying the producer with <code>onOverflow</code>.
 <p>
 <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onBackpressureBuffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param capacity number of slots available in the buffer.
 @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.
 @return the source <code>Observable</code> modified to buffer items up to the given capacity
 - seealso: <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
 @since 1.1.0
 */
- (RxObservable *)onBackpressureBufferWithLong:(jlong)capacity
                        withRxFunctionsAction0:(id<RxFunctionsAction0>)onOverflow;

/*!
 @brief Instructs an Observable that is emitting items faster than its observer can consume them to buffer up to
 a given amount of items until they can be emitted.
 The resulting Observable will behave as determined
 by <code>overflowStrategy</code> if the buffer capacity is exceeded.
 <ul>
 <li><code>BackpressureOverflow.Strategy.ON_OVERFLOW_ERROR</code> (default) will <code>onError</code> dropping all undelivered items,
 unsubscribing from the source, and notifying the producer with <code>onOverflow</code>. </li>
 <li><code>BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_LATEST</code> will drop any new items emitted by the producer while
 the buffer is full, without generating any <code>onError</code>.  Each drop will however invoke <code>onOverflow</code>
 to signal the overflow to the producer.</li>j
 <li><code>BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_OLDEST</code> will drop the oldest items in the buffer in order to make
 room for newly emitted ones. Overflow will not generate an<code>onError</code>, but each drop will invoke
 <code>onOverflow</code> to signal the overflow to the producer.</li>
 </ul>
 <p>
 <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onBackpressureBuffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param capacity number of slots available in the buffer.
 @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.
 @param overflowStrategy how should the <code>Observable</code> react to buffer overflows.  Null is not allowed.
 @return the source <code>Observable</code> modified to buffer items up to the given capacity
 - seealso: <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)onBackpressureBufferWithLong:(jlong)capacity
                        withRxFunctionsAction0:(id<RxFunctionsAction0>)onOverflow
           withRxBackpressureOverflow_Strategy:(id<RxBackpressureOverflow_Strategy>)overflowStrategy;

/*!
 @brief Instructs an Observable that is emitting items faster than its observer can consume them to discard,
 rather than emit, those items that its observer is not prepared to observe.
 <p>
 <img width="640" height="245" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.drop.png" alt="">
 <p>
 If the downstream request count hits 0 then the Observable will refrain from calling <code>onNext</code> until
 the observer invokes <code>request(n)</code> again to increase the request count.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onBackpressureDrop</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return the source Observable modified to drop <code>onNext</code> notifications on overflow
 - seealso: <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
 */
- (RxObservable *)onBackpressureDrop;

/*!
 @brief Instructs an Observable that is emitting items faster than its observer can consume them to discard,
 rather than emit, those items that its observer is not prepared to observe.
 <p>
 <img width="640" height="245" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.drop.png" alt="">
 <p>
 If the downstream request count hits 0 then the Observable will refrain from calling <code>onNext</code> until
 the observer invokes <code>request(n)</code> again to increase the request count.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onBackpressureDrop</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onDrop the action to invoke for each item dropped. onDrop action should be fast and should never block.
 @return the source Observable modified to drop <code>onNext</code> notifications on overflow
 - seealso: <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
  The behavior of this can change at any time. 
 @since 1.1.0
 */
- (RxObservable *)onBackpressureDropWithRxFunctionsAction1:(id<RxFunctionsAction1>)onDrop;

/*!
 @brief Instructs an Observable that is emitting items faster than its observer can consume them to 
 hold onto the latest value and emit that on request.
 <p>
 <img width="640" height="245" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.latest.png" alt="">
 <p>
 Its behavior is logically equivalent to <code>toBlocking().latest()</code> with the exception that
 the downstream is not blocking while requesting more values.
 <p>
 Note that if the upstream Observable does support backpressure, this operator ignores that capability
 and doesn't propagate any backpressure requests from downstream.
 <p>
 Note that due to the nature of how backpressure requests are propagated through subscribeOn/observeOn,
 requesting more than 1 from downstream doesn't guarantee a continuous delivery of onNext events.
 @return the source Observable modified so that it emits the most recently-received item upon request
 @since 1.1.0
 */
- (RxObservable *)onBackpressureLatest;

/*!
 @brief Instructs an Observable to pass control to another Observable rather than invoking
 <code>onError</code> if it encounters an error.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png" alt="">
 <p>
 By default, when an Observable encounters an error that prevents it from emitting the expected item to
 its <code>Observer</code>, the Observable invokes its Observer's <code>onError</code> method, and then quits
 without invoking any more of its Observer's methods. The <code>onErrorResumeNext</code> method changes this
 behavior. If you pass a function that returns an Observable (<code>resumeFunction</code>) to
 <code>onErrorResumeNext</code>, if the original Observable encounters an error, instead of invoking its
 Observer's <code>onError</code> method, it will instead relinquish control to the Observable returned from
 <code>resumeFunction</code>, which will invoke the Observer's <code>onNext</code> method if it is
 able to do so. In such a case, because no Observable necessarily invokes <code>onError</code>, the Observer
 may never know that an error happened.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be
 encountered.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onErrorResumeNext</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param resumeFunction
 a function that returns an Observable that will take over if the source Observable encounters
 an error
 @return the original Observable, with appropriately modified behavior
 - seealso: <a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX operators documentation: Catch</a>
 */
- (RxObservable *)onErrorResumeNextWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)resumeFunction;

/*!
 @brief Instructs an Observable to pass control to another Observable rather than invoking
 <code>onError</code> if it encounters an error.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png" alt="">
 <p>
 By default, when an Observable encounters an error that prevents it from emitting the expected item to
 its <code>Observer</code>, the Observable invokes its Observer's <code>onError</code> method, and then quits
 without invoking any more of its Observer's methods. The <code>onErrorResumeNext</code> method changes this
 behavior. If you pass another Observable (<code>resumeSequence</code>) to an Observable's
 <code>onErrorResumeNext</code> method, if the original Observable encounters an error, instead of invoking its
 Observer's <code>onError</code> method, it will instead relinquish control to <code>resumeSequence</code> which
 will invoke the Observer's <code>onNext</code> method if it is able to do so. In such a case,
 because no Observable necessarily invokes <code>onError</code>, the Observer may never know that an error
 happened.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be
 encountered.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onErrorResumeNext</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param resumeSequence
 a function that returns an Observable that will take over if the source Observable encounters
 an error
 @return the original Observable, with appropriately modified behavior
 - seealso: <a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX operators documentation: Catch</a>
 */
- (RxObservable *)onErrorResumeNextWithRxObservable:(RxObservable *)resumeSequence;

/*!
 @brief Instructs an Observable to emit an item (returned by a specified function) rather than invoking
 <code>onError</code> if it encounters an error.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png" alt="">
 <p>
 By default, when an Observable encounters an error that prevents it from emitting the expected item to
 its <code>Observer</code>, the Observable invokes its Observer's <code>onError</code> method, and then quits
 without invoking any more of its Observer's methods. The <code>onErrorReturn</code> method changes this
 behavior. If you pass a function (<code>resumeFunction</code>) to an Observable's <code>onErrorReturn</code>
 method, if the original Observable encounters an error, instead of invoking its Observer's
 <code>onError</code> method, it will instead emit the return value of <code>resumeFunction</code>.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be
 encountered.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onErrorReturn</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param resumeFunction
 a function that returns an item that the new Observable will emit if the source Observable
 encounters an error
 @return the original Observable with appropriately modified behavior
 - seealso: <a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX operators documentation: Catch</a>
 */
- (RxObservable *)onErrorReturnWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)resumeFunction;

/*!
 @brief Instructs an Observable to pass control to another Observable rather than invoking
 <code>onError</code> if it encounters an <code>java.lang.Exception</code>.
 <p>
 This differs from <code>onErrorResumeNext</code> in that this one does not handle <code>java.lang.Throwable</code>
 or <code>java.lang.Error</code> but lets those continue through.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onExceptionResumeNextViaObservable.png" alt="">
 <p>
 By default, when an Observable encounters an exception that prevents it from emitting the expected item
 to its <code>Observer</code>, the Observable invokes its Observer's <code>onError</code> method, and then quits
 without invoking any more of its Observer's methods. The <code>onExceptionResumeNext</code> method changes
 this behavior. If you pass another Observable (<code>resumeSequence</code>) to an Observable's
 <code>onExceptionResumeNext</code> method, if the original Observable encounters an exception, instead of
 invoking its Observer's <code>onError</code> method, it will instead relinquish control to
 <code>resumeSequence</code> which will invoke the Observer's <code>onNext</code> method if it is
 able to do so. In such a case, because no Observable necessarily invokes <code>onError</code>, the Observer
 may never know that an exception happened.
 <p>
 You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be
 encountered.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onExceptionResumeNext</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param resumeSequence
 a function that returns an Observable that will take over if the source Observable encounters
 an exception
 @return the original Observable, with appropriately modified behavior
 - seealso: <a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX operators documentation: Catch</a>
 */
- (RxObservable *)onExceptionResumeNextWithRxObservable:(RxObservable *)resumeSequence;

/*!
 @brief Nulls out references to the upstream producer and downstream Subscriber if
 the sequence is terminated or downstream unsubscribes.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>onTerminateDetach</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable which out references to the upstream producer and downstream Subscriber if
 the sequence is terminated or downstream unsubscribes
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)onTerminateDetach;

/*!
 @brief Returns a <code>ConnectableObservable</code>, which is a variety of Observable that waits until its
 <code>connect</code> method is called before it begins emitting items to those
 <code>Observer</code>s that have subscribed to it.
 <p>
 <img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>publish</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return a <code>ConnectableObservable</code> that upon connection causes the source Observable to emit items
 to its <code>Observer</code>s
 - seealso: <a href="http://reactivex.io/documentation/operators/publish.html">ReactiveX operators documentation: Publish</a>
 */
- (RxObservablesConnectableObservable *)publish;

/*!
 @brief Returns an Observable that emits the results of invoking a specified selector on items emitted by a
 <code>ConnectableObservable</code> that shares a single subscription to the underlying sequence.
 <p>
 <img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.f.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>publish</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param selector
 a function that can use the multicasted source sequence as many times as needed, without
 causing multiple subscriptions to the source sequence. Subscribers to the given source will
 receive all notifications of the source from the time of the subscription forward.
 @return an Observable that emits the results of invoking the selector on the items emitted by a <code>ConnectableObservable</code> that shares a single subscription to the underlying sequence
 - seealso: <a href="http://reactivex.io/documentation/operators/publish.html">ReactiveX operators documentation: Publish</a>
 */
- (RxObservable *)publishWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector;

/*!
 @brief Returns an Observable that emits a sequence of Integers within a specified range.
 <p>
 <img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/range.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>range</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param start
 the value of the first Integer in the sequence
 @param count
 the number of sequential Integers to generate
 @return an Observable that emits a range of sequential Integers
 @throws IllegalArgumentException
 if <code>count</code> is less than zero, or if <code>start</code> + <code>count</code> &minus; 1 exceeds
 <code>Integer.MAX_VALUE</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/range.html">ReactiveX operators documentation: Range</a>
 */
+ (RxObservable *)rangeWithInt:(jint)start
                       withInt:(jint)count;

/*!
 @brief Returns an Observable that emits a sequence of Integers within a specified range, on a specified
 Scheduler.
 <p>
 <img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/range.s.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param start
 the value of the first Integer in the sequence
 @param count
 the number of sequential Integers to generate
 @param scheduler
 the Scheduler to run the generator loop on
 @return an Observable that emits a range of sequential Integers
 - seealso: <a href="http://reactivex.io/documentation/operators/range.html">ReactiveX operators documentation: Range</a>
 */
+ (RxObservable *)rangeWithInt:(jint)start
                       withInt:(jint)count
               withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Requests <code>n</code> initially from the upstream and then 75% of <code>n</code> subsequently
 after 75% of <code>n</code> values have been emitted to the downstream.
 <p>This operator allows preventing the downstream to trigger unbounded mode via <code>request(Long.MAX_VALUE)</code>
 or compensate for the per-item overhead of small and frequent requests.
 <dl>
 <dt><b>Backpressure:</b></dt>
 <dd>The operator expects backpressure from upstream and honors backpressure from downstream.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>rebatchRequests</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param n the initial request amount, further request will happen after 75% of this value
 @return the Observable that rebatches request amounts from downstream
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)rebatchRequestsWithInt:(jint)n;

/*!
 @brief Returns an Observable that applies a specified accumulator function to the first item emitted by a source
 Observable, then feeds the result of that function along with the second item emitted by the source
 Observable into the same function, and so on until all items have been emitted by the source Observable,
 and emits the final result from the final call to your function as its sole item.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduce.png" alt="">
 <p>
 This technique, which is called "reduce" here, is sometimes called "aggregate," "fold," "accumulate,"
 "compress," or "inject" in other programming contexts. Groovy, for instance, has an <code>inject</code> method
 that does a similar operation on lists.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure because by intent it will receive all values and reduce
 them to a single <code>onNext</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>reduce</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param accumulator
 an accumulator function to be invoked on each item emitted by the source Observable, whose
 result will be used in the next accumulator call
 @return an Observable that emits a single item that is the result of accumulating the items emitted by
 the source Observable
 @throws IllegalArgumentException
 if the source Observable emits no items
 - seealso: <a href="http://reactivex.io/documentation/operators/reduce.html">ReactiveX operators documentation: Reduce</a>
 - seealso: <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a>
 */
- (RxObservable *)reduceWithRxFunctionsFunc2:(id<RxFunctionsFunc2>)accumulator;

/*!
 @brief Returns an Observable that applies a specified accumulator function to the first item emitted by a source
 Observable and a specified seed value, then feeds the result of that function along with the second item
 emitted by an Observable into the same function, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your function as its sole item.
 <p>
 <img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.png" alt="">
 <p>
 This technique, which is called "reduce" here, is sometimes called "aggregate," "fold," "accumulate,"
 "compress," or "inject" in other programming contexts. Groovy, for instance, has an <code>inject</code> method
 that does a similar operation on lists.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure because by intent it will receive all values and reduce
 them to a single <code>onNext</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>reduce</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param initialValue
 the initial (seed) accumulator value
 @param accumulator
 an accumulator function to be invoked on each item emitted by the source Observable, the
 result of which will be used in the next accumulator call
 @return an Observable that emits a single item that is the result of accumulating the output from the
 items emitted by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/reduce.html">ReactiveX operators documentation: Reduce</a>
 - seealso: <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a>
 */
- (RxObservable *)reduceWithId:(id)initialValue
          withRxFunctionsFunc2:(id<RxFunctionsFunc2>)accumulator;

/*!
 @brief Returns an Observable that repeats the sequence of items emitted by the source Observable indefinitely.
 <p>
 <img width="640" height="309" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.o.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>repeat</code> operates by default on the <code>trampoline</code> <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits the items emitted by the source Observable repeatedly and in sequence
 - seealso: <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>
 */
- (RxObservable *)repeat;

/*!
 @brief Returns an Observable that repeats the sequence of items emitted by the source Observable at most
 <code>count</code> times.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.on.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>repeat</code> operates by default on the <code>trampoline</code> <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the number of times the source Observable items are repeated, a count of 0 will yield an empty
 sequence
 @return an Observable that repeats the sequence of items emitted by the source Observable at most
 <code>count</code> times
 @throws IllegalArgumentException
 if <code>count</code> is less than zero
 - seealso: <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>
 */
- (RxObservable *)repeatWithLong:(jlong)count;

/*!
 @brief Returns an Observable that repeats the sequence of items emitted by the source Observable at most
 <code>count</code> times, on a particular Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.ons.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param count
 the number of times the source Observable items are repeated, a count of 0 will yield an empty
 sequence
 @param scheduler
 the <code>Scheduler</code> to emit the items on
 @return an Observable that repeats the sequence of items emitted by the source Observable at most
 <code>count</code> times on a particular Scheduler
 - seealso: <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>
 */
- (RxObservable *)repeatWithLong:(jlong)count
                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that repeats the sequence of items emitted by the source Observable indefinitely,
 on a particular Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.os.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler
 the Scheduler to emit the items on
 @return an Observable that emits the items emitted by the source Observable repeatedly and in sequence
 - seealso: <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>
 */
- (RxObservable *)repeatWithRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits the same values as the source Observable with the exception of an
 <code>onCompleted</code>.
 An <code>onCompleted</code> notification from the source will result in the emission of
 a <code>void</code> item to the Observable provided as an argument to the <code>notificationHandler</code>
 function. If that Observable calls <code>onComplete</code> or <code>onError</code> then <code>repeatWhen</code> will
 call <code>onCompleted</code> or <code>onError</code> on the child subscription. Otherwise, this Observable will
 resubscribe to the source observable.
 <p>
 <img width="640" height="430" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatWhen.f.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>repeatWhen</code> operates by default on the <code>trampoline</code> <code>Scheduler</code>.</dd>
 </dl>
 @param notificationHandler
 receives an Observable of notifications with which a user can complete or error, aborting the repeat.
 @return the source Observable modified with repeat logic
 - seealso: <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>
 */
- (RxObservable *)repeatWhenWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)notificationHandler;

/*!
 @brief Returns an Observable that emits the same values as the source Observable with the exception of an
 <code>onCompleted</code>.
 An <code>onCompleted</code> notification from the source will result in the emission of
 a <code>void</code> item to the Observable provided as an argument to the <code>notificationHandler</code>
 function. If that Observable calls <code>onComplete</code> or <code>onError</code> then <code>repeatWhen</code> will
 call <code>onCompleted</code> or <code>onError</code> on the child subscription. Otherwise, this Observable will
 resubscribe to the source Observable, on a particular Scheduler.
 <p>
 <img width="640" height="430" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatWhen.f.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param notificationHandler
 receives an Observable of notifications with which a user can complete or error, aborting the repeat.
 @param scheduler
 the <code>Scheduler</code> to emit the items on
 @return the source Observable modified with repeat logic
 - seealso: <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>
 */
- (RxObservable *)repeatWhenWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)notificationHandler
                                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns a <code>ConnectableObservable</code> that shares a single subscription to the underlying Observable
 that will replay all of its items and notifications to any future <code>Observer</code>.
 A Connectable
 Observable resembles an ordinary Observable, except that it does not begin emitting items when it is
 subscribed to, but only when its <code>connect</code> method is called.
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>replay</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return a <code>ConnectableObservable</code> that upon connection causes the source Observable to emit its
 items to its <code>Observer</code>s
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservablesConnectableObservable *)replay;

/*!
 @brief Returns an Observable that emits items that are the results of invoking a specified selector on the items
 emitted by a <code>ConnectableObservable</code> that shares a single subscription to the source Observable.
 <p>
 <img width="640" height="450" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.f.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>replay</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param selector
 the selector function, which can use the multicasted sequence as many times as needed, without
 causing multiple subscriptions to the Observable
 @return an Observable that emits items that are the results of invoking the selector on a
 <code>ConnectableObservable</code> that shares a single subscription to the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)replayWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector;

/*!
 @brief Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying <code>bufferSize</code> notifications.
 <p>
 <img width="640" height="440" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fn.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>replay</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param selector
 the selector function, which can use the multicasted sequence as many times as needed, without
 causing multiple subscriptions to the Observable
 @param bufferSize
 the buffer size that limits the number of items the connectable observable can replay
 @return an Observable that emits items that are the results of invoking the selector on items emitted by
 a <code>ConnectableObservable</code> that shares a single subscription to the source Observable
 replaying no more than <code>bufferSize</code> items
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)replayWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector
                                     withInt:(jint)bufferSize;

/*!
 @brief Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying no more than <code>bufferSize</code> items that were emitted within a specified time window.
 <p>
 <img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fnt.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>replay</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param selector
 a selector function, which can use the multicasted sequence as many times as needed, without
 causing multiple subscriptions to the Observable
 @param bufferSize
 the buffer size that limits the number of items the connectable observable can replay
 @param time
 the duration of the window in which the replayed items must have been emitted
 @param unit
 the time unit of <code>time</code>
 @return an Observable that emits items that are the results of invoking the selector on items emitted by
 a <code>ConnectableObservable</code> that shares a single subscription to the source Observable, and
 replays no more than <code>bufferSize</code> items that were emitted within the window defined by
 <code>time</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)replayWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector
                                     withInt:(jint)bufferSize
                                    withLong:(jlong)time
              withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying no more than <code>bufferSize</code> items that were emitted within a specified time window.
 <p>
 <img width="640" height="445" height="440" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fnts.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param selector
 a selector function, which can use the multicasted sequence as many times as needed, without
 causing multiple subscriptions to the Observable
 @param bufferSize
 the buffer size that limits the number of items the connectable observable can replay
 @param time
 the duration of the window in which the replayed items must have been emitted
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the Scheduler that is the time source for the window
 @return an Observable that emits items that are the results of invoking the selector on items emitted by
 a <code>ConnectableObservable</code> that shares a single subscription to the source Observable, and
 replays no more than <code>bufferSize</code> items that were emitted within the window defined by
 <code>time</code>
 @throws IllegalArgumentException
 if <code>bufferSize</code> is less than zero
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)replayWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector
                                     withInt:(jint)bufferSize
                                    withLong:(jlong)time
              withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                             withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying a maximum of <code>bufferSize</code> items.
 <p>
 <img width="640" height="440" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fns.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param selector
 a selector function, which can use the multicasted sequence as many times as needed, without
 causing multiple subscriptions to the Observable
 @param bufferSize
 the buffer size that limits the number of items the connectable observable can replay
 @param scheduler
 the Scheduler on which the replay is observed
 @return an Observable that emits items that are the results of invoking the selector on items emitted by
 a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying no more than <code>bufferSize</code> notifications
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)replayWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector
                                     withInt:(jint)bufferSize
                             withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying all items that were emitted within a specified time window.
 <p>
 <img width="640" height="435" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ft.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>replay</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param selector
 a selector function, which can use the multicasted sequence as many times as needed, without
 causing multiple subscriptions to the Observable
 @param time
 the duration of the window in which the replayed items must have been emitted
 @param unit
 the time unit of <code>time</code>
 @return an Observable that emits items that are the results of invoking the selector on items emitted by
 a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying all items that were emitted within the window defined by <code>time</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)replayWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector
                                    withLong:(jlong)time
              withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying all items that were emitted within a specified time window.
 <p>
 <img width="640" height="440" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fts.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param selector
 a selector function, which can use the multicasted sequence as many times as needed, without
 causing multiple subscriptions to the Observable
 @param time
 the duration of the window in which the replayed items must have been emitted
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the scheduler that is the time source for the window
 @return an Observable that emits items that are the results of invoking the selector on items emitted by
 a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying all items that were emitted within the window defined by <code>time</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)replayWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector
                                    withLong:(jlong)time
              withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                             withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <code>ConnectableObservable</code> that shares a single subscription to the source Observable.
 <p>
 <img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fs.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param selector
 a selector function, which can use the multicasted sequence as many times as needed, without
 causing multiple subscriptions to the Observable
 @param scheduler
 the Scheduler where the replay is observed
 @return an Observable that emits items that are the results of invoking the selector on items emitted by
 a <code>ConnectableObservable</code> that shares a single subscription to the source Observable,
 replaying all items
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservable *)replayWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector
                             withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns a <code>ConnectableObservable</code> that shares a single subscription to the source Observable that
 replays at most <code>bufferSize</code> items emitted by that Observable.
 A Connectable Observable resembles
 an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only
 when its <code>connect</code> method is called.
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.n.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>replay</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param bufferSize
 the buffer size that limits the number of items that can be replayed
 @return a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items emitted by that Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservablesConnectableObservable *)replayWithInt:(jint)bufferSize;

/*!
 @brief Returns a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items that were emitted during a specified time window.
 A Connectable
 Observable resembles an ordinary Observable, except that it does not begin emitting items when it is
 subscribed to, but only when its <code>connect</code> method is called. 
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.nt.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>replay</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param bufferSize
 the buffer size that limits the number of items that can be replayed
 @param time
 the duration of the window in which the replayed items must have been emitted
 @param unit
 the time unit of <code>time</code>
 @return a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items that were emitted during the window defined by
 <code>time</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservablesConnectableObservable *)replayWithInt:(jint)bufferSize
                                             withLong:(jlong)time
                       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 that replays a maximum of <code>bufferSize</code> items that are emitted within a specified time window.
 A
 Connectable Observable resembles an ordinary Observable, except that it does not begin emitting items
 when it is subscribed to, but only when its <code>connect</code> method is called.
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.nts.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param bufferSize
 the buffer size that limits the number of items that can be replayed
 @param time
 the duration of the window in which the replayed items must have been emitted
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the scheduler that is used as a time source for the window
 @return a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items that were emitted during the window defined by
 <code>time</code>
 @throws IllegalArgumentException
 if <code>bufferSize</code> is less than zero
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservablesConnectableObservable *)replayWithInt:(jint)bufferSize
                                             withLong:(jlong)time
                       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                      withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items emitted by that Observable.
 A Connectable Observable resembles
 an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only
 when its <code>connect</code> method is called. 
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ns.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param bufferSize
 the buffer size that limits the number of items that can be replayed
 @param scheduler
 the scheduler on which the Observers will observe the emitted items
 @return a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items that were emitted by the Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservablesConnectableObservable *)replayWithInt:(jint)bufferSize
                                      withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays all items emitted by that Observable within a specified time window.
 A Connectable Observable
 resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to,
 but only when its <code>connect</code> method is called. 
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.t.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>replay</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param time
 the duration of the window in which the replayed items must have been emitted
 @param unit
 the time unit of <code>time</code>
 @return a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays the items that were emitted during the window defined by <code>time</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservablesConnectableObservable *)replayWithLong:(jlong)time
                        withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays all items emitted by that Observable within a specified time window.
 A Connectable Observable
 resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to,
 but only when its <code>connect</code> method is called. 
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ts.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param time
 the duration of the window in which the replayed items must have been emitted
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the Scheduler that is the time source for the window
 @return a <code>ConnectableObservable</code> that shares a single subscription to the source Observable and
 replays the items that were emitted during the window defined by <code>time</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservablesConnectableObservable *)replayWithLong:(jlong)time
                        withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                       withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns a <code>ConnectableObservable</code> that shares a single subscription to the source Observable that
 will replay all of its items and notifications to any future <code>Observer</code> on the given
 <code>Scheduler</code>.
 A Connectable Observable resembles an ordinary Observable, except that it does not
 begin emitting items when it is subscribed to, but only when its <code>connect</code> method is called.
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator supports backpressure. Note that the upstream requests are determined by the child
 Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
 request 100 elements from the underlying Observable sequence.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler
 the Scheduler on which the Observers will observe the emitted items
 @return a <code>ConnectableObservable</code> that shares a single subscription to the source Observable that
 will replay all of its items and notifications to any future <code>Observer</code> on the given
 <code>Scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
 */
- (RxObservablesConnectableObservable *)replayWithRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that mirrors the source Observable, resubscribing to it if it calls <code>onError</code>
 (infinite retry count).
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png" alt="">
 <p>
 If the source Observable calls <code>Observer.onError</code>, this method will resubscribe to the source
 Observable rather than propagating the <code>onError</code> call.
 <p>
 Any and all items emitted by the source Observable will be emitted by the resulting Observable, even
 those emitted during failed subscriptions. For example, if an Observable fails at first but emits
 <code>[1, 2]</code> then succeeds the second time and emits <code>[1, 2, 3, 4, 5]</code> then the complete sequence
 of emissions and notifications would be <code>[1, 2, 1, 2, 3, 4, 5, onCompleted]</code>.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>retry</code> operates by default on the <code>trampoline</code> <code>Scheduler</code>.</dd>
 </dl>
 @return the source Observable modified with retry logic
 - seealso: <a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX operators documentation: Retry</a>
 */
- (RxObservable *)retry;

/*!
 @brief Returns an Observable that mirrors the source Observable, resubscribing to it if it calls <code>onError</code>
 and the predicate returns true for that specific exception and retry count.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator honors backpressure.</td>
 <dt><b>Scheduler:</b></dt>
 <dd><code>retry</code> operates by default on the <code>trampoline</code> <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 the predicate that determines if a resubscription may happen in case of a specific exception
 and retry count
 @return the source Observable modified with retry logic
 - seealso: #retry()
 - seealso: <a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX operators documentation: Retry</a>
 */
- (RxObservable *)retryWithRxFunctionsFunc2:(id<RxFunctionsFunc2>)predicate;

/*!
 @brief Returns an Observable that mirrors the source Observable, resubscribing to it if it calls <code>onError</code>
 up to a specified number of retries.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png" alt="">
 <p>
 If the source Observable calls <code>Observer.onError</code>, this method will resubscribe to the source
 Observable for a maximum of <code>count</code> resubscriptions rather than propagating the
 <code>onError</code> call.
 <p>
 Any and all items emitted by the source Observable will be emitted by the resulting Observable, even
 those emitted during failed subscriptions. For example, if an Observable fails at first but emits
 <code>[1, 2]</code> then succeeds the second time and emits <code>[1, 2, 3, 4, 5]</code> then the complete sequence
 of emissions and notifications would be <code>[1, 2, 1, 2, 3, 4, 5, onCompleted]</code>.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>retry</code> operates by default on the <code>trampoline</code> <code>Scheduler</code>.</dd>
 </dl>
 @param count
 number of retry attempts before failing
 @return the source Observable modified with retry logic
 - seealso: <a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX operators documentation: Retry</a>
 */
- (RxObservable *)retryWithLong:(jlong)count;

/*!
 @brief Returns an Observable that emits the same values as the source observable with the exception of an
 <code>onError</code>.
 An <code>onError</code> notification from the source will result in the emission of a
 <code>Throwable</code> item to the Observable provided as an argument to the <code>notificationHandler</code>
 function. If that Observable calls <code>onComplete</code> or <code>onError</code> then <code>retry</code> will call
 <code>onCompleted</code> or <code>onError</code> on the child subscription. Otherwise, this Observable will
 resubscribe to the source Observable.    
 <p>
 <img width="640" height="430" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryWhen.f.png" alt="">
 Example:
 This retries 3 times, each time incrementing the number of seconds it waits.
 @code
 
  Observable.create((Subscriber<? super String> s) -> 
      System.out.println("subscribing");
      s.onError(new RuntimeException("always fails"));
  }).retryWhen(attempts -> {
      return attempts.zipWith(Observable.range(1, 3), (n, i) -> i).flatMap(i -> {
          System.out.println("delay retry by " + i + " second(s)");
          return Observable.timer(i, TimeUnit.SECONDS);
      });
  }).toBlocking().forEach(System.out::println);
  
@endcode
 Output is:
 @code
  subscribing
  delay retry by 1 second(s)
  subscribing
  delay retry by 2 second(s)
  subscribing
  delay retry by 3 second(s)
  subscribing
 
@endcode
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>retryWhen</code> operates by default on the <code>trampoline</code> <code>Scheduler</code>.</dd>
 </dl>
 @param notificationHandler
 receives an Observable of notifications with which a user can complete or error, aborting the
 retry
 @return the source Observable modified with retry logic
 - seealso: <a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX operators documentation: Retry</a>
 */
- (RxObservable *)retryWhenWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)notificationHandler;

/*!
 @brief Returns an Observable that emits the same values as the source observable with the exception of an
 <code>onError</code>.
 An <code>onError</code> will cause the emission of the <code>Throwable</code> that cause the
 error to the Observable returned from <code>notificationHandler</code>. If that Observable calls
 <code>onComplete</code> or <code>onError</code> then <code>retry</code> will call <code>onCompleted</code> or <code>onError</code>
 on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a
 particular Scheduler.    
 <p>
 <img width="640" height="430" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryWhen.f.png" alt="">
 <p>
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param notificationHandler
 receives an Observable of notifications with which a user can complete or error, aborting the
 retry
 @param scheduler
 the <code>Scheduler</code> on which to subscribe to the source Observable
 @return the source Observable modified with retry logic
 - seealso: <a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX operators documentation: Retry</a>
 */
- (RxObservable *)retryWhenWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)notificationHandler
                                withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits the most recently emitted item (if any) emitted by the source Observable
 within periodic time intervals.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>sample</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param period
 the sampling rate
 @param unit
 the <code>TimeUnit</code> in which <code>period</code> is defined
 @return an Observable that emits the results of sampling the items emitted by the source Observable at
 the specified time interval
 - seealso: <a href="http://reactivex.io/documentation/operators/sample.html">ReactiveX operators documentation: Sample</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 - seealso: #throttleLast(long,TimeUnit)
 */
- (RxObservable *)sampleWithLong:(jlong)period
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits the most recently emitted item (if any) emitted by the source Observable
 within periodic time intervals, where the intervals are defined on a particular Scheduler.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param period
 the sampling rate
 @param unit
 the <code>TimeUnit</code> in which <code>period</code> is defined
 @param scheduler
 the <code>Scheduler</code> to use when sampling
 @return an Observable that emits the results of sampling the items emitted by the source Observable at
 the specified time interval
 - seealso: <a href="http://reactivex.io/documentation/operators/sample.html">ReactiveX operators documentation: Sample</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 - seealso: #throttleLast(long,TimeUnit,Scheduler)
 */
- (RxObservable *)sampleWithLong:(jlong)period
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that, when the specified <code>sampler</code> Observable emits an item or completes,
 emits the most recently emitted item (if any) emitted by the source Observable since the previous
 emission from the <code>sampler</code> Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses the emissions of the <code>sampler</code>
 Observable to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>sample</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sampler
 the Observable to use for sampling the source Observable
 @return an Observable that emits the results of sampling the items emitted by this Observable whenever
 the <code>sampler</code> Observable emits an item or completes
 - seealso: <a href="http://reactivex.io/documentation/operators/sample.html">ReactiveX operators documentation: Sample</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 */
- (RxObservable *)sampleWithRxObservable:(RxObservable *)sampler;

/*!
 @brief Returns an Observable that applies a specified accumulator function to the first item emitted by a source
 Observable, then feeds the result of that function along with the second item emitted by the source
 Observable into the same function, and so on until all items have been emitted by the source Observable,
 emitting the result of each of these iterations.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scan.png" alt="">
 <p>
 This sort of function is sometimes called an accumulator.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>scan</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param accumulator
 an accumulator function to be invoked on each item emitted by the source Observable, whose
 result will be emitted to <code>Observer</code>s via <code>onNext</code> and used in the
 next accumulator call
 @return an Observable that emits the results of each call to the accumulator function
 - seealso: <a href="http://reactivex.io/documentation/operators/scan.html">ReactiveX operators documentation: Scan</a>
 */
- (RxObservable *)scanWithRxFunctionsFunc2:(id<RxFunctionsFunc2>)accumulator;

/*!
 @brief Returns an Observable that applies a specified accumulator function to the first item emitted by a source
 Observable and a seed value, then feeds the result of that function along with the second item emitted by
 the source Observable into the same function, and so on until all items have been emitted by the source
 Observable, emitting the result of each of these iterations.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scanSeed.png" alt="">
 <p>
 This sort of function is sometimes called an accumulator.
 <p>
 Note that the Observable that results from this method will emit <code>initialValue</code> as its first
 emitted item.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>scan</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param initialValue
 the initial (seed) accumulator item
 @param accumulator
 an accumulator function to be invoked on each item emitted by the source Observable, whose
 result will be emitted to <code>Observer</code>s via <code>onNext</code> and used in the
 next accumulator call
 @return an Observable that emits <code>initialValue</code> followed by the results of each call to the
 accumulator function
 - seealso: <a href="http://reactivex.io/documentation/operators/scan.html">ReactiveX operators documentation: Scan</a>
 */
- (RxObservable *)scanWithId:(id)initialValue
        withRxFunctionsFunc2:(id<RxFunctionsFunc2>)accumulator;

/*!
 @brief Returns an Observable that emits a Boolean value that indicates whether two Observable sequences are the
 same by comparing the items emitted by each Observable pairwise.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>sequenceEqual</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param first
 the first Observable to compare
 @param second
 the second Observable to compare
 @return an Observable that emits a Boolean value that indicates whether the two sequences are the same
 - seealso: <a href="http://reactivex.io/documentation/operators/sequenceequal.html">ReactiveX operators documentation: SequenceEqual</a>
 */
+ (RxObservable *)sequenceEqualWithRxObservable:(RxObservable *)first
                               withRxObservable:(RxObservable *)second;

/*!
 @brief Returns an Observable that emits a Boolean value that indicates whether two Observable sequences are the
 same by comparing the items emitted by each Observable pairwise based on the results of a specified
 equality function.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>sequenceEqual</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param first
 the first Observable to compare
 @param second
 the second Observable to compare
 @param equality
 a function used to compare items emitted by each Observable
 @return an Observable that emits a Boolean value that indicates whether the two Observable two sequences
 are the same according to the specified function
 - seealso: <a href="http://reactivex.io/documentation/operators/sequenceequal.html">ReactiveX operators documentation: SequenceEqual</a>
 */
+ (RxObservable *)sequenceEqualWithRxObservable:(RxObservable *)first
                               withRxObservable:(RxObservable *)second
                           withRxFunctionsFunc2:(id<RxFunctionsFunc2>)equality;

/*!
 @brief Forces an Observable's emissions and notifications to be serialized and for it to obey
 <a href="http://reactivex.io/documentation/contract.html">the Observable contract</a> in other ways.
 <p>
 It is possible for an Observable to invoke its Subscribers' methods asynchronously, perhaps from
 different threads. This could make such an Observable poorly-behaved, in that it might try to invoke
 <code>onCompleted</code> or <code>onError</code> before one of its <code>onNext</code> invocations, or it might call
 <code>onNext</code> from two different threads concurrently. You can force such an Observable to be
 well-behaved and sequential by applying the <code>serialize</code> method to it.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/synchronize.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>serialize</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an <code>Observable</code> that is guaranteed to be well-behaved and to make only serialized calls to
 its observers
 - seealso: <a href="http://reactivex.io/documentation/operators/serialize.html">ReactiveX operators documentation: Serialize</a>
 */
- (RxObservable *)serialize;

/*!
 @brief Returns a new <code>Observable</code> that multicasts (shares) the original <code>Observable</code>.
 As long as
 there is at least one <code>Subscriber</code> this <code>Observable</code> will be subscribed and emitting data. 
 When all subscribers have unsubscribed it will unsubscribe from the source <code>Observable</code>. 
 <p>
 This is an alias for <code>publish()</code>.<code>ConnectableObservable.refCount()</code>.
 <p>
 <img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure because multicasting means the stream is "hot" with
 multiple subscribers. Each child will need to manage backpressure independently using operators such
 as <code>onBackpressureDrop</code> and <code>onBackpressureBuffer</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>share</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an <code>Observable</code> that upon connection causes the source <code>Observable</code> to emit items
 to its <code>Observer</code>s
 - seealso: <a href="http://reactivex.io/documentation/operators/refcount.html">ReactiveX operators documentation: RefCount</a>
 */
- (RxObservable *)share;

/*!
 @brief Returns an Observable that emits the single item emitted by the source Observable, if that Observable
 emits only a single item.
 If the source Observable emits more than one item or no items, notify of an
 <code>IllegalArgumentException</code> or <code>NoSuchElementException</code> respectively.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/single.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>single</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits the single item emitted by the source Observable
 @throws IllegalArgumentException
 if the source emits more than one item
 @throws NoSuchElementException
 if the source emits no items
 - seealso: <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
 */
- (RxObservable *)single;

/*!
 @brief Returns an Observable that emits the single item emitted by the source Observable that matches a
 specified predicate, if that Observable emits one such item.
 If the source Observable emits more than one
 such item or no such items, notify of an <code>IllegalArgumentException</code> or
 <code>NoSuchElementException</code> respectively.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/single.p.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>single</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 a predicate function to evaluate items emitted by the source Observable
 @return an Observable that emits the single item emitted by the source Observable that matches the
 predicate
 @throws IllegalArgumentException
 if the source Observable emits more than one item that matches the predicate
 @throws NoSuchElementException
 if the source Observable emits no item that matches the predicate
 - seealso: <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
 */
- (RxObservable *)singleWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Returns an Observable that emits the single item emitted by the source Observable, if that Observable
 emits only a single item, or a default item if the source Observable emits no items.
 If the source
 Observable emits more than one item, throw an <code>IllegalArgumentException</code>.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrDefault.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>singleOrDefault</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param defaultValue
 a default value to emit if the source Observable emits no item
 @return an Observable that emits the single item emitted by the source Observable, or a default item if
 the source Observable is empty
 @throws IllegalArgumentException
 if the source Observable emits more than one item
 - seealso: <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
 */
- (RxObservable *)singleOrDefaultWithId:(id)defaultValue;

/*!
 @brief Returns an Observable that emits the single item emitted by the source Observable that matches a
 predicate, if that Observable emits only one such item, or a default item if the source Observable emits
 no such items.
 If the source Observable emits more than one such item, throw an
 <code>IllegalArgumentException</code>.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrDefault.p.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>singleOrDefault</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param defaultValue
 a default item to emit if the source Observable emits no matching items
 @param predicate
 a predicate function to evaluate items emitted by the source Observable
 @return an Observable that emits the single item emitted by the source Observable that matches the
 predicate, or the default item if no emitted item matches the predicate
 @throws IllegalArgumentException
 if the source Observable emits more than one item that matches the predicate
 - seealso: <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
 */
- (RxObservable *)singleOrDefaultWithId:(id)defaultValue
                   withRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Returns an Observable that skips the first <code>count</code> items emitted by the source Observable and emits
 the remainder.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>skip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the number of items to skip
 @return an Observable that is identical to the source Observable except that it does not emit the first
 <code>count</code> items that the source Observable emits
 - seealso: <a href="http://reactivex.io/documentation/operators/skip.html">ReactiveX operators documentation: Skip</a>
 */
- (RxObservable *)skipWithInt:(jint)count;

/*!
 @brief Returns an Observable that skips values emitted by the source Observable before a specified time window
 elapses.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.t.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>skip</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param time
 the length of the time window to skip
 @param unit
 the time unit of <code>time</code>
 @return an Observable that skips values emitted by the source Observable before the time window defined
 by <code>time</code> elapses and the emits the remainder
 - seealso: <a href="http://reactivex.io/documentation/operators/skip.html">ReactiveX operators documentation: Skip</a>
 */
- (RxObservable *)skipWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that skips values emitted by the source Observable before a specified time window
 on a specified <code>Scheduler</code> elapses.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.ts.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param time
 the length of the time window to skip
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the <code>Scheduler</code> on which the timed wait happens
 @return an Observable that skips values emitted by the source Observable before the time window defined
 by <code>time</code> and <code>scheduler</code> elapses, and then emits the remainder
 - seealso: <a href="http://reactivex.io/documentation/operators/skip.html">ReactiveX operators documentation: Skip</a>
 */
- (RxObservable *)skipWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
               withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that drops a specified number of items from the end of the sequence emitted by the
 source Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.png" alt="">
 <p>
 This Observer accumulates a queue long enough to store the first <code>count</code> items. As more items are
 received, items are taken from the front of the queue and emitted by the returned Observable. This causes
 such items to be delayed.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>skipLast</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 number of items to drop from the end of the source sequence
 @return an Observable that emits the items emitted by the source Observable except for the dropped ones
 at the end
 @throws IndexOutOfBoundsException
 if <code>count</code> is less than zero
 - seealso: <a href="http://reactivex.io/documentation/operators/skiplast.html">ReactiveX operators documentation: SkipLast</a>
 */
- (RxObservable *)skipLastWithInt:(jint)count;

/*!
 @brief Returns an Observable that drops items emitted by the source Observable during a specified time window
 before the source completes.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.t.png" alt="">
 <p>
 Note: this action will cache the latest items arriving in the specified time window.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>skipLast</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @return an Observable that drops those items emitted by the source Observable in a time window before the
 source completes defined by <code>time</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/skiplast.html">ReactiveX operators documentation: SkipLast</a>
 */
- (RxObservable *)skipLastWithLong:(jlong)time
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that drops items emitted by the source Observable during a specified time window
 (defined on a specified scheduler) before the source completes.
 <p>
 <img width="640" height="340" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.ts.png" alt="">
 <p>
 Note: this action will cache the latest items arriving in the specified time window.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the scheduler used as the time source
 @return an Observable that drops those items emitted by the source Observable in a time window before the
 source completes defined by <code>time</code> and <code>scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/skiplast.html">ReactiveX operators documentation: SkipLast</a>
 */
- (RxObservable *)skipLastWithLong:(jlong)time
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                   withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that skips items emitted by the source Observable until a second Observable emits
 an item.
 <p>
 <img width="640" height="375" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipUntil.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>skipUntil</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param other
 the second Observable that has to emit an item before the source Observable's elements begin
 to be mirrored by the resulting Observable
 @return an Observable that skips items from the source Observable until the second Observable emits an
 item, then emits the remaining items
 - seealso: <a href="http://reactivex.io/documentation/operators/skipuntil.html">ReactiveX operators documentation: SkipUntil</a>
 */
- (RxObservable *)skipUntilWithRxObservable:(RxObservable *)other;

/*!
 @brief Returns an Observable that skips all items emitted by the source Observable as long as a specified
 condition holds true, but emits all further source items as soon as the condition becomes false.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipWhile.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>skipWhile</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 a function to test each item emitted from the source Observable
 @return an Observable that begins emitting items emitted by the source Observable when the specified
 predicate becomes false
 - seealso: <a href="http://reactivex.io/documentation/operators/skipwhile.html">ReactiveX operators documentation: SkipWhile</a>
 */
- (RxObservable *)skipWhileWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Returns an Observable that emits the items in a specified <code>Iterable</code> before it begins to emit items
 emitted by the source Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param values
 an Iterable that contains the items you want the modified Observable to emit first
 @return an Observable that emits the items in the specified <code>Iterable</code> and then emits the items
 emitted by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithJavaLangIterable:(id<JavaLangIterable>)values;

/*!
 @brief Returns an Observable that emits the items in a specified <code>Observable</code> before it begins to emit
 items emitted by the source Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.o.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param values
 an Observable that contains the items you want the modified Observable to emit first
 @return an Observable that emits the items in the specified <code>Observable</code> and then emits the items
 emitted by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithRxObservable:(RxObservable *)values;

/*!
 @brief Returns an Observable that emits a specified item before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 the item to emit
 @return an Observable that emits the specified item before it begins to emit items emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithId:(id)t1;

/*!
 @brief Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 the first item to emit
 @param t2
 the second item to emit
 @return an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithId:(id)t1
                           withId:(id)t2;

/*!
 @brief Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 the first item to emit
 @param t2
 the second item to emit
 @param t3
 the third item to emit
 @return an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithId:(id)t1
                           withId:(id)t2
                           withId:(id)t3;

/*!
 @brief Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 the first item to emit
 @param t2
 the second item to emit
 @param t3
 the third item to emit
 @param t4
 the fourth item to emit
 @return an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithId:(id)t1
                           withId:(id)t2
                           withId:(id)t3
                           withId:(id)t4;

/*!
 @brief Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 the first item to emit
 @param t2
 the second item to emit
 @param t3
 the third item to emit
 @param t4
 the fourth item to emit
 @param t5
 the fifth item to emit
 @return an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithId:(id)t1
                           withId:(id)t2
                           withId:(id)t3
                           withId:(id)t4
                           withId:(id)t5;

/*!
 @brief Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 the first item to emit
 @param t2
 the second item to emit
 @param t3
 the third item to emit
 @param t4
 the fourth item to emit
 @param t5
 the fifth item to emit
 @param t6
 the sixth item to emit
 @return an Observable that emits the specified items before it begins to emit items emitted
 by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithId:(id)t1
                           withId:(id)t2
                           withId:(id)t3
                           withId:(id)t4
                           withId:(id)t5
                           withId:(id)t6;

/*!
 @brief Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 the first item to emit
 @param t2
 the second item to emit
 @param t3
 the third item to emit
 @param t4
 the fourth item to emit
 @param t5
 the fifth item to emit
 @param t6
 the sixth item to emit
 @param t7
 the seventh item to emit
 @return an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithId:(id)t1
                           withId:(id)t2
                           withId:(id)t3
                           withId:(id)t4
                           withId:(id)t5
                           withId:(id)t6
                           withId:(id)t7;

/*!
 @brief Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 the first item to emit
 @param t2
 the second item to emit
 @param t3
 the third item to emit
 @param t4
 the fourth item to emit
 @param t5
 the fifth item to emit
 @param t6
 the sixth item to emit
 @param t7
 the seventh item to emit
 @param t8
 the eighth item to emit
 @return an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithId:(id)t1
                           withId:(id)t2
                           withId:(id)t3
                           withId:(id)t4
                           withId:(id)t5
                           withId:(id)t6
                           withId:(id)t7
                           withId:(id)t8;

/*!
 @brief Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>startWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param t1
 the first item to emit
 @param t2
 the second item to emit
 @param t3
 the third item to emit
 @param t4
 the fourth item to emit
 @param t5
 the fifth item to emit
 @param t6
 the sixth item to emit
 @param t7
 the seventh item to emit
 @param t8
 the eighth item to emit
 @param t9
 the ninth item to emit
 @return an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>
 */
- (RxObservable *)startWithWithId:(id)t1
                           withId:(id)t2
                           withId:(id)t3
                           withId:(id)t4
                           withId:(id)t5
                           withId:(id)t6
                           withId:(id)t7
                           withId:(id)t8
                           withId:(id)t9;

/*!
 @brief Subscribes to an Observable and ignores <code>onNext</code> and <code>onCompleted</code> emissions.
 If an <code>onError</code> emission arrives then 
 <code>OnErrorNotImplementedException</code> is thrown. 
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>subscribe</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return a <code>Subscription</code> reference with which the <code>Observer</code> can stop receiving items before
 the Observable has finished sending them
 @throws OnErrorNotImplementedException
 if the Observable tries to call <code>onError</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
 */
- (id<RxSubscription>)subscribe;

/*!
 @brief Subscribes to an Observable and provides a callback to handle the items it emits.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>subscribe</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNext
 the <code>Action1<T></code> you have designed to accept emissions from the Observable
 @return a <code>Subscription</code> reference with which the <code>Observer</code> can stop receiving items before
 the Observable has finished sending them
 @throws IllegalArgumentException
 if <code>onNext</code> is null
 @throws OnErrorNotImplementedException
 if the Observable calls <code>onError</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
 */
- (id<RxSubscription>)subscribeWithRxFunctionsAction1:(id<RxFunctionsAction1>)onNext;

/*!
 @brief Subscribes to an Observable and provides callbacks to handle the items it emits and any error
 notification it issues.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>subscribe</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNext
 the <code>Action1<T></code> you have designed to accept emissions from the Observable
 @param onError
 the <code>Action1<Throwable></code> you have designed to accept any error notification from the
 Observable
 @return a <code>Subscription</code> reference with which the <code>Observer</code> can stop receiving items before
 the Observable has finished sending them
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
 @throws IllegalArgumentException
 if <code>onNext</code> is null, or
 if <code>onError</code> is null
 */
- (id<RxSubscription>)subscribeWithRxFunctionsAction1:(id<RxFunctionsAction1>)onNext
                               withRxFunctionsAction1:(id<RxFunctionsAction1>)onError;

/*!
 @brief Subscribes to an Observable and provides callbacks to handle the items it emits and any error or
 completion notification it issues.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>subscribe</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param onNext
 the <code>Action1<T></code> you have designed to accept emissions from the Observable
 @param onError
 the <code>Action1<Throwable></code> you have designed to accept any error notification from the
 Observable
 @param onCompleted
 the <code>Action0</code> you have designed to accept a completion notification from the
 Observable
 @return a <code>Subscription</code> reference with which the <code>Observer</code> can stop receiving items before
 the Observable has finished sending them
 @throws IllegalArgumentException
 if <code>onNext</code> is null, or
 if <code>onError</code> is null, or
 if <code>onComplete</code> is null
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
 */
- (id<RxSubscription>)subscribeWithRxFunctionsAction1:(id<RxFunctionsAction1>)onNext
                               withRxFunctionsAction1:(id<RxFunctionsAction1>)onError
                               withRxFunctionsAction0:(id<RxFunctionsAction0>)onCompleted;

/*!
 @brief Subscribes to an Observable and provides an Observer that implements functions to handle the items the
 Observable emits and any error or completion notification it issues.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>subscribe</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param observer
 the Observer that will handle emissions and notifications from the Observable
 @return a <code>Subscription</code> reference with which the <code>Observer</code> can stop receiving items before
 the Observable has completed
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
 */
- (id<RxSubscription>)subscribeWithRxObserver:(id<RxObserver>)observer;

/*!
 @brief Subscribes to an Observable and provides a Subscriber that implements functions to handle the items the
 Observable emits and any error or completion notification it issues.
 <p>
 A typical implementation of <code>subscribe</code> does the following:
 <ol>
 <li>It stores a reference to the Subscriber in a collection object, such as a <code>List<T></code> object.</li>
 <li>It returns a reference to the <code>Subscription</code> interface. This enables Subscribers to
 unsubscribe, that is, to stop receiving items and notifications before the Observable completes, which
 also invokes the Subscriber's <code>onCompleted</code> method.</li>
 </ol><p>
 An <code>Observable<T></code> instance is responsible for accepting all subscriptions and notifying all
 Subscribers. Unless the documentation for a particular <code>Observable<T></code> implementation indicates
 otherwise, Subscriber should make no assumptions about the order in which multiple Subscribers will
 receive their notifications.
 <p>
 For more information see the
 <a href="http://reactivex.io/documentation/observable.html">ReactiveX documentation</a>.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>subscribe</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param subscriber
 the <code>Subscriber</code> that will handle emissions and notifications from the Observable
 @return a <code>Subscription</code> reference with which Subscribers that are <code>Observer</code>s can
 unsubscribe from the Observable
 @throws IllegalStateException
 if <code>subscribe</code> is unable to obtain an <code>OnSubscribe<></code> function
 @throws IllegalArgumentException
 if the <code>Subscriber</code> provided as the argument to <code>subscribe</code> is <code>null</code>
 @throws OnErrorNotImplementedException
 if the <code>Subscriber</code>'s <code>onError</code> method is null
 @throws RuntimeException
 if the <code>Subscriber</code>'s <code>onError</code> method itself threw a <code>Throwable</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
 */
- (id<RxSubscription>)subscribeWithRxSubscriber:(RxSubscriber *)subscriber;

/*!
 @brief Asynchronously subscribes Observers to this Observable on the specified <code>Scheduler</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/subscribeOn.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler
 the <code>Scheduler</code> to perform subscription actions on
 @return the source Observable modified so that its subscriptions happen on the
 specified <code>Scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribeon.html">ReactiveX operators documentation: SubscribeOn</a>
 - seealso: <a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/">RxJava Threading Examples</a>
 - seealso: #observeOn
 */
- (RxObservable *)subscribeOnWithRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits the items emitted by the source Observable or the items of an alternate
 Observable if the source Observable is empty.
 <p/>
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>switchIfEmpty</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param alternate
 the alternate Observable to subscribe to if the source does not emit any items
 @return an Observable that emits the items emitted by the source Observable or the items of an
 alternate Observable if the source Observable is empty.
 @since 1.1.0
 */
- (RxObservable *)switchIfEmptyWithRxObservable:(RxObservable *)alternate;

/*!
 @brief Returns a new Observable by applying a function that you supply to each item emitted by the source
 Observable that returns an Observable, and then emitting the items emitted by the most recently emitted
 of these Observables.
 <p>
 The resulting Observable completes if both the upstream Observable and the last inner Observable, if any, complete.
 If the upstream Observable signals an onError, the inner Observable is unsubscribed and the error delivered in-sequence.
 <p>
 <img width="640" height="350" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>switchMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param func
 a function that, when applied to an item emitted by the source Observable, returns an
 Observable
 @return an Observable that emits the items emitted by the Observable returned from applying <code>func</code> to the most recently emitted item emitted by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
 */
- (RxObservable *)switchMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)func;

/*!
 @brief Returns a new Observable by applying a function that you supply to each item emitted by the source
 Observable that returns an Observable, and then emitting the items emitted by the most recently emitted
 of these Observables and delays any error until all Observables terminate.
 <p>
 The resulting Observable completes if both the upstream Observable and the last inner Observable, if any, complete.
 If the upstream Observable signals an onError, the termination of the last inner Observable will emit that error as is
 or wrapped into a CompositeException along with the other possible errors the former inner Observables signalled.
 <p>
 <img width="640" height="350" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>switchMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param func
 a function that, when applied to an item emitted by the source Observable, returns an
 Observable
 @return an Observable that emits the items emitted by the Observable returned from applying <code>func</code> to the most recently emitted item emitted by the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
  The behavior of this can change at any time.
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)switchMapDelayErrorWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)func;

/*!
 @brief Converts an Observable that emits Observables into an Observable that emits the items emitted by the
 most recently emitted of those Observables.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png" alt="">
 <p>
 <code>switchOnNext</code> subscribes to an Observable that emits Observables. Each time it observes one of
 these emitted Observables, the Observable returned by <code>switchOnNext</code> begins emitting the items
 emitted by that Observable. When a new Observable is emitted, <code>switchOnNext</code> stops emitting items
 from the earlier-emitted Observable and begins emitting items from the new one.
 <p>
 The resulting Observable completes if both the outer Observable and the last inner Observable, if any, complete.
 If the outer Observable signals an onError, the inner Observable is unsubscribed and the error delivered in-sequence.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>switchOnNext</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sequenceOfSequences
 the source Observable that emits Observables
 @return an Observable that emits the items emitted by the Observable most recently emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/switch.html">ReactiveX operators documentation: Switch</a>
 */
+ (RxObservable *)switchOnNextWithRxObservable:(RxObservable *)sequenceOfSequences;

/*!
 @brief Converts an Observable that emits Observables into an Observable that emits the items emitted by the
 most recently emitted of those Observables and delays any exception until all Observables terminate.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png" alt="">
 <p>
 <code>switchOnNext</code> subscribes to an Observable that emits Observables. Each time it observes one of
 these emitted Observables, the Observable returned by <code>switchOnNext</code> begins emitting the items
 emitted by that Observable. When a new Observable is emitted, <code>switchOnNext</code> stops emitting items
 from the earlier-emitted Observable and begins emitting items from the new one.
 <p>
 The resulting Observable completes if both the main Observable and the last inner Observable, if any, complete.
 If the main Observable signals an onError, the termination of the last inner Observable will emit that error as is
 or wrapped into a CompositeException along with the other possible errors the former inner Observables signalled.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>switchOnNext</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sequenceOfSequences
 the source Observable that emits Observables
 @return an Observable that emits the items emitted by the Observable most recently emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/switch.html">ReactiveX operators documentation: Switch</a>
  The behavior of this can change at any time.
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)switchOnNextDelayErrorWithRxObservable:(RxObservable *)sequenceOfSequences;

/*!
 @brief Returns an Observable that emits only the first <code>count</code> items emitted by the source Observable.
 If the source emits fewer than 
 <code>count</code> items then all of its items are emitted.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.png" alt="">
 <p>
 This method returns an Observable that will invoke a subscribing <code>Observer</code>'s
 <code>onNext</code> function a maximum of <code>count</code> times before invoking
 <code>onCompleted</code>.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>take</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum number of items to emit
 @return an Observable that emits only the first <code>count</code> items emitted by the source Observable, or
 all of the items from the source Observable if that Observable emits fewer than <code>count</code> items
 - seealso: <a href="http://reactivex.io/documentation/operators/take.html">ReactiveX operators documentation: Take</a>
 */
- (RxObservable *)takeWithInt:(jint)count;

/*!
 @brief Returns an Observable that emits those items emitted by source Observable before a specified time runs
 out.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.t.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>take</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @return an Observable that emits those items emitted by the source Observable before the time runs out
 - seealso: <a href="http://reactivex.io/documentation/operators/take.html">ReactiveX operators documentation: Take</a>
 */
- (RxObservable *)takeWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits those items emitted by source Observable before a specified time (on a
 specified Scheduler) runs out.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.ts.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the Scheduler used for time source
 @return an Observable that emits those items emitted by the source Observable before the time runs out,
 according to the specified Scheduler
 - seealso: <a href="http://reactivex.io/documentation/operators/take.html">ReactiveX operators documentation: Take</a>
 */
- (RxObservable *)takeWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
               withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
 a specified condition.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeFirstN.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>takeFirst</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 the condition any item emitted by the source Observable has to satisfy
 @return an Observable that emits only the very first item emitted by the source Observable that satisfies
 the given condition, or that completes without emitting anything if the source Observable
 completes without emitting a single condition-satisfying item
 - seealso: <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
 */
- (RxObservable *)takeFirstWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Returns an Observable that emits at most the last <code>count</code> items emitted by the source Observable.
 If the source emits fewer than 
 <code>count</code> items then all of its items are emitted.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.n.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>takeLast</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum number of items to emit from the end of the sequence of items emitted by the source
 Observable
 @return an Observable that emits at most the last <code>count</code> items emitted by the source Observable
 @throws IndexOutOfBoundsException
 if <code>count</code> is less than zero
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastWithInt:(jint)count;

/*!
 @brief Returns an Observable that emits at most a specified number of items from the source Observable that were
 emitted in a specified window of time before the Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tn.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>takeLast</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum number of items to emit
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @return an Observable that emits at most <code>count</code> items from the source Observable that were emitted
 in a specified window of time before the Observable completed
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastWithInt:(jint)count
                         withLong:(jlong)time
   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits at most a specified number of items from the source Observable that were
 emitted in a specified window of time before the Observable completed, where the timing information is
 provided by a given Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tns.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param count
 the maximum number of items to emit
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the <code>Scheduler</code> that provides the timestamps for the observed items
 @return an Observable that emits at most <code>count</code> items from the source Observable that were emitted
 in a specified window of time before the Observable completed, where the timing information is
 provided by the given <code>scheduler</code>
 @throws IndexOutOfBoundsException
 if <code>count</code> is less than zero
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastWithInt:(jint)count
                         withLong:(jlong)time
   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                  withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits the items from the source Observable that were emitted in a specified
 window of time before the Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.t.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>takeLast</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @return an Observable that emits the items from the source Observable that were emitted in the window of
 time before the Observable completed specified by <code>time</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastWithLong:(jlong)time
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits the items from the source Observable that were emitted in a specified
 window of time before the Observable completed, where the timing information is provided by a specified
 Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.ts.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the Scheduler that provides the timestamps for the Observed items
 @return an Observable that emits the items from the source Observable that were emitted in the window of
 time before the Observable completed specified by <code>time</code>, where the timing information is
 provided by <code>scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastWithLong:(jlong)time
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                   withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits a single List containing at most the last <code>count</code> elements emitted by the
 source Observable.
 If the source emits fewer than <code>count</code> items then the emitted List will contain all of the source emissions.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>takeLastBuffer</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum number of items to emit in the list
 @return an Observable that emits a single list containing at most the last <code>count</code> elements emitted by the
 source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastBufferWithInt:(jint)count;

/*!
 @brief Returns an Observable that emits a single List containing at most <code>count</code> items from the source
 Observable that were emitted during a specified window of time before the source Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.tn.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>takeLastBuffer</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum number of items to emit
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @return an Observable that emits a single List containing at most <code>count</code> items emitted by the
 source Observable during the time window defined by <code>time</code> before the source Observable
 completed
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastBufferWithInt:(jint)count
                               withLong:(jlong)time
         withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits a single List containing at most <code>count</code> items from the source
 Observable that were emitted during a specified window of time (on a specified Scheduler) before the
 source Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.tns.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param count
 the maximum number of items to emit
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the Scheduler that provides the timestamps for the observed items
 @return an Observable that emits a single List containing at most <code>count</code> items emitted by the
 source Observable during the time window defined by <code>time</code> before the source Observable
 completed
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastBufferWithInt:(jint)count
                               withLong:(jlong)time
         withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                        withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits a single List containing those items from the source Observable that
 were emitted during a specified window of time before the source Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.t.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>takeLastBuffer</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @return an Observable that emits a single List containing the items emitted by the source Observable
 during the time window defined by <code>time</code> before the source Observable completed
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastBufferWithLong:(jlong)time
          withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits a single List containing those items from the source Observable that
 were emitted during a specified window of time before the source Observable completed, where the timing
 information is provided by the given Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.ts.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param time
 the length of the time window
 @param unit
 the time unit of <code>time</code>
 @param scheduler
 the Scheduler that provides the timestamps for the observed items
 @return an Observable that emits a single List containing the items emitted by the source Observable
 during the time window defined by <code>time</code> before the source Observable completed, where the
 timing information is provided by <code>scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>
 */
- (RxObservable *)takeLastBufferWithLong:(jlong)time
          withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                         withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits items emitted by the source Observable, checks the specified predicate
 for each item, and then completes if the condition is satisfied.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.p.png" alt="">
 <p>
 The difference between this operator and <code>takeWhile(Func1)</code> is that here, the condition is
 evaluated <em>after</em> the item is emitted.
  "Scheduler" and "Backpressure Support" sections missing from javadocs
 @param stopPredicate 
 a function that evaluates an item emitted by the source Observable and returns a Boolean
 @return an Observable that first emits items emitted by the source Observable, checks the specified
 condition after each item, and then completes if the condition is satisfied.
 - seealso: <a href="http://reactivex.io/documentation/operators/takeuntil.html">ReactiveX operators documentation: TakeUntil</a>
 - seealso: Observable#takeWhile(Func1)
 @since 1.1.0
 */
- (RxObservable *)takeUntilWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)stopPredicate;

/*!
 @brief Returns an Observable that emits the items emitted by the source Observable until a second Observable
 emits an item.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>takeUntil</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param other
 the Observable whose first emitted item will cause <code>takeUntil</code> to stop emitting items
 from the source Observable
 @return an Observable that emits the items emitted by the source Observable until such time as <code>other</code> emits its first item
 - seealso: <a href="http://reactivex.io/documentation/operators/takeuntil.html">ReactiveX operators documentation: TakeUntil</a>
 */
- (RxObservable *)takeUntilWithRxObservable:(RxObservable *)other;

/*!
 @brief Returns an Observable that emits items emitted by the source Observable so long as each item satisfied a
 specified condition, and then completes as soon as this condition is not satisfied.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeWhile.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>takeWhile</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param predicate
 a function that evaluates an item emitted by the source Observable and returns a Boolean
 @return an Observable that emits the items from the source Observable so long as each item satisfies the
 condition defined by <code>predicate</code>, then completes
 - seealso: <a href="http://reactivex.io/documentation/operators/takewhile.html">ReactiveX operators documentation: TakeWhile</a>
 - seealso: Observable#takeUntil(Func1)
 */
- (RxObservable *)takeWhileWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)predicate;

/*!
 @brief Returns an Observable that emits only the first item emitted by the source Observable during sequential
 time windows of a specified duration.
 <p>
 This differs from <code>throttleLast</code> in that this only tracks passage of time whereas
 <code>throttleLast</code> ticks at scheduled intervals.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>throttleFirst</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param windowDuration
 time to wait before emitting another item after emitting the last item
 @param unit
 the unit of time of <code>windowDuration</code>
 @return an Observable that performs the throttle operation
 - seealso: <a href="http://reactivex.io/documentation/operators/sample.html">ReactiveX operators documentation: Sample</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 */
- (RxObservable *)throttleFirstWithLong:(jlong)windowDuration
         withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits only the first item emitted by the source Observable during sequential
 time windows of a specified duration, where the windows are managed by a specified Scheduler.
 <p>
 This differs from <code>throttleLast</code> in that this only tracks passage of time whereas
 <code>throttleLast</code> ticks at scheduled intervals.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param skipDuration
 time to wait before emitting another item after emitting the last item
 @param unit
 the unit of time of <code>skipDuration</code>
 @param scheduler
 the <code>Scheduler</code> to use internally to manage the timers that handle timeout for each
 event
 @return an Observable that performs the throttle operation
 - seealso: <a href="http://reactivex.io/documentation/operators/sample.html">ReactiveX operators documentation: Sample</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 */
- (RxObservable *)throttleFirstWithLong:(jlong)skipDuration
         withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                        withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits only the last item emitted by the source Observable during sequential
 time windows of a specified duration.
 <p>
 This differs from <code>throttleFirst</code> in that this ticks along at a scheduled interval whereas
 <code>throttleFirst</code> does not tick, it just tracks passage of time.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>throttleLast</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param intervalDuration
 duration of windows within which the last item emitted by the source Observable will be
 emitted
 @param unit
 the unit of time of <code>intervalDuration</code>
 @return an Observable that performs the throttle operation
 - seealso: <a href="http://reactivex.io/documentation/operators/sample.html">ReactiveX operators documentation: Sample</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 - seealso: #sample(long,TimeUnit)
 */
- (RxObservable *)throttleLastWithLong:(jlong)intervalDuration
        withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits only the last item emitted by the source Observable during sequential
 time windows of a specified duration, where the duration is governed by a specified Scheduler.
 <p>
 This differs from <code>throttleFirst</code> in that this ticks along at a scheduled interval whereas
 <code>throttleFirst</code> does not tick, it just tracks passage of time.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param intervalDuration
 duration of windows within which the last item emitted by the source Observable will be
 emitted
 @param unit
 the unit of time of <code>intervalDuration</code>
 @param scheduler
 the <code>Scheduler</code> to use internally to manage the timers that handle timeout for each
 event
 @return an Observable that performs the throttle operation
 - seealso: <a href="http://reactivex.io/documentation/operators/sample.html">ReactiveX operators documentation: Sample</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 - seealso: #sample(long,TimeUnit,Scheduler)
 */
- (RxObservable *)throttleLastWithLong:(jlong)intervalDuration
        withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                       withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that only emits those items emitted by the source Observable that are not followed
 by another emitted item within a specified time window.
 <p>
 <em>Note:</em> If the source Observable keeps emitting items more frequently than the length of the time
 window then no items will be emitted by the resulting Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleWithTimeout.png" alt="">
 <p>
 Information on debounce vs throttle:
 <p>
 <ul>
 <li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">Debounce and Throttle: visual explanation</a></li>
 <li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/">Debouncing: javascript methods</a></li>
 <li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/">Javascript - don't spam your server: debounce and throttle</a></li>
 </ul>
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>throttleWithTimeout</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timeout
 the length of the window of time that must pass after the emission of an item from the source
 Observable in which that Observable emits no items in order for the item to be emitted by the
 resulting Observable
 @param unit
 the <code>TimeUnit</code> of <code>timeout</code>
 @return an Observable that filters out items that are too quickly followed by newer items
 - seealso: <a href="http://reactivex.io/documentation/operators/debounce.html">ReactiveX operators documentation: Debounce</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 - seealso: #debounce(long,TimeUnit)
 */
- (RxObservable *)throttleWithTimeoutWithLong:(jlong)timeout
               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that only emits those items emitted by the source Observable that are not followed
 by another emitted item within a specified time window, where the time window is governed by a specified
 Scheduler.
 <p>
 <em>Note:</em> If the source Observable keeps emitting items more frequently than the length of the time
 window then no items will be emitted by the resulting Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleWithTimeout.s.png" alt="">
 <p>
 Information on debounce vs throttle:
 <p>
 <ul>
 <li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">Debounce and Throttle: visual explanation</a></li>
 <li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/">Debouncing: javascript methods</a></li>
 <li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/">Javascript - don't spam your server: debounce and throttle</a></li>
 </ul>
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timeout
 the length of the window of time that must pass after the emission of an item from the source
 Observable in which that Observable emits no items in order for the item to be emitted by the
 resulting Observable
 @param unit
 the <code>TimeUnit</code> of <code>timeout</code>
 @param scheduler
 the <code>Scheduler</code> to use internally to manage the timers that handle the timeout for each
 item
 @return an Observable that filters out items that are too quickly followed by newer items
 - seealso: <a href="http://reactivex.io/documentation/operators/debounce.html">ReactiveX operators documentation: Debounce</a>
 - seealso: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>
 - seealso: #debounce(long,TimeUnit,Scheduler)
 */
- (RxObservable *)throttleWithTimeoutWithLong:(jlong)timeout
               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                              withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits records of the time interval between consecutive items emitted by the
 source Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>timeInterval</code> operates by default on the <code>immediate</code> <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits time interval information items
 - seealso: <a href="http://reactivex.io/documentation/operators/timeinterval.html">ReactiveX operators documentation: TimeInterval</a>
 */
- (RxObservable *)timeInterval;

/*!
 @brief Returns an Observable that emits records of the time interval between consecutive items emitted by the
 source Observable, where this interval is computed on a specified Scheduler.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.s.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler
 the <code>Scheduler</code> used to compute time intervals
 @return an Observable that emits time interval information items
 - seealso: <a href="http://reactivex.io/documentation/operators/timeinterval.html">ReactiveX operators documentation: TimeInterval</a>
 */
- (RxObservable *)timeIntervalWithRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that mirrors the source Observable, but notifies observers of a
 <code>TimeoutException</code> if either the first item emitted by the source Observable or any subsequent item
 doesn't arrive within time windows defined by other Observables.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout5.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>timeout</code> operates by default on the <code>immediate</code> <code>Scheduler</code>.</dd>
 </dl>
 @param firstTimeoutSelector
 a function that returns an Observable that determines the timeout window for the first source
 item
 @param timeoutSelector
 a function that returns an Observable for each item emitted by the source Observable and that
 determines the timeout window in which the subsequent source item must arrive in order to
 continue the sequence
 @return an Observable that mirrors the source Observable, but notifies observers of a
 <code>TimeoutException</code> if either the first item or any subsequent item doesn't arrive within
 the time windows specified by the timeout selectors
 - seealso: <a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX operators documentation: Timeout</a>
 */
- (RxObservable *)timeoutWithRxFunctionsFunc0:(id<RxFunctionsFunc0>)firstTimeoutSelector
                         withRxFunctionsFunc1:(id<RxFunctionsFunc1>)timeoutSelector;

/*!
 @brief Returns an Observable that mirrors the source Observable, but switches to a fallback Observable if either
 the first item emitted by the source Observable or any subsequent item doesn't arrive within time windows
 defined by other Observables.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout6.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>timeout</code> operates by default on the <code>immediate</code> <code>Scheduler</code>.</dd>
 </dl>
 @param firstTimeoutSelector
 a function that returns an Observable which determines the timeout window for the first source
 item
 @param timeoutSelector
 a function that returns an Observable for each item emitted by the source Observable and that
 determines the timeout window in which the subsequent source item must arrive in order to
 continue the sequence
 @param other
 the fallback Observable to switch to if the source Observable times out
 @return an Observable that mirrors the source Observable, but switches to the <code>other</code> Observable if
 either the first item emitted by the source Observable or any subsequent item doesn't arrive
 within time windows defined by the timeout selectors
 @throws NullPointerException
 if <code>timeoutSelector</code> is null
 - seealso: <a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX operators documentation: Timeout</a>
 */
- (RxObservable *)timeoutWithRxFunctionsFunc0:(id<RxFunctionsFunc0>)firstTimeoutSelector
                         withRxFunctionsFunc1:(id<RxFunctionsFunc1>)timeoutSelector
                             withRxObservable:(RxObservable *)other;

/*!
 @brief Returns an Observable that mirrors the source Observable, but notifies observers of a
 <code>TimeoutException</code> if an item emitted by the source Observable doesn't arrive within a window of
 time after the emission of the previous item, where that period of time is measured by an Observable that
 is a function of the previous item.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout3.png" alt="">
 <p>
 Note: The arrival of the first source item is never timed out.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>timeout</code> operates by default on the <code>immediate</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timeoutSelector
 a function that returns an observable for each item emitted by the source
 Observable and that determines the timeout window for the subsequent item
 @return an Observable that mirrors the source Observable, but notifies observers of a
 <code>TimeoutException</code> if an item emitted by the source Observable takes longer to arrive than
 the time window defined by the selector for the previously emitted item
 - seealso: <a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX operators documentation: Timeout</a>
 */
- (RxObservable *)timeoutWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)timeoutSelector;

/*!
 @brief Returns an Observable that mirrors the source Observable, but that switches to a fallback Observable if
 an item emitted by the source Observable doesn't arrive within a window of time after the emission of the
 previous item, where that period of time is measured by an Observable that is a function of the previous
 item.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout4.png" alt="">
 <p>
 Note: The arrival of the first source item is never timed out.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>timeout</code> operates by default on the <code>immediate</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timeoutSelector
 a function that returns an Observable, for each item emitted by the source Observable, that
 determines the timeout window for the subsequent item
 @param other
 the fallback Observable to switch to if the source Observable times out
 @return an Observable that mirrors the source Observable, but switches to mirroring a fallback Observable
 if an item emitted by the source Observable takes longer to arrive than the time window defined
 by the selector for the previously emitted item
 - seealso: <a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX operators documentation: Timeout</a>
 */
- (RxObservable *)timeoutWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)timeoutSelector
                             withRxObservable:(RxObservable *)other;

/*!
 @brief Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item.
 If the next item isn't emitted within the specified timeout duration starting from its predecessor,
 the resulting Observable terminates and notifies observers of a <code>TimeoutException</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>timeout</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timeout
 maximum duration between emitted items before a timeout occurs
 @param timeUnit
 the unit of time that applies to the <code>timeout</code> argument.
 @return the source Observable modified to notify observers of a <code>TimeoutException</code> in case of a
 timeout
 - seealso: <a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX operators documentation: Timeout</a>
 */
- (RxObservable *)timeoutWithLong:(jlong)timeout
   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)timeUnit;

/*!
 @brief Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item.
 If the next item isn't emitted within the specified timeout duration starting from its predecessor,
 the resulting Observable begins instead to mirror a fallback Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>timeout</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timeout
 maximum duration between items before a timeout occurs
 @param timeUnit
 the unit of time that applies to the <code>timeout</code> argument
 @param other
 the fallback Observable to use in case of a timeout
 @return the source Observable modified to switch to the fallback Observable in case of a timeout
 - seealso: <a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX operators documentation: Timeout</a>
 */
- (RxObservable *)timeoutWithLong:(jlong)timeout
   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)timeUnit
                 withRxObservable:(RxObservable *)other;

/*!
 @brief Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item using a specified Scheduler.
 If the next item isn't emitted within the specified timeout duration
 starting from its predecessor, the resulting Observable begins instead to mirror a fallback Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2s.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timeout
 maximum duration between items before a timeout occurs
 @param timeUnit
 the unit of time that applies to the <code>timeout</code> argument
 @param other
 the Observable to use as the fallback in case of a timeout
 @param scheduler
 the <code>Scheduler</code> to run the timeout timers on
 @return the source Observable modified so that it will switch to the fallback Observable in case of a
 timeout
 - seealso: <a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX operators documentation: Timeout</a>
 */
- (RxObservable *)timeoutWithLong:(jlong)timeout
   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)timeUnit
                 withRxObservable:(RxObservable *)other
                  withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item, where this policy is governed on a specified Scheduler.
 If the next item isn't emitted within the
 specified timeout duration starting from its predecessor, the resulting Observable terminates and
 notifies observers of a <code>TimeoutException</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1s.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timeout
 maximum duration between items before a timeout occurs
 @param timeUnit
 the unit of time that applies to the <code>timeout</code> argument
 @param scheduler
 the Scheduler to run the timeout timers on
 @return the source Observable modified to notify observers of a <code>TimeoutException</code> in case of a
 timeout
 - seealso: <a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX operators documentation: Timeout</a>
 */
- (RxObservable *)timeoutWithLong:(jlong)timeout
   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)timeUnit
                  withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits a <code>0L</code> after the <code>initialDelay</code> and ever increasing numbers
 after each <code>period</code> of time thereafter.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.p.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate
 it should slow the timer or use something like <code>onBackpressureDrop</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>timer</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param initialDelay
 the initial delay time to wait before emitting the first value of 0L
 @param period
 the period of time between emissions of the subsequent numbers
 @param unit
 the time unit for both <code>initialDelay</code> and <code>period</code>
 @return an Observable that emits a 0L after the <code>initialDelay</code> and ever increasing numbers after
 each <code>period</code> of time thereafter
 - seealso: <a href="http://reactivex.io/documentation/operators/timer.html">ReactiveX operators documentation: Timer</a>
 */
+ (RxObservable *)timerWithLong:(jlong)initialDelay
                       withLong:(jlong)period
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits a <code>0L</code> after the <code>initialDelay</code> and ever increasing numbers
 after each <code>period</code> of time thereafter, on a specified <code>Scheduler</code>.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.ps.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate
 it should slow the timer or use something like <code>onBackpressureDrop</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param initialDelay
 the initial delay time to wait before emitting the first value of 0L
 @param period
 the period of time between emissions of the subsequent numbers
 @param unit
 the time unit for both <code>initialDelay</code> and <code>period</code>
 @param scheduler
 the Scheduler on which the waiting happens and items are emitted
 @return an Observable that emits a 0L after the <code>initialDelay</code> and ever increasing numbers after
 each <code>period</code> of time thereafter, while running on the given Scheduler
 - seealso: <a href="http://reactivex.io/documentation/operators/timer.html">ReactiveX operators documentation: Timer</a>
 */
+ (RxObservable *)timerWithLong:(jlong)initialDelay
                       withLong:(jlong)period
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits one item after a specified delay, and then completes.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate
 it should slow the timer or use something like <code>onBackpressureDrop</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>timer</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param delay
 the initial delay before emitting a single <code>0L</code>
 @param unit
 time units to use for <code>delay</code>
 @return an Observable that emits one item after a specified delay, and then completes
 - seealso: <a href="http://reactivex.io/documentation/operators/timer.html">ReactiveX operators documentation: Timer</a>
 */
+ (RxObservable *)timerWithLong:(jlong)delay
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits one item after a specified delay, on a specified Scheduler, and then
 completes.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rate
 it should slow the timer or use something like <code>onBackpressureDrop</code>.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param delay
 the initial delay before emitting a single 0L
 @param unit
 time units to use for <code>delay</code>
 @param scheduler
 the <code>Scheduler</code> to use for scheduling the item
 @return an Observable that emits one item after a specified delay, on a specified Scheduler, and then
 completes
 - seealso: <a href="http://reactivex.io/documentation/operators/timer.html">ReactiveX operators documentation: Timer</a>
 */
+ (RxObservable *)timerWithLong:(jlong)delay
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits each item emitted by the source Observable, wrapped in a
 <code>Timestamped</code> object.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>timestamp</code> operates by default on the <code>immediate</code> <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits timestamped items from the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/timestamp.html">ReactiveX operators documentation: Timestamp</a>
 */
- (RxObservable *)timestamp;

/*!
 @brief Returns an Observable that emits each item emitted by the source Observable, wrapped in a
 <code>Timestamped</code> object whose timestamps are provided by a specified Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.s.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler
 the <code>Scheduler</code> to use as a time source
 @return an Observable that emits timestamped items from the source Observable with timestamps provided by
 the <code>scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/timestamp.html">ReactiveX operators documentation: Timestamp</a>
 */
- (RxObservable *)timestampWithRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Converts an Observable into a <code>BlockingObservable</code> (an Observable with blocking operators).
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toBlocking</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return a <code>BlockingObservable</code> version of this Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservablesBlockingObservable *)toBlocking;

/*!
 @brief Returns a Completable that discards all onNext emissions (similar to
 <code>ignoreAllElements()</code>) and calls onCompleted when this source observable calls
 onCompleted.
 Error terminal events are propagated.
 <p>
 <img width="640" height="295" src=
 "https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toCompletable.png"
 alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toCompletable</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return a Completable that calls onCompleted on it's subscriber when the source Observable
 calls onCompleted
 - seealso: <a href="http://reactivex.io/documentation/completable.html">ReactiveX documentation:
     *      Completable</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
 with the release number)
 */
- (RxCompletable *)toCompletable;

/*!
 @brief Returns an Observable that emits a single item, a list composed of all the items emitted by the source
 Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.png" alt="">
 <p>
 Normally, an Observable that returns multiple items will do so by invoking its <code>Observer</code>'s
 <code>onNext</code> method for each such item. You can change this behavior, instructing the
 Observable to compose a list of all of these items and then to invoke the Observer's <code>onNext</code>
 function once, passing it the entire list, by calling the Observable's <code>toList</code> method prior to
 calling its <code>subscribe</code> method.
 <p>
 Be careful not to use this operator on Observables that emit infinite or very large numbers of items, as
 you do not have the option to unsubscribe.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>The operator buffers everything from its upstream but it only emits the aggregated list when the downstream requests at least one item.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toList</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return an Observable that emits a single item: a List containing all of the items emitted by the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toList;

/*!
 @brief Returns an Observable that emits a single HashMap containing all items emitted by the source Observable,
 mapped by the keys returned by a specified <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.png" alt="">
 <p>
 If more than one source item maps to the same key, the HashMap will contain the latest of those items.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 the function that extracts the key from a source item to be used in the HashMap
 @return an Observable that emits a single item: a HashMap containing the mapped items from the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector;

/*!
 @brief Returns an Observable that emits a single HashMap containing values corresponding to items emitted by the
 source Observable, mapped by the keys returned by a specified <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.png" alt="">
 <p>
 If more than one source item maps to the same key, the HashMap will contain a single entry that
 corresponds to the latest of those items.
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 the function that extracts the key from a source item to be used in the HashMap
 @param valueSelector
 the function that extracts the value from a source item to be used in the HashMap
 @return an Observable that emits a single item: a HashMap containing the mapped items from the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector
                       withRxFunctionsFunc1:(id<RxFunctionsFunc1>)valueSelector;

/*!
 @brief Returns an Observable that emits a single Map, returned by a specified <code>mapFactory</code> function, that
 contains keys and values extracted from the items emitted by the source Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 the function that extracts the key from a source item to be used in the Map
 @param valueSelector
 the function that extracts the value from the source items to be used as value in the Map
 @param mapFactory
 the function that returns a Map instance to be used
 @return an Observable that emits a single item: a Map that contains the mapped items emitted by the
 source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toMapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector
                       withRxFunctionsFunc1:(id<RxFunctionsFunc1>)valueSelector
                       withRxFunctionsFunc0:(id<RxFunctionsFunc0>)mapFactory;

/*!
 @brief Returns an Observable that emits a single HashMap that contains an ArrayList of items emitted by the
 source Observable keyed by a specified <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toMultiMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 the function that extracts the key from the source items to be used as key in the HashMap
 @return an Observable that emits a single item: a HashMap that contains an ArrayList of items mapped from
 the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toMultimapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector;

/*!
 @brief Returns an Observable that emits a single HashMap that contains an ArrayList of values extracted by a
 specified <code>valueSelector</code> function from items emitted by the source Observable, keyed by a
 specified <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toMultiMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 the function that extracts a key from the source items to be used as key in the HashMap
 @param valueSelector
 the function that extracts a value from the source items to be used as value in the HashMap
 @return an Observable that emits a single item: a HashMap that contains an ArrayList of items mapped from
 the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toMultimapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector
                            withRxFunctionsFunc1:(id<RxFunctionsFunc1>)valueSelector;

/*!
 @brief Returns an Observable that emits a single Map, returned by a specified <code>mapFactory</code> function, that
 contains an ArrayList of values, extracted by a specified <code>valueSelector</code> function from items
 emitted by the source Observable and keyed by the <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toMultiMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 the function that extracts a key from the source items to be used as the key in the Map
 @param valueSelector
 the function that extracts a value from the source items to be used as the value in the Map
 @param mapFactory
 the function that returns a Map instance to be used
 @return an Observable that emits a single item: a Map that contains a list items mapped from the source
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toMultimapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector
                            withRxFunctionsFunc1:(id<RxFunctionsFunc1>)valueSelector
                            withRxFunctionsFunc0:(id<RxFunctionsFunc0>)mapFactory;

/*!
 @brief Returns an Observable that emits a single Map, returned by a specified <code>mapFactory</code> function, that
 contains a custom collection of values, extracted by a specified <code>valueSelector</code> function from
 items emitted by the source Observable, and keyed by the <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as by intent it is requesting and buffering everything.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toMultiMap</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param keySelector
 the function that extracts a key from the source items to be used as the key in the Map
 @param valueSelector
 the function that extracts a value from the source items to be used as the value in the Map
 @param mapFactory
 the function that returns a Map instance to be used
 @param collectionFactory
 the function that returns a Collection instance for a particular key to be used in the Map
 @return an Observable that emits a single item: a Map that contains the collection of mapped items from
 the source Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toMultimapWithRxFunctionsFunc1:(id<RxFunctionsFunc1>)keySelector
                            withRxFunctionsFunc1:(id<RxFunctionsFunc1>)valueSelector
                            withRxFunctionsFunc0:(id<RxFunctionsFunc0>)mapFactory
                            withRxFunctionsFunc1:(id<RxFunctionsFunc1>)collectionFactory;

/*!
 @brief Returns a Single that emits the single item emitted by the source Observable, if that Observable
 emits only a single item.
 If the source Observable emits more than one item or no items, notify of an
 <code>IllegalArgumentException</code> or <code>NoSuchElementException</code> respectively.
 <p>
 <img width="640" height="295" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toSingle.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toSingle</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @return a Single that emits the single item emitted by the source Observable
 @throws IllegalArgumentException
 if the source observable emits more than one item
 @throws NoSuchElementException
 if the source observable emits no items
 - seealso: <a href="http://reactivex.io/documentation/single.html">ReactiveX documentation: Single</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxSingle *)toSingle;

/*!
 @brief Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
 sorted order.
 Each item emitted by the Observable must implement <code>Comparable</code> with respect to all
 other items in the sequence.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>The operator buffers everything from its upstream but it only emits the sorted list when the downstream requests at least one item.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toSortedList</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @throws ClassCastException
 if any item emitted by the Observable does not implement <code>Comparable</code> with respect to
 all other items emitted by the Observable
 @return an Observable that emits a list that contains the items emitted by the source Observable in
 sorted order
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toSortedList;

/*!
 @brief Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
 sorted order based on a specified comparison function.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.f.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>The operator buffers everything from its upstream but it only emits the sorted list when the downstream requests at least one item.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toSortedList</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sortFunction
 a function that compares two items emitted by the source Observable and returns an Integer
 that indicates their sort order
 @return an Observable that emits a list that contains the items emitted by the source Observable in
 sorted order
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 */
- (RxObservable *)toSortedListWithRxFunctionsFunc2:(id<RxFunctionsFunc2>)sortFunction;

/*!
 @brief Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
 sorted order based on a specified comparison function.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.f.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>The operator buffers everything from its upstream but it only emits the sorted list when the downstream requests at least one item.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toSortedList</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param sortFunction
 a function that compares two items emitted by the source Observable and returns an Integer
 that indicates their sort order
 @param initialCapacity 
 the initial capacity of the ArrayList used to accumulate items before sorting
 @return an Observable that emits a list that contains the items emitted by the source Observable in
 sorted order
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)toSortedListWithRxFunctionsFunc2:(id<RxFunctionsFunc2>)sortFunction
                                           withInt:(jint)initialCapacity;

/*!
 @brief Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
 sorted order.
 Each item emitted by the Observable must implement <code>Comparable</code> with respect to all
 other items in the sequence.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>The operator buffers everything from its upstream but it only emits the sorted list when the downstream requests at least one item.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>toSortedList</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @throws ClassCastException
 if any item emitted by the Observable does not implement <code>Comparable</code> with respect to
 all other items emitted by the Observable
 @param initialCapacity 
 the initial capacity of the ArrayList used to accumulate items before sorting
 @return an Observable that emits a list that contains the items emitted by the source Observable in
 sorted order
 - seealso: <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
- (RxObservable *)toSortedListWithInt:(jint)initialCapacity;

/*!
 @brief Subscribes to an Observable and invokes <code>OnSubscribe</code> function without any contract protection,
 error handling, unsubscribe, or execution hooks.
 <p>
 Use this only for implementing an <code>Operator</code> that requires nested subscriptions. For other
 purposes, use <code>subscribe(Subscriber)</code> which ensures
 <a href="http://reactivex.io/documentation/contract.html">the Observable contract</a> and other
 functionality.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>unsafeSubscribe</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param subscriber
 the Subscriber that will handle emissions and notifications from the Observable
 @return a <code>Subscription</code> reference with which the <code>Subscriber</code> can stop receiving items
 before the Observable has completed
 */
- (id<RxSubscription>)unsafeSubscribeWithRxSubscriber:(RxSubscriber *)subscriber;

/*!
 @brief Modifies the source Observable so that subscribers will unsubscribe from it on a specified
 <code>Scheduler</code>.
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param scheduler
 the <code>Scheduler</code> to perform unsubscription actions on
 @return the source Observable modified so that its unsubscriptions happen on the specified
 <code>Scheduler</code>
 - seealso: <a href="http://reactivex.io/documentation/operators/subscribeon.html">ReactiveX operators documentation: SubscribeOn</a>
 */
- (RxObservable *)unsubscribeOnWithRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Constructs an Observable that creates a dependent resource object which is disposed of on unsubscription.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/using.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>using</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param resourceFactory
 the factory function to create a resource object that depends on the Observable
 @param observableFactory
 the factory function to create an Observable
 @param disposeAction
 the function that will dispose of the resource
 @return the Observable whose lifetime controls the lifetime of the dependent resource object
 - seealso: <a href="http://reactivex.io/documentation/operators/using.html">ReactiveX operators documentation: Using</a>
 */
+ (RxObservable *)using__WithRxFunctionsFunc0:(id<RxFunctionsFunc0>)resourceFactory
                         withRxFunctionsFunc1:(id<RxFunctionsFunc1>)observableFactory
                       withRxFunctionsAction1:(id<RxFunctionsAction1>)disposeAction;

/*!
 @brief Constructs an Observable that creates a dependent resource object which is disposed of just before 
 termination if you have set <code>disposeEagerly</code> to <code>true</code> and unsubscription does not occur
 before termination.
 Otherwise resource disposal will occur on unsubscription.  Eager disposal is
 particularly appropriate for a synchronous Observable that reuses resources. <code>disposeAction</code> will
 only be called once per subscription.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/using.png" alt="">
 <dl>
 <dt><b>Scheduler:</b></dt>
 <dd><code>using</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
  "Backpressure Support" section missing from javadoc
 @param resourceFactory
 the factory function to create a resource object that depends on the Observable
 @param observableFactory
 the factory function to create an Observable
 @param disposeAction
 the function that will dispose of the resource
 @param disposeEagerly
 if <code>true</code> then disposal will happen either on unsubscription or just before emission of 
 a terminal event (<code>onComplete</code> or <code>onError</code>).
 @return the Observable whose lifetime controls the lifetime of the dependent resource object
 - seealso: <a href="http://reactivex.io/documentation/operators/using.html">ReactiveX operators documentation: Using</a>
  The behavior of this can change at any time.
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 */
+ (RxObservable *)using__WithRxFunctionsFunc0:(id<RxFunctionsFunc0>)resourceFactory
                         withRxFunctionsFunc1:(id<RxFunctionsFunc1>)observableFactory
                       withRxFunctionsAction1:(id<RxFunctionsAction1>)disposeAction
                                  withBoolean:(jboolean)disposeEagerly;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping windows. It emits the current window and opens a new one
 whenever the Observable produced by the specified <code>closingSelector</code> emits an item.
 <p>
 <img width="640" height="460" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window1.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses the <code>closingSelector</code> to control data
 flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>window</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param closingSelector
 a <code>Func0</code> that returns an <code>Observable</code> that governs the boundary between windows.
 When this <code>Observable</code> emits an item, <code>window</code> emits the current window and begins
 a new one.
 @return an Observable that emits connected, non-overlapping windows of items from the source Observable
 whenever <code>closingSelector</code> emits an item
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithRxFunctionsFunc0:(id<RxFunctionsFunc0>)closingSelector;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping windows, each containing <code>count</code> items. When the source
 Observable completes or encounters an error, the resulting Observable emits the current window and
 propagates the notification from the source Observable.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window3.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Observable uses an
 unbounded buffer that may hold at most <code>count</code> elements.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>window</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum size of each window before it should be emitted
 @return an Observable that emits connected, non-overlapping windows, each containing at most
 <code>count</code> items from the source Observable
 @throws IllegalArgumentException if either count is non-positive
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithInt:(jint)count;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable emits windows every <code>skip</code> items, each containing no more than <code>count</code> items. When
 the source Observable completes or encounters an error, the resulting Observable emits the current window
 and propagates the notification from the source Observable.
 <p>
 <img width="640" height="365" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window4.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>The operator honors backpressure of its inner and outer subscribers, however, the inner Observable uses an
 unbounded buffer that may hold at most <code>count</code> elements.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>window</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param count
 the maximum size of each window before it should be emitted
 @param skip
 how many items need to be skipped before starting a new window. Note that if <code>skip</code> and
 <code>count</code> are equal this is the same operation as <code>window(int)</code>.
 @return an Observable that emits windows every <code>skip</code> items containing at most <code>count</code> items
 from the source Observable
 @throws IllegalArgumentException if either count or skip is non-positive
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithInt:(jint)count
                        withInt:(jint)skip;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable starts a new window periodically, as determined by the <code>timeshift</code> argument. It emits
 each window after a fixed timespan, specified by the <code>timespan</code> argument. When the source
 Observable completes or Observable completes or encounters an error, the resulting Observable emits the
 current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>window</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timespan
 the period of time each window collects items before it should be emitted
 @param timeshift
 the period of time after which a new window will be created
 @param unit
 the unit of time that applies to the <code>timespan</code> and <code>timeshift</code> arguments
 @return an Observable that emits new windows periodically as a fixed timespan elapses
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithLong:(jlong)timespan
                        withLong:(jlong)timeshift
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable starts a new window periodically, as determined by the <code>timeshift</code> argument or a maximum
 size as specified by the <code>count</code> argument (whichever is reached first). It emits
 each window after a fixed timespan, specified by the <code>timespan</code> argument. When the source
 Observable completes or Observable completes or encounters an error, the resulting Observable emits the
 current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timespan
 the period of time each window collects items before it should be emitted
 @param timeshift
 the period of time after which a new window will be created
 @param unit
 the unit of time that applies to the <code>timespan</code> and <code>timeshift</code> arguments
 @param count
 the maximum size of each window before it should be emitted
 @param scheduler
 the <code>Scheduler</code> to use when determining the end and start of a window
 @return an Observable that emits new windows periodically as a fixed timespan elapses
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithLong:(jlong)timespan
                        withLong:(jlong)timeshift
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                         withInt:(jint)count
                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable starts a new window periodically, as determined by the <code>timeshift</code> argument. It emits
 each window after a fixed timespan, specified by the <code>timespan</code> argument. When the source
 Observable completes or Observable completes or encounters an error, the resulting Observable emits the
 current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timespan
 the period of time each window collects items before it should be emitted
 @param timeshift
 the period of time after which a new window will be created
 @param unit
 the unit of time that applies to the <code>timespan</code> and <code>timeshift</code> arguments
 @param scheduler
 the <code>Scheduler</code> to use when determining the end and start of a window
 @return an Observable that emits new windows periodically as a fixed timespan elapses
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithLong:(jlong)timespan
                        withLong:(jlong)timeshift
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping windows, each of a fixed duration specified by the
 <code>timespan</code> argument. When the source Observable completes or encounters an error, the resulting
 Observable emits the current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="375" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window5.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>window</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timespan
 the period of time each window collects items before it should be emitted and replaced with a
 new window
 @param unit
 the unit of time that applies to the <code>timespan</code> argument
 @return an Observable that emits connected, non-overlapping windows representing items emitted by the
 source Observable during fixed, consecutive durations
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithLong:(jlong)timespan
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping windows, each of a fixed duration as specified by the
 <code>timespan</code> argument or a maximum size as specified by the <code>count</code> argument (whichever is
 reached first). When the source Observable completes or encounters an error, the resulting Observable
 emits the current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>window</code> operates by default on the <code>computation</code> <code>Scheduler</code>.</dd>
 </dl>
 @param timespan
 the period of time each window collects items before it should be emitted and replaced with a
 new window
 @param unit
 the unit of time that applies to the <code>timespan</code> argument
 @param count
 the maximum size of each window before it should be emitted
 @return an Observable that emits connected, non-overlapping windows of items from the source Observable
 that were emitted during a fixed duration of time or when the window has reached maximum capacity
 (whichever occurs first)
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithLong:(jlong)timespan
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                         withInt:(jint)count;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping windows, each of a fixed duration specified by the
 <code>timespan</code> argument or a maximum size specified by the <code>count</code> argument (whichever is reached
 first). When the source Observable completes or encounters an error, the resulting Observable emits the
 current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timespan
 the period of time each window collects items before it should be emitted and replaced with a
 new window
 @param unit
 the unit of time which applies to the <code>timespan</code> argument
 @param count
 the maximum size of each window before it should be emitted
 @param scheduler
 the <code>Scheduler</code> to use when determining the end and start of a window
 @return an Observable that emits connected, non-overlapping windows of items from the source Observable
 that were emitted during a fixed duration of time or when the window has reached maximum capacity
 (whichever occurs first)
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithLong:(jlong)timespan
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                         withInt:(jint)count
                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable emits connected, non-overlapping windows, each of a fixed duration as specified by the
 <code>timespan</code> argument. When the source Observable completes or encounters an error, the resulting
 Observable emits the current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="375" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window5.s.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses time to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>you specify which <code>Scheduler</code> this operator will use</dd>
 </dl>
 @param timespan
 the period of time each window collects items before it should be emitted and replaced with a
 new window
 @param unit
 the unit of time which applies to the <code>timespan</code> argument
 @param scheduler
 the <code>Scheduler</code> to use when determining the end and start of a window
 @return an Observable that emits connected, non-overlapping windows containing items emitted by the
 source Observable within a fixed duration
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithLong:(jlong)timespan
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                 withRxScheduler:(RxScheduler *)scheduler;

/*!
 @brief Returns an Observable that emits windows of items it collects from the source Observable.
 The resulting
 Observable emits windows that contain those items emitted by the source Observable between the time when
 the <code>windowOpenings</code> Observable emits an item and when the Observable returned by
 <code>closingSelector</code> emits an item.
 <p>
 <img width="640" height="550" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window2.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses Observables to control data flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>window</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param windowOpenings
 an Observable that, when it emits an item, causes another window to be created
 @param closingSelector
 a <code>Func1</code> that produces an Observable for every window created. When this Observable
 emits an item, the associated window is closed and emitted
 @return an Observable that emits windows of items emitted by the source Observable that are governed by
 the specified window-governing Observables
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithRxObservable:(RxObservable *)windowOpenings
                    withRxFunctionsFunc1:(id<RxFunctionsFunc1>)closingSelector;

/*!
 @brief Returns an Observable that emits non-overlapping windows of items it collects from the source Observable
 where the boundary of each window is determined by the items emitted from a specified boundary-governing
 Observable.
 <p>
 <img width="640" height="475" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window8.png" alt="">
 <dl>
 <dt><b>Backpressure Support:</b></dt>
 <dd>This operator does not support backpressure as it uses a <code>boundary</code> Observable to control data
 flow.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd>This version of <code>window</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param boundary
 an Observable whose emitted items close and open windows
 @return an Observable that emits non-overlapping windows of items it collects from the source Observable
 where the boundary of each window is determined by the items emitted from the <code>boundary</code>
 Observable
 - seealso: <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
 */
- (RxObservable *)windowWithRxObservable:(RxObservable *)boundary;

/*!
 @brief Merges the specified Observable into this Observable sequence by using the <code>resultSelector</code>
 function only when the source Observable (this instance) emits an item.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/withLatestFrom.png" alt="">
  "Backpressure Support" section missing from javadoc
  "Scheduler" section missing from javadoc
 @param other
 the other Observable
 @param resultSelector
 the function to call when this Observable emits an item and the other Observable has already
 emitted an item, to generate the item to be emitted by the resulting Observable
 @return an Observable that merges the specified Observable into this Observable by using the
 <code>resultSelector</code> function only when the source Observable sequence (this instance) emits an
 item
  The behavior of this can change at any time.
 @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
 - seealso: <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
 */
- (RxObservable *)withLatestFromWithRxObservable:(RxObservable *)other
                            withRxFunctionsFunc2:(id<RxFunctionsFunc2>)resultSelector;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 items emitted, in sequence, by an Iterable of other Observables.
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each of the source Observables;
 the second item emitted by the new Observable will be the result of the function applied to the second
 item emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code> as many times as
 the number of <code>onNext</code> invocations of the source Observable that emits the fewest items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(Arrays.asList(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2)), (a) -&gt; a)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param ws
 an Iterable of source Observables
 @param zipFunction
 a function that, when applied to an item emitted by each of the source Observables, results in
 an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithJavaLangIterable:(id<JavaLangIterable>)ws
                     withRxFunctionsFuncN:(id<RxFunctionsFuncN>)zipFunction;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 <i>n</i> items emitted, in sequence, by the <i>n</i> Observables emitted by a specified Observable.
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each of the Observables emitted
 by the source Observable; the second item emitted by the new Observable will be the result of the
 function applied to the second item emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code> as many times as
 the number of <code>onNext</code> invocations of the source Observable that emits the fewest items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(just(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2)), (a) -&gt; a)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.o.png" alt="">
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param ws
 an Observable of source Observables
 @param zipFunction
 a function that, when applied to an item emitted by each of the Observables emitted by
 <code>ws</code>, results in an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithRxObservable:(RxObservable *)ws
                 withRxFunctionsFuncN:(id<RxFunctionsFuncN>)zipFunction;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 two items emitted, in sequence, by two other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by <code>o1</code> and the first item
 emitted by <code>o2</code>; the second item emitted by the new Observable will be the result of the function
 applied to the second item emitted by <code>o1</code> and the second item emitted by <code>o2</code>; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2), (a, b) -&gt; a + b)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 a second source Observable
 @param zipFunction
 a function that, when applied to an item emitted by each of the source Observables, results
 in an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                 withRxFunctionsFunc2:(id<RxFunctionsFunc2>)zipFunction;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 three items emitted, in sequence, by three other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by <code>o1</code>, the first item
 emitted by <code>o2</code>, and the first item emitted by <code>o3</code>; the second item emitted by the new
 Observable will be the result of the function applied to the second item emitted by <code>o1</code>, the
 second item emitted by <code>o2</code>, and the second item emitted by <code>o3</code>; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2), ..., (a, b, c) -&gt; a + b)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 a second source Observable
 @param o3
 a third source Observable
 @param zipFunction
 a function that, when applied to an item emitted by each of the source Observables, results in
 an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                 withRxFunctionsFunc3:(id<RxFunctionsFunc3>)zipFunction;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 four items emitted, in sequence, by four other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by <code>o1</code>, the first item
 emitted by <code>o2</code>, the first item emitted by <code>o3</code>, and the first item emitted by <code>04</code>;
 the second item emitted by the new Observable will be the result of the function applied to the second
 item emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2), ..., (a, b, c, d) -&gt; a + b)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 a second source Observable
 @param o3
 a third source Observable
 @param o4
 a fourth source Observable
 @param zipFunction
 a function that, when applied to an item emitted by each of the source Observables, results in
 an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                 withRxFunctionsFunc4:(id<RxFunctionsFunc4>)zipFunction;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 five items emitted, in sequence, by five other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by <code>o1</code>, the first item
 emitted by <code>o2</code>, the first item emitted by <code>o3</code>, the first item emitted by <code>o4</code>, and
 the first item emitted by <code>o5</code>; the second item emitted by the new Observable will be the result of
 the function applied to the second item emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2), ..., (a, b, c, d, e) -&gt; a + b)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 a second source Observable
 @param o3
 a third source Observable
 @param o4
 a fourth source Observable
 @param o5
 a fifth source Observable
 @param zipFunction
 a function that, when applied to an item emitted by each of the source Observables, results in
 an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5
                 withRxFunctionsFunc5:(id<RxFunctionsFunc5>)zipFunction;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 six items emitted, in sequence, by six other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each source Observable, the
 second item emitted by the new Observable will be the result of the function applied to the second item
 emitted by each of those Observables, and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2), ..., (a, b, c, d, e, f) -&gt; a + b)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 a second source Observable
 @param o3
 a third source Observable
 @param o4
 a fourth source Observable
 @param o5
 a fifth source Observable
 @param o6
 a sixth source Observable
 @param zipFunction
 a function that, when applied to an item emitted by each of the source Observables, results in
 an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5
                     withRxObservable:(RxObservable *)o6
                 withRxFunctionsFunc6:(id<RxFunctionsFunc6>)zipFunction;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 seven items emitted, in sequence, by seven other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each source Observable, the
 second item emitted by the new Observable will be the result of the function applied to the second item
 emitted by each of those Observables, and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2), ..., (a, b, c, d, e, f, g) -&gt; a + b)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 a second source Observable
 @param o3
 a third source Observable
 @param o4
 a fourth source Observable
 @param o5
 a fifth source Observable
 @param o6
 a sixth source Observable
 @param o7
 a seventh source Observable
 @param zipFunction
 a function that, when applied to an item emitted by each of the source Observables, results in
 an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5
                     withRxObservable:(RxObservable *)o6
                     withRxObservable:(RxObservable *)o7
                 withRxFunctionsFunc7:(id<RxFunctionsFunc7>)zipFunction;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 eight items emitted, in sequence, by eight other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each source Observable, the
 second item emitted by the new Observable will be the result of the function applied to the second item
 emitted by each of those Observables, and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2), ..., (a, b, c, d, e, f, g, h) -&gt; a + b)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 a second source Observable
 @param o3
 a third source Observable
 @param o4
 a fourth source Observable
 @param o5
 a fifth source Observable
 @param o6
 a sixth source Observable
 @param o7
 a seventh source Observable
 @param o8
 an eighth source Observable
 @param zipFunction
 a function that, when applied to an item emitted by each of the source Observables, results in
 an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5
                     withRxObservable:(RxObservable *)o6
                     withRxObservable:(RxObservable *)o7
                     withRxObservable:(RxObservable *)o8
                 withRxFunctionsFunc8:(id<RxFunctionsFunc8>)zipFunction;

/*!
 @brief Returns an Observable that emits the results of a specified combiner function applied to combinations of
 nine items emitted, in sequence, by nine other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each source Observable, the
 second item emitted by the new Observable will be the result of the function applied to the second item
 emitted by each of those Observables, and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke <code>onNext</code>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>zip(range(1, 5).doOnCompleted(action1), range(6, 5).doOnCompleted(action2), ..., (a, b, c, d, e, f, g, h, i) -&gt; a + b)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zip</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param o1
 the first source Observable
 @param o2
 a second source Observable
 @param o3
 a third source Observable
 @param o4
 a fourth source Observable
 @param o5
 a fifth source Observable
 @param o6
 a sixth source Observable
 @param o7
 a seventh source Observable
 @param o8
 an eighth source Observable
 @param o9
 a ninth source Observable
 @param zipFunction
 a function that, when applied to an item emitted by each of the source Observables, results in
 an item that will be emitted by the resulting Observable
 @return an Observable that emits the zipped results
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
+ (RxObservable *)zipWithRxObservable:(RxObservable *)o1
                     withRxObservable:(RxObservable *)o2
                     withRxObservable:(RxObservable *)o3
                     withRxObservable:(RxObservable *)o4
                     withRxObservable:(RxObservable *)o5
                     withRxObservable:(RxObservable *)o6
                     withRxObservable:(RxObservable *)o7
                     withRxObservable:(RxObservable *)o8
                     withRxObservable:(RxObservable *)o9
                 withRxFunctionsFunc9:(id<RxFunctionsFunc9>)zipFunction;

/*!
 @brief Returns an Observable that emits items that are the result of applying a specified function to pairs of
 values, one each from the source Observable and a specified Iterable sequence.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.i.png" alt="">
 <p>
 Note that the <code>other</code> Iterable is evaluated as items are observed from the source Observable; it is
 not pre-consumed. This allows you to zip infinite streams on either side.
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zipWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param other
 the Iterable sequence
 @param zipFunction
 a function that combines the pairs of items from the Observable and the Iterable to generate
 the items to be emitted by the resulting Observable
 @return an Observable that pairs up values from the source Observable and the <code>other</code> Iterable
 sequence and emits the results of <code>zipFunction</code> applied to these pairs
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
- (RxObservable *)zipWithWithJavaLangIterable:(id<JavaLangIterable>)other
                         withRxFunctionsFunc2:(id<RxFunctionsFunc2>)zipFunction;

/*!
 @brief Returns an Observable that emits items that are the result of applying a specified function to pairs of
 values, one each from the source Observable and another specified Observable.
 <p>
 <p>
 The operator subscribes to its sources in order they are specified and completes eagerly if 
 one of the sources is shorter than the rest while unsubscribing the other sources. Therefore, it 
 is possible those other sources will never be able to run to completion (and thus not calling 
 <code>doOnCompleted()</code>). This can also happen if the sources are exactly the same length; if
 source A completes and B has been consumed and is about to complete, the operator detects A won't
 be sending further values and it will unsubscribe B immediately. For example:
 @code
<code>range(1, 5).doOnCompleted(action1).zipWith(range(6, 5).doOnCompleted(action2), (a, b) -&gt; a + b)</code>
@endcode
 <code>action1</code> will be called but <code>action2</code> won't.
 <br>To work around this termination property,
 use <code>doOnUnsubscribed()</code> as well or use <code>using()</code> to do cleanup in case of completion 
 or unsubscription.
 <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
 <dl>
 <dt><b>Backpressure:</b><dt>
 <dd>The operator expects backpressure from the sources and honors backpressure from the downstream.
 (I.e., zipping with <code>interval(long,TimeUnit)</code> may result in MissingBackpressureException, use
 one of the <code>onBackpressureX</code> to handle similar, backpressure-ignoring sources.</dd>
 <dt><b>Scheduler:</b></dt>
 <dd><code>zipWith</code> does not operate by default on a particular <code>Scheduler</code>.</dd>
 </dl>
 @param other
 the other Observable
 @param zipFunction
 a function that combines the pairs of items from the two Observables to generate the items to
 be emitted by the resulting Observable
 @return an Observable that pairs up values from the source Observable and the <code>other</code> Observable
 and emits the results of <code>zipFunction</code> applied to these pairs
 - seealso: <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
 */
- (RxObservable *)zipWithWithRxObservable:(RxObservable *)other
                     withRxFunctionsFunc2:(id<RxFunctionsFunc2>)zipFunction;

#pragma mark Protected

/*!
 @brief Creates an Observable with a Function to execute when it is subscribed to.
 <p>
 <em>Note:</em> Use <code>create(OnSubscribe)</code> to create an Observable, instead of this constructor,
 unless you specifically have a need for inheritance.
 @param f
 <code>OnSubscribe</code> to be executed when <code>subscribe(Subscriber)</code> is called
 */
- (instancetype)initWithRxObservable_OnSubscribe:(id<RxObservable_OnSubscribe>)f;

#pragma mark Package-Private

+ (id<RxSubscription>)subscribeWithRxSubscriber:(RxSubscriber *)subscriber
                               withRxObservable:(RxObservable *)observable;

@end

J2OBJC_STATIC_INIT(RxObservable)

J2OBJC_FIELD_SETTER(RxObservable, onSubscribe_, id<RxObservable_OnSubscribe>)

inline RxPluginsRxJavaObservableExecutionHook *RxObservable_get_hook();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT RxPluginsRxJavaObservableExecutionHook *RxObservable_hook;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxObservable, hook, RxPluginsRxJavaObservableExecutionHook *)

FOUNDATION_EXPORT void RxObservable_initWithRxObservable_OnSubscribe_(RxObservable *self, id<RxObservable_OnSubscribe> f);

FOUNDATION_EXPORT RxObservable *new_RxObservable_initWithRxObservable_OnSubscribe_(id<RxObservable_OnSubscribe> f) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxObservable *create_RxObservable_initWithRxObservable_OnSubscribe_(id<RxObservable_OnSubscribe> f);

FOUNDATION_EXPORT RxObservable *RxObservable_createWithRxObservable_OnSubscribe_(id<RxObservable_OnSubscribe> f);

FOUNDATION_EXPORT RxObservable *RxObservable_createWithRxObservablesSyncOnSubscribe_(RxObservablesSyncOnSubscribe *syncOnSubscribe);

FOUNDATION_EXPORT RxObservable *RxObservable_createWithRxObservablesAsyncOnSubscribe_(RxObservablesAsyncOnSubscribe *asyncOnSubscribe);

FOUNDATION_EXPORT RxObservable *RxObservable_ambWithJavaLangIterable_(id<JavaLangIterable> sources);

FOUNDATION_EXPORT RxObservable *RxObservable_ambWithRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2);

FOUNDATION_EXPORT RxObservable *RxObservable_ambWithRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3);

FOUNDATION_EXPORT RxObservable *RxObservable_ambWithRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4);

FOUNDATION_EXPORT RxObservable *RxObservable_ambWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5);

FOUNDATION_EXPORT RxObservable *RxObservable_ambWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6);

FOUNDATION_EXPORT RxObservable *RxObservable_ambWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7);

FOUNDATION_EXPORT RxObservable *RxObservable_ambWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, RxObservable *o8);

FOUNDATION_EXPORT RxObservable *RxObservable_ambWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, RxObservable *o8, RxObservable *o9);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithRxObservable_withRxObservable_withRxFunctionsFunc2_(RxObservable *o1, RxObservable *o2, id<RxFunctionsFunc2> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc3_(RxObservable *o1, RxObservable *o2, RxObservable *o3, id<RxFunctionsFunc3> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc4_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, id<RxFunctionsFunc4> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc5_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, id<RxFunctionsFunc5> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc6_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, id<RxFunctionsFunc6> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc7_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, id<RxFunctionsFunc7> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc8_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, RxObservable *o8, id<RxFunctionsFunc8> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc9_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, RxObservable *o8, RxObservable *o9, id<RxFunctionsFunc9> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithJavaUtilList_withRxFunctionsFuncN_(id<JavaUtilList> sources, id<RxFunctionsFuncN> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestWithJavaLangIterable_withRxFunctionsFuncN_(id<JavaLangIterable> sources, id<RxFunctionsFuncN> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_combineLatestDelayErrorWithJavaLangIterable_withRxFunctionsFuncN_(id<JavaLangIterable> sources, id<RxFunctionsFuncN> combineFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_concatWithRxObservable_(RxObservable *observables);

FOUNDATION_EXPORT RxObservable *RxObservable_concatWithRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2);

FOUNDATION_EXPORT RxObservable *RxObservable_concatWithRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3);

FOUNDATION_EXPORT RxObservable *RxObservable_concatWithRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4);

FOUNDATION_EXPORT RxObservable *RxObservable_concatWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5);

FOUNDATION_EXPORT RxObservable *RxObservable_concatWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6);

FOUNDATION_EXPORT RxObservable *RxObservable_concatWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6, RxObservable *t7);

FOUNDATION_EXPORT RxObservable *RxObservable_concatWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6, RxObservable *t7, RxObservable *t8);

FOUNDATION_EXPORT RxObservable *RxObservable_concatWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6, RxObservable *t7, RxObservable *t8, RxObservable *t9);

FOUNDATION_EXPORT RxObservable *RxObservable_concatDelayErrorWithRxObservable_(RxObservable *sources);

FOUNDATION_EXPORT RxObservable *RxObservable_concatDelayErrorWithJavaLangIterable_(id<JavaLangIterable> sources);

FOUNDATION_EXPORT RxObservable *RxObservable_deferWithRxFunctionsFunc0_(id<RxFunctionsFunc0> observableFactory);

FOUNDATION_EXPORT RxObservable *RxObservable_empty();

FOUNDATION_EXPORT RxObservable *RxObservable_errorWithNSException_(NSException *exception);

FOUNDATION_EXPORT RxObservable *RxObservable_fromWithJavaUtilConcurrentFuture_(id<JavaUtilConcurrentFuture> future);

FOUNDATION_EXPORT RxObservable *RxObservable_fromWithJavaUtilConcurrentFuture_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaUtilConcurrentFuture> future, jlong timeout, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT RxObservable *RxObservable_fromWithJavaUtilConcurrentFuture_withRxScheduler_(id<JavaUtilConcurrentFuture> future, RxScheduler *scheduler);

FOUNDATION_EXPORT RxObservable *RxObservable_fromWithJavaLangIterable_(id<JavaLangIterable> iterable);

FOUNDATION_EXPORT RxObservable *RxObservable_fromWithNSObjectArray_(IOSObjectArray *array);

FOUNDATION_EXPORT RxObservable *RxObservable_fromCallableWithJavaUtilConcurrentCallable_(id<JavaUtilConcurrentCallable> func);

FOUNDATION_EXPORT RxObservable *RxObservable_intervalWithLong_withJavaUtilConcurrentTimeUnit_(jlong interval, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT RxObservable *RxObservable_intervalWithLong_withJavaUtilConcurrentTimeUnit_withRxScheduler_(jlong interval, JavaUtilConcurrentTimeUnit *unit, RxScheduler *scheduler);

FOUNDATION_EXPORT RxObservable *RxObservable_intervalWithLong_withLong_withJavaUtilConcurrentTimeUnit_(jlong initialDelay, jlong period, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT RxObservable *RxObservable_intervalWithLong_withLong_withJavaUtilConcurrentTimeUnit_withRxScheduler_(jlong initialDelay, jlong period, JavaUtilConcurrentTimeUnit *unit, RxScheduler *scheduler);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_(id value);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_withId_(id t1, id t2);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_withId_withId_(id t1, id t2, id t3);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_withId_withId_withId_(id t1, id t2, id t3, id t4);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_withId_withId_withId_withId_(id t1, id t2, id t3, id t4, id t5);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_withId_withId_withId_withId_withId_(id t1, id t2, id t3, id t4, id t5, id t6);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_withId_withId_withId_withId_withId_withId_(id t1, id t2, id t3, id t4, id t5, id t6, id t7);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_withId_withId_withId_withId_withId_withId_withId_(id t1, id t2, id t3, id t4, id t5, id t6, id t7, id t8);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_withId_withId_withId_withId_withId_withId_withId_withId_(id t1, id t2, id t3, id t4, id t5, id t6, id t7, id t8, id t9);

FOUNDATION_EXPORT RxObservable *RxObservable_justWithId_withId_withId_withId_withId_withId_withId_withId_withId_withId_(id t1, id t2, id t3, id t4, id t5, id t6, id t7, id t8, id t9, id t10);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithJavaLangIterable_(id<JavaLangIterable> sequences);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithJavaLangIterable_withInt_(id<JavaLangIterable> sequences, jint maxConcurrent);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_(RxObservable *source);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_withInt_(RxObservable *source, jint maxConcurrent);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6, RxObservable *t7);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6, RxObservable *t7, RxObservable *t8);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6, RxObservable *t7, RxObservable *t8, RxObservable *t9);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservableArray_(IOSObjectArray *sequences);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeWithRxObservableArray_withInt_(IOSObjectArray *sequences, jint maxConcurrent);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_(RxObservable *source);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_withInt_(RxObservable *source, jint maxConcurrent);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithJavaLangIterable_(id<JavaLangIterable> sequences);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithJavaLangIterable_withInt_(id<JavaLangIterable> sequences, jint maxConcurrent);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6, RxObservable *t7);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6, RxObservable *t7, RxObservable *t8);

FOUNDATION_EXPORT RxObservable *RxObservable_mergeDelayErrorWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *t1, RxObservable *t2, RxObservable *t3, RxObservable *t4, RxObservable *t5, RxObservable *t6, RxObservable *t7, RxObservable *t8, RxObservable *t9);

FOUNDATION_EXPORT RxObservable *RxObservable_never();

FOUNDATION_EXPORT RxObservable *RxObservable_rangeWithInt_withInt_(jint start, jint count);

FOUNDATION_EXPORT RxObservable *RxObservable_rangeWithInt_withInt_withRxScheduler_(jint start, jint count, RxScheduler *scheduler);

FOUNDATION_EXPORT RxObservable *RxObservable_sequenceEqualWithRxObservable_withRxObservable_(RxObservable *first, RxObservable *second);

FOUNDATION_EXPORT RxObservable *RxObservable_sequenceEqualWithRxObservable_withRxObservable_withRxFunctionsFunc2_(RxObservable *first, RxObservable *second, id<RxFunctionsFunc2> equality);

FOUNDATION_EXPORT RxObservable *RxObservable_switchOnNextWithRxObservable_(RxObservable *sequenceOfSequences);

FOUNDATION_EXPORT RxObservable *RxObservable_switchOnNextDelayErrorWithRxObservable_(RxObservable *sequenceOfSequences);

FOUNDATION_EXPORT RxObservable *RxObservable_timerWithLong_withLong_withJavaUtilConcurrentTimeUnit_(jlong initialDelay, jlong period, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT RxObservable *RxObservable_timerWithLong_withLong_withJavaUtilConcurrentTimeUnit_withRxScheduler_(jlong initialDelay, jlong period, JavaUtilConcurrentTimeUnit *unit, RxScheduler *scheduler);

FOUNDATION_EXPORT RxObservable *RxObservable_timerWithLong_withJavaUtilConcurrentTimeUnit_(jlong delay, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT RxObservable *RxObservable_timerWithLong_withJavaUtilConcurrentTimeUnit_withRxScheduler_(jlong delay, JavaUtilConcurrentTimeUnit *unit, RxScheduler *scheduler);

FOUNDATION_EXPORT RxObservable *RxObservable_using__WithRxFunctionsFunc0_withRxFunctionsFunc1_withRxFunctionsAction1_(id<RxFunctionsFunc0> resourceFactory, id<RxFunctionsFunc1> observableFactory, id<RxFunctionsAction1> disposeAction);

FOUNDATION_EXPORT RxObservable *RxObservable_using__WithRxFunctionsFunc0_withRxFunctionsFunc1_withRxFunctionsAction1_withBoolean_(id<RxFunctionsFunc0> resourceFactory, id<RxFunctionsFunc1> observableFactory, id<RxFunctionsAction1> disposeAction, jboolean disposeEagerly);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithJavaLangIterable_withRxFunctionsFuncN_(id<JavaLangIterable> ws, id<RxFunctionsFuncN> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithRxObservable_withRxFunctionsFuncN_(RxObservable *ws, id<RxFunctionsFuncN> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithRxObservable_withRxObservable_withRxFunctionsFunc2_(RxObservable *o1, RxObservable *o2, id<RxFunctionsFunc2> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc3_(RxObservable *o1, RxObservable *o2, RxObservable *o3, id<RxFunctionsFunc3> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc4_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, id<RxFunctionsFunc4> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc5_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, id<RxFunctionsFunc5> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc6_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, id<RxFunctionsFunc6> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc7_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, id<RxFunctionsFunc7> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc8_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, RxObservable *o8, id<RxFunctionsFunc8> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_zipWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxFunctionsFunc9_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, RxObservable *o8, RxObservable *o9, id<RxFunctionsFunc9> zipFunction);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, RxObservable *o8);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_withRxObservable_(RxObservable *o1, RxObservable *o2, RxObservable *o3, RxObservable *o4, RxObservable *o5, RxObservable *o6, RxObservable *o7, RxObservable *o8, RxObservable *o9);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithJavaLangIterable_(id<JavaLangIterable> sources);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithJavaLangIterable_withInt_(id<JavaLangIterable> sources, jint capacityHint);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_(RxObservable *sources);

FOUNDATION_EXPORT RxObservable *RxObservable_concatEagerWithRxObservable_withInt_(RxObservable *sources, jint capacityHint);

FOUNDATION_EXPORT id<RxSubscription> RxObservable_subscribeWithRxSubscriber_withRxObservable_(RxSubscriber *subscriber, RxObservable *observable);

J2OBJC_TYPE_LITERAL_HEADER(RxObservable)

#endif

#if !defined (RxObservable_OnSubscribe_) && (INCLUDE_ALL_RxObservable || defined(INCLUDE_RxObservable_OnSubscribe))
#define RxObservable_OnSubscribe_

#define RESTRICT_RxFunctionsAction1 1
#define INCLUDE_RxFunctionsAction1 1
#include "rx/functions/Action1.h"

/*!
 @brief Invoked when Observable.subscribe is called.
 */
@protocol RxObservable_OnSubscribe < RxFunctionsAction1, JavaObject >

@end

J2OBJC_EMPTY_STATIC_INIT(RxObservable_OnSubscribe)

J2OBJC_TYPE_LITERAL_HEADER(RxObservable_OnSubscribe)

#endif

#if !defined (RxObservable_Operator_) && (INCLUDE_ALL_RxObservable || defined(INCLUDE_RxObservable_Operator))
#define RxObservable_Operator_

#define RESTRICT_RxFunctionsFunc1 1
#define INCLUDE_RxFunctionsFunc1 1
#include "rx/functions/Func1.h"

@class RxSubscriber;

/*!
 @brief Operator function for lifting into an Observable.
 */
@protocol RxObservable_Operator < RxFunctionsFunc1, JavaObject >

- (RxSubscriber *)callWithId:(RxSubscriber *)arg0;

@end

J2OBJC_EMPTY_STATIC_INIT(RxObservable_Operator)

J2OBJC_TYPE_LITERAL_HEADER(RxObservable_Operator)

#endif

#if !defined (RxObservable_OnSubscribeExtend_) && (INCLUDE_ALL_RxObservable || defined(INCLUDE_RxObservable_OnSubscribeExtend))
#define RxObservable_OnSubscribeExtend_

@class RxObservable;
@class RxSubscriber;

/*!
 @brief Transforms a OnSubscribe.call() into an Observable.subscribe() call.
 <p>Note: has to be in Observable because it calls the private subscribe() method 
 */
@interface RxObservable_OnSubscribeExtend : NSObject < RxObservable_OnSubscribe > {
 @public
  RxObservable *parent_;
}

#pragma mark Public

- (void)callWithId:(RxSubscriber *)subscriber;

#pragma mark Package-Private

- (instancetype)initWithRxObservable:(RxObservable *)parent;

@end

J2OBJC_EMPTY_STATIC_INIT(RxObservable_OnSubscribeExtend)

J2OBJC_FIELD_SETTER(RxObservable_OnSubscribeExtend, parent_, RxObservable *)

FOUNDATION_EXPORT void RxObservable_OnSubscribeExtend_initWithRxObservable_(RxObservable_OnSubscribeExtend *self, RxObservable *parent);

FOUNDATION_EXPORT RxObservable_OnSubscribeExtend *new_RxObservable_OnSubscribeExtend_initWithRxObservable_(RxObservable *parent) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxObservable_OnSubscribeExtend *create_RxObservable_OnSubscribeExtend_initWithRxObservable_(RxObservable *parent);

J2OBJC_TYPE_LITERAL_HEADER(RxObservable_OnSubscribeExtend)

#endif

#if !defined (RxObservable_Transformer_) && (INCLUDE_ALL_RxObservable || defined(INCLUDE_RxObservable_Transformer))
#define RxObservable_Transformer_

#define RESTRICT_RxFunctionsFunc1 1
#define INCLUDE_RxFunctionsFunc1 1
#include "rx/functions/Func1.h"

@class RxObservable;

/*!
 @brief Transformer function used by <code>compose</code>.
  more complete description needed
 */
@protocol RxObservable_Transformer < RxFunctionsFunc1, JavaObject >

- (RxObservable *)callWithId:(RxObservable *)arg0;

@end

J2OBJC_EMPTY_STATIC_INIT(RxObservable_Transformer)

J2OBJC_TYPE_LITERAL_HEADER(RxObservable_Transformer)

#endif

#pragma pop_macro("INCLUDE_ALL_RxObservable")
