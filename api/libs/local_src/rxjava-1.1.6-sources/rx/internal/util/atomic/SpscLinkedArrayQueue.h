//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/util/atomic/SpscLinkedArrayQueue.java
//

/*!
 @brief Copyright 2014 Netflix, Inc.
 Licensed under the Apache License, Version 2.0 (the "License"); you may not
 use this file except in compliance with the License. You may obtain a copy of
 the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 License for the specific language governing permissions and limitations under
 the License.
 */
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalUtilAtomicSpscLinkedArrayQueue")
#ifdef RESTRICT_RxInternalUtilAtomicSpscLinkedArrayQueue
#define INCLUDE_ALL_RxInternalUtilAtomicSpscLinkedArrayQueue 0
#else
#define INCLUDE_ALL_RxInternalUtilAtomicSpscLinkedArrayQueue 1
#endif
#undef RESTRICT_RxInternalUtilAtomicSpscLinkedArrayQueue

#if !defined (RxInternalUtilAtomicSpscLinkedArrayQueue_) && (INCLUDE_ALL_RxInternalUtilAtomicSpscLinkedArrayQueue || defined(INCLUDE_RxInternalUtilAtomicSpscLinkedArrayQueue))
#define RxInternalUtilAtomicSpscLinkedArrayQueue_

#define RESTRICT_JavaUtilQueue 1
#define INCLUDE_JavaUtilQueue 1
#include "java/util/Queue.h"

@class IOSObjectArray;
@class JavaUtilConcurrentAtomicAtomicLong;
@class JavaUtilConcurrentAtomicAtomicReferenceArray;
@protocol JavaUtilCollection;
@protocol JavaUtilIterator;

/*!
 @brief A single-producer single-consumer array-backed queue which can allocate new arrays in case the consumer is slower
 than the producer.
 */
@interface RxInternalUtilAtomicSpscLinkedArrayQueue : NSObject < JavaUtilQueue > {
 @public
  JavaUtilConcurrentAtomicAtomicLong *producerIndex_;
  jint producerLookAheadStep_;
  jlong producerLookAhead_;
  jint producerMask_;
  JavaUtilConcurrentAtomicAtomicReferenceArray *producerBuffer_;
  jint consumerMask_;
  JavaUtilConcurrentAtomicAtomicReferenceArray *consumerBuffer_;
  JavaUtilConcurrentAtomicAtomicLong *consumerIndex_;
}

+ (jint)MAX_LOOK_AHEAD_STEP;

#pragma mark Public

- (instancetype)initWithInt:(jint)bufferSize;

- (jboolean)addWithId:(id)e;

- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (id)element;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

/*!
 @brief 
 <p>
 This implementation is correct for single producer thread use only.
 */
- (jboolean)offerWithId:(id)e;

/*!
 @brief Offer two elements at the same time.
 <p>Don't use the regular offer() with this at all!
 @param first
 @param second
 @return always true
 */
- (jboolean)offerWithId:(id)first
                 withId:(id)second;

/*!
 @brief 
 <p>
 This implementation is correct for single consumer thread use only.
 */
- (id)peek;

/*!
 @brief 
 <p>
 This implementation is correct for single consumer thread use only.
 */
- (id)poll;

- (id)remove;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jint)size;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

#pragma mark Package-Private

@end

J2OBJC_STATIC_INIT(RxInternalUtilAtomicSpscLinkedArrayQueue)

J2OBJC_FIELD_SETTER(RxInternalUtilAtomicSpscLinkedArrayQueue, producerIndex_, JavaUtilConcurrentAtomicAtomicLong *)
J2OBJC_FIELD_SETTER(RxInternalUtilAtomicSpscLinkedArrayQueue, producerBuffer_, JavaUtilConcurrentAtomicAtomicReferenceArray *)
J2OBJC_FIELD_SETTER(RxInternalUtilAtomicSpscLinkedArrayQueue, consumerBuffer_, JavaUtilConcurrentAtomicAtomicReferenceArray *)
J2OBJC_FIELD_SETTER(RxInternalUtilAtomicSpscLinkedArrayQueue, consumerIndex_, JavaUtilConcurrentAtomicAtomicLong *)

inline jint RxInternalUtilAtomicSpscLinkedArrayQueue_get_MAX_LOOK_AHEAD_STEP();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint RxInternalUtilAtomicSpscLinkedArrayQueue_MAX_LOOK_AHEAD_STEP;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(RxInternalUtilAtomicSpscLinkedArrayQueue, MAX_LOOK_AHEAD_STEP, jint)

FOUNDATION_EXPORT void RxInternalUtilAtomicSpscLinkedArrayQueue_initWithInt_(RxInternalUtilAtomicSpscLinkedArrayQueue *self, jint bufferSize);

FOUNDATION_EXPORT RxInternalUtilAtomicSpscLinkedArrayQueue *new_RxInternalUtilAtomicSpscLinkedArrayQueue_initWithInt_(jint bufferSize) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalUtilAtomicSpscLinkedArrayQueue *create_RxInternalUtilAtomicSpscLinkedArrayQueue_initWithInt_(jint bufferSize);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalUtilAtomicSpscLinkedArrayQueue)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalUtilAtomicSpscLinkedArrayQueue")
