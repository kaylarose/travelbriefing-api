//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/util/atomic/MpscLinkedAtomicQueue.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalUtilAtomicMpscLinkedAtomicQueue")
#ifdef RESTRICT_RxInternalUtilAtomicMpscLinkedAtomicQueue
#define INCLUDE_ALL_RxInternalUtilAtomicMpscLinkedAtomicQueue 0
#else
#define INCLUDE_ALL_RxInternalUtilAtomicMpscLinkedAtomicQueue 1
#endif
#undef RESTRICT_RxInternalUtilAtomicMpscLinkedAtomicQueue

#if !defined (RxInternalUtilAtomicMpscLinkedAtomicQueue_) && (INCLUDE_ALL_RxInternalUtilAtomicMpscLinkedAtomicQueue || defined(INCLUDE_RxInternalUtilAtomicMpscLinkedAtomicQueue))
#define RxInternalUtilAtomicMpscLinkedAtomicQueue_

#define RESTRICT_RxInternalUtilAtomicBaseLinkedAtomicQueue 1
#define INCLUDE_RxInternalUtilAtomicBaseLinkedAtomicQueue 1
#include "rx/internal/util/atomic/BaseLinkedAtomicQueue.h"

/*!
 @brief This is a direct Java port of the MPSC algorithm as presented <a
 href="http://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue"> on 1024
 Cores</a> by D.
 Vyukov. The original has been adapted to Java and it's quirks with regards to memory model and
 layout:
 <ol>
 <li>Use XCHG functionality provided by AtomicReference (which is better in JDK 8+).
 </ol>
 The queue is initialized with a stub node which is set to both the producer and consumer node references. From this
 point follow the notes on offer/poll.
 @author nitsanw
 */
@interface RxInternalUtilAtomicMpscLinkedAtomicQueue : RxInternalUtilAtomicBaseLinkedAtomicQueue

#pragma mark Public

- (instancetype)init;

/*!
 @brief  <br>
 <p>
 IMPLEMENTATION NOTES:<br>
 Offer is allowed from multiple threads.
 <br>
 Offer allocates a new node and:
 <ol>
 <li>Swaps it atomically with current producer node (only one producer 'wins')
 <li>Sets the new node as the node following from the swapped producer node
 </ol>
 This works because each producer is guaranteed to 'plant' a new node and link the old node. No 2 producers can
 get the same producer node as part of XCHG guarantee.
 - seealso: java.util.Queue#offer(java.lang.Object)
 */
- (jboolean)offerWithId:(id)nextValue;

- (id)peek;

/*!
 @brief  <br>
 <p>
 IMPLEMENTATION NOTES:<br>
 Poll is allowed from a SINGLE thread.
 <br>
 Poll reads the next node from the consumerNode and:
 <ol>
 <li>If it is null, the queue is assumed empty (though it might not be).
 <li>If it is not null set it as the consumer node and return it's now evacuated value.
 </ol>
 This means the consumerNode.value is always null, which is also the starting point for the queue. Because null
 values are not allowed to be offered this is the only node with it's value set to null at any one time.
 - seealso: java.util.Queue#poll()
 */
- (id)poll;

#pragma mark Package-Private

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalUtilAtomicMpscLinkedAtomicQueue)

FOUNDATION_EXPORT void RxInternalUtilAtomicMpscLinkedAtomicQueue_init(RxInternalUtilAtomicMpscLinkedAtomicQueue *self);

FOUNDATION_EXPORT RxInternalUtilAtomicMpscLinkedAtomicQueue *new_RxInternalUtilAtomicMpscLinkedAtomicQueue_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalUtilAtomicMpscLinkedAtomicQueue *create_RxInternalUtilAtomicMpscLinkedAtomicQueue_init();

J2OBJC_TYPE_LITERAL_HEADER(RxInternalUtilAtomicMpscLinkedAtomicQueue)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalUtilAtomicMpscLinkedAtomicQueue")
