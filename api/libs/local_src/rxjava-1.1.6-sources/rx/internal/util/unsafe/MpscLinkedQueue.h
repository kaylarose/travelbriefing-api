//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/util/unsafe/MpscLinkedQueue.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalUtilUnsafeMpscLinkedQueue")
#ifdef RESTRICT_RxInternalUtilUnsafeMpscLinkedQueue
#define INCLUDE_ALL_RxInternalUtilUnsafeMpscLinkedQueue 0
#else
#define INCLUDE_ALL_RxInternalUtilUnsafeMpscLinkedQueue 1
#endif
#undef RESTRICT_RxInternalUtilUnsafeMpscLinkedQueue

#if !defined (RxInternalUtilUnsafeMpscLinkedQueue_) && (INCLUDE_ALL_RxInternalUtilUnsafeMpscLinkedQueue || defined(INCLUDE_RxInternalUtilUnsafeMpscLinkedQueue))
#define RxInternalUtilUnsafeMpscLinkedQueue_

#define RESTRICT_RxInternalUtilUnsafeBaseLinkedQueue 1
#define INCLUDE_RxInternalUtilUnsafeBaseLinkedQueue 1
#include "rx/internal/util/unsafe/BaseLinkedQueue.h"

@class RxInternalUtilAtomicLinkedQueueNode;

/*!
 @brief This is a direct Java port of the MPSC algorithm as presented <a
 href="http://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue"> on 1024
 Cores</a> by D.
 Vyukov. The original has been adapted to Java and it's quirks with regards to memory model and
 layout:
 <ol>
 <li>Use inheritance to ensure no false sharing occurs between producer/consumer node reference fields.
 <li>Use XCHG functionality to the best of the JDK ability (see differences in JDK7/8 impls).
 </ol>
 The queue is initialized with a stub node which is set to both the producer and consumer node references. From this
 point follow the notes on offer/poll.
 @author nitsanw
 */
@interface RxInternalUtilUnsafeMpscLinkedQueue : RxInternalUtilUnsafeBaseLinkedQueue

#pragma mark Public

- (instancetype)init;

/*!
 @brief  <br>
 <p>
 IMPLEMENTATION NOTES:<br>
 Offer is allowed from multiple threads.
 <br>
 Offer allocates a new node and:
 <ol>
 <li>Swaps it atomically with current producer node (only one producer 'wins')
 <li>Sets the new node as the node following from the swapped producer node
 </ol>
 This works because each producer is guaranteed to 'plant' a new node and link the old node. No 2 producers can
 get the same producer node as part of XCHG guarantee.
 - seealso: MessagePassingQueue#offer(Object)
 - seealso: java.util.Queue#offer(java.lang.Object)
 */
- (jboolean)offerWithId:(id)nextValue;

- (id)peek;

/*!
 @brief  <br>
 <p>
 IMPLEMENTATION NOTES:<br>
 Poll is allowed from a SINGLE thread.
 <br>
 Poll reads the next node from the consumerNode and:
 <ol>
 <li>If it is null, the queue is assumed empty (though it might not be).
 <li>If it is not null set it as the consumer node and return it's now evacuated value.
 </ol>
 This means the consumerNode.value is always null, which is also the starting point for the queue. Because null
 values are not allowed to be offered this is the only node with it's value set to null at any one time.
 - seealso: MessagePassingQueue#poll()
 - seealso: java.util.Queue#poll()
 */
- (id)poll;

#pragma mark Protected

- (RxInternalUtilAtomicLinkedQueueNode *)xchgProducerNodeWithRxInternalUtilAtomicLinkedQueueNode:(RxInternalUtilAtomicLinkedQueueNode *)newVal;

#pragma mark Package-Private

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalUtilUnsafeMpscLinkedQueue)

FOUNDATION_EXPORT void RxInternalUtilUnsafeMpscLinkedQueue_init(RxInternalUtilUnsafeMpscLinkedQueue *self);

FOUNDATION_EXPORT RxInternalUtilUnsafeMpscLinkedQueue *new_RxInternalUtilUnsafeMpscLinkedQueue_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalUtilUnsafeMpscLinkedQueue *create_RxInternalUtilUnsafeMpscLinkedQueue_init();

J2OBJC_TYPE_LITERAL_HEADER(RxInternalUtilUnsafeMpscLinkedQueue)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalUtilUnsafeMpscLinkedQueue")
