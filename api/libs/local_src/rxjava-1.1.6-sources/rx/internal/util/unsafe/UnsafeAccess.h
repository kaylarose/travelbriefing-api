//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/util/unsafe/UnsafeAccess.java
//

/*!
 @brief Copyright 2014 Netflix, Inc.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalUtilUnsafeUnsafeAccess")
#ifdef RESTRICT_RxInternalUtilUnsafeUnsafeAccess
#define INCLUDE_ALL_RxInternalUtilUnsafeUnsafeAccess 0
#else
#define INCLUDE_ALL_RxInternalUtilUnsafeUnsafeAccess 1
#endif
#undef RESTRICT_RxInternalUtilUnsafeUnsafeAccess

#if !defined (RxInternalUtilUnsafeUnsafeAccess_) && (INCLUDE_ALL_RxInternalUtilUnsafeUnsafeAccess || defined(INCLUDE_RxInternalUtilUnsafeUnsafeAccess))
#define RxInternalUtilUnsafeUnsafeAccess_

@class IOSClass;
@class SunMiscUnsafe;

/*!
 @brief All use of this class MUST first check that UnsafeAccess.isUnsafeAvailable() == true
 otherwise NPEs will happen in environments without "suc.misc.Unsafe" such as Android.
 <p>
 Note that you can force RxJava to not use Unsafe API by setting any value to System Property
 <code>rx.unsafe-disable</code>.
 */
@interface RxInternalUtilUnsafeUnsafeAccess : NSObject

+ (SunMiscUnsafe *)UNSAFE;

#pragma mark Public

/*!
 @brief Returns the address of the specific field on the class and
 wraps a NoSuchFieldException into an internal error.
 <p>
 One can avoid using static initializers this way and just assign
 the address directly to the target static field.
 @param clazz the target class
 @param fieldName the target field name
 @return the address (offset) of the field
 */
+ (jlong)addressOfWithIOSClass:(IOSClass *)clazz
                  withNSString:(NSString *)fieldName;

+ (jboolean)compareAndSwapIntWithId:(id)obj
                           withLong:(jlong)offset
                            withInt:(jint)expected
                            withInt:(jint)newValue;

+ (jint)getAndAddIntWithId:(id)obj
                  withLong:(jlong)offset
                   withInt:(jint)n;

+ (jint)getAndIncrementIntWithId:(id)obj
                        withLong:(jlong)offset;

+ (jint)getAndSetIntWithId:(id)obj
                  withLong:(jlong)offset
                   withInt:(jint)newValue;

+ (jboolean)isUnsafeAvailable;

@end

J2OBJC_STATIC_INIT(RxInternalUtilUnsafeUnsafeAccess)

inline SunMiscUnsafe *RxInternalUtilUnsafeUnsafeAccess_get_UNSAFE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT SunMiscUnsafe *RxInternalUtilUnsafeUnsafeAccess_UNSAFE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalUtilUnsafeUnsafeAccess, UNSAFE, SunMiscUnsafe *)

FOUNDATION_EXPORT jboolean RxInternalUtilUnsafeUnsafeAccess_isUnsafeAvailable();

FOUNDATION_EXPORT jint RxInternalUtilUnsafeUnsafeAccess_getAndIncrementIntWithId_withLong_(id obj, jlong offset);

FOUNDATION_EXPORT jint RxInternalUtilUnsafeUnsafeAccess_getAndAddIntWithId_withLong_withInt_(id obj, jlong offset, jint n);

FOUNDATION_EXPORT jint RxInternalUtilUnsafeUnsafeAccess_getAndSetIntWithId_withLong_withInt_(id obj, jlong offset, jint newValue);

FOUNDATION_EXPORT jboolean RxInternalUtilUnsafeUnsafeAccess_compareAndSwapIntWithId_withLong_withInt_withInt_(id obj, jlong offset, jint expected, jint newValue);

FOUNDATION_EXPORT jlong RxInternalUtilUnsafeUnsafeAccess_addressOfWithIOSClass_withNSString_(IOSClass *clazz, NSString *fieldName);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalUtilUnsafeUnsafeAccess)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalUtilUnsafeUnsafeAccess")
