//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/util/unsafe/ConcurrentCircularArrayQueue.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalUtilUnsafeConcurrentCircularArrayQueue")
#ifdef RESTRICT_RxInternalUtilUnsafeConcurrentCircularArrayQueue
#define INCLUDE_ALL_RxInternalUtilUnsafeConcurrentCircularArrayQueue 0
#else
#define INCLUDE_ALL_RxInternalUtilUnsafeConcurrentCircularArrayQueue 1
#endif
#undef RESTRICT_RxInternalUtilUnsafeConcurrentCircularArrayQueue
#ifdef INCLUDE_RxInternalUtilUnsafeConcurrentCircularArrayQueue
#define INCLUDE_RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad 1
#endif

#if !defined (RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad_) && (INCLUDE_ALL_RxInternalUtilUnsafeConcurrentCircularArrayQueue || defined(INCLUDE_RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad))
#define RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad_

#define RESTRICT_JavaUtilAbstractQueue 1
#define INCLUDE_JavaUtilAbstractQueue 1
#include "java/util/AbstractQueue.h"

#define RESTRICT_RxInternalUtilUnsafeMessagePassingQueue 1
#define INCLUDE_RxInternalUtilUnsafeMessagePassingQueue 1
#include "rx/internal/util/unsafe/MessagePassingQueue.h"

@interface RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad : JavaUtilAbstractQueue < RxInternalUtilUnsafeMessagePassingQueue > {
 @public
  jlong p00_, p01_, p02_, p03_, p04_, p05_, p06_, p07_;
  jlong p30_, p31_, p32_, p33_, p34_, p35_, p36_, p37_;
}

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad)

FOUNDATION_EXPORT void RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad_init(RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad *self);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad)

#endif

#if !defined (RxInternalUtilUnsafeConcurrentCircularArrayQueue_) && (INCLUDE_ALL_RxInternalUtilUnsafeConcurrentCircularArrayQueue || defined(INCLUDE_RxInternalUtilUnsafeConcurrentCircularArrayQueue))
#define RxInternalUtilUnsafeConcurrentCircularArrayQueue_

@class IOSObjectArray;
@protocol JavaUtilIterator;

/*!
 @brief A concurrent access enabling class used by circular array based queues this class exposes an offset computation
 method along with differently memory fenced load/store methods into the underlying array.
 The class is pre-padded and
 the array is padded on either side to help with False sharing prevention. It is expected that subclasses handle post
 padding.
 <p>
 Offset calculation is separate from access to enable the reuse of a give compute offset.
 <p>
 Load/Store methods using a <i>buffer</i> parameter are provided to allow the prevention of final field reload after a
 LoadLoad barrier.
 <p>
 @author nitsanw
 */
@interface RxInternalUtilUnsafeConcurrentCircularArrayQueue : RxInternalUtilUnsafeConcurrentCircularArrayQueueL0Pad {
 @public
  jlong mask_;
  IOSObjectArray *buffer_;
}

+ (jint)SPARSE_SHIFT;

+ (jint)BUFFER_PAD;

#pragma mark Public

- (instancetype)initWithInt:(jint)capacity;

- (void)clear;

- (id<JavaUtilIterator>)iterator;

#pragma mark Protected

/*!
 @param index desirable element index
 @return the offset in bytes within the array for a given index.
 */
- (jlong)calcElementOffsetWithLong:(jlong)index;

/*!
 @param index desirable element index
 @param mask
 @return the offset in bytes within the array for a given index.
 */
- (jlong)calcElementOffsetWithLong:(jlong)index
                          withLong:(jlong)mask;

/*!
 @brief A plain load (no ordering/fences) of an element from a given offset.
 @param buffer this.buffer
 @param offset computed via <code>ConcurrentCircularArrayQueue.calcElementOffset(long)</code>
 @return the element at the offset
 */
- (id)lpElementWithNSObjectArray:(IOSObjectArray *)buffer
                        withLong:(jlong)offset;

/*!
 @brief A plain load (no ordering/fences) of an element from a given offset.
 @param offset computed via <code>ConcurrentCircularArrayQueue.calcElementOffset(long)</code>
 @return the element at the offset
 */
- (id)lpElementWithLong:(jlong)offset;

/*!
 @brief A volatile load (load + LoadLoad barrier) of an element from a given offset.
 @param buffer this.buffer
 @param offset computed via <code>ConcurrentCircularArrayQueue.calcElementOffset(long)</code>
 @return the element at the offset
 */
- (id)lvElementWithNSObjectArray:(IOSObjectArray *)buffer
                        withLong:(jlong)offset;

/*!
 @brief A volatile load (load + LoadLoad barrier) of an element from a given offset.
 @param offset computed via <code>ConcurrentCircularArrayQueue.calcElementOffset(long)</code>
 @return the element at the offset
 */
- (id)lvElementWithLong:(jlong)offset;

/*!
 @brief An ordered store(store + StoreStore barrier) of an element to a given offset
 @param buffer this.buffer
 @param offset computed via <code>ConcurrentCircularArrayQueue.calcElementOffset(long)</code>
 @param e an orderly kitty
 */
- (void)soElementWithNSObjectArray:(IOSObjectArray *)buffer
                          withLong:(jlong)offset
                            withId:(id)e;

/*!
 @brief An ordered store(store + StoreStore barrier) of an element to a given offset
 @param offset computed via <code>ConcurrentCircularArrayQueue.calcElementOffset(long)</code>
 @param e an orderly kitty
 */
- (void)soElementWithLong:(jlong)offset
                   withId:(id)e;

/*!
 @brief A plain store (no ordering/fences) of an element to a given offset
 @param buffer this.buffer
 @param offset computed via <code>ConcurrentCircularArrayQueue.calcElementOffset(long)</code>
 @param e an orderly kitty
 */
- (void)spElementWithNSObjectArray:(IOSObjectArray *)buffer
                          withLong:(jlong)offset
                            withId:(id)e;

/*!
 @brief A plain store (no ordering/fences) of an element to a given offset
 @param offset computed via <code>ConcurrentCircularArrayQueue.calcElementOffset(long)</code>
 @param e a kitty
 */
- (void)spElementWithLong:(jlong)offset
                   withId:(id)e;

#pragma mark Package-Private

@end

J2OBJC_STATIC_INIT(RxInternalUtilUnsafeConcurrentCircularArrayQueue)

J2OBJC_FIELD_SETTER(RxInternalUtilUnsafeConcurrentCircularArrayQueue, buffer_, IOSObjectArray *)

inline jint RxInternalUtilUnsafeConcurrentCircularArrayQueue_get_SPARSE_SHIFT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint RxInternalUtilUnsafeConcurrentCircularArrayQueue_SPARSE_SHIFT;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(RxInternalUtilUnsafeConcurrentCircularArrayQueue, SPARSE_SHIFT, jint)

inline jint RxInternalUtilUnsafeConcurrentCircularArrayQueue_get_BUFFER_PAD();
#define RxInternalUtilUnsafeConcurrentCircularArrayQueue_BUFFER_PAD 32
J2OBJC_STATIC_FIELD_CONSTANT(RxInternalUtilUnsafeConcurrentCircularArrayQueue, BUFFER_PAD, jint)

FOUNDATION_EXPORT void RxInternalUtilUnsafeConcurrentCircularArrayQueue_initWithInt_(RxInternalUtilUnsafeConcurrentCircularArrayQueue *self, jint capacity);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalUtilUnsafeConcurrentCircularArrayQueue)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalUtilUnsafeConcurrentCircularArrayQueue")
