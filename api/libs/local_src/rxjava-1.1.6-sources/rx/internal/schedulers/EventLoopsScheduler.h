//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/schedulers/EventLoopsScheduler.java
//

/*!
 @brief Copyright 2014 Netflix, Inc.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler")
#ifdef RESTRICT_RxInternalSchedulersEventLoopsScheduler
#define INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler 0
#else
#define INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler 1
#endif
#undef RESTRICT_RxInternalSchedulersEventLoopsScheduler

#if !defined (RxInternalSchedulersEventLoopsScheduler_) && (INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler || defined(INCLUDE_RxInternalSchedulersEventLoopsScheduler))
#define RxInternalSchedulersEventLoopsScheduler_

#define RESTRICT_RxScheduler 1
#define INCLUDE_RxScheduler 1
#include "rx/Scheduler.h"

#define RESTRICT_RxInternalSchedulersSchedulerLifecycle 1
#define INCLUDE_RxInternalSchedulersSchedulerLifecycle 1
#include "rx/internal/schedulers/SchedulerLifecycle.h"

@class JavaUtilConcurrentAtomicAtomicReference;
@class RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool;
@class RxInternalSchedulersEventLoopsScheduler_PoolWorker;
@class RxScheduler_Worker;
@protocol JavaUtilConcurrentThreadFactory;
@protocol RxFunctionsAction0;
@protocol RxSubscription;

@interface RxInternalSchedulersEventLoopsScheduler : RxScheduler < RxInternalSchedulersSchedulerLifecycle > {
 @public
  id<JavaUtilConcurrentThreadFactory> threadFactory_;
  JavaUtilConcurrentAtomicAtomicReference *pool_;
}

+ (NSString *)KEY_MAX_THREADS;

+ (jint)MAX_THREADS;

+ (RxInternalSchedulersEventLoopsScheduler_PoolWorker *)SHUTDOWN_WORKER;

+ (RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *)NONE;

#pragma mark Public

/*!
 @brief Create a scheduler with pool size equal to the available processor
 count and using least-recent worker selection policy.
 @param threadFactory the factory to use with the executors
 */
- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

- (RxScheduler_Worker *)createWorker;

/*!
 @brief Schedules the action directly on one of the event loop workers
 without the additional infrastructure and checking.
 @param action the action to schedule
 @return the subscription
 */
- (id<RxSubscription>)scheduleDirectWithRxFunctionsAction0:(id<RxFunctionsAction0>)action;

- (void)shutdown;

- (void)start;

@end

J2OBJC_STATIC_INIT(RxInternalSchedulersEventLoopsScheduler)

J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler, threadFactory_, id<JavaUtilConcurrentThreadFactory>)
J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler, pool_, JavaUtilConcurrentAtomicAtomicReference *)

/*!
 @brief Key to setting the maximum number of computation scheduler threads.
 Zero or less is interpreted as use available. Capped by available.
 */
inline NSString *RxInternalSchedulersEventLoopsScheduler_get_KEY_MAX_THREADS();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *RxInternalSchedulersEventLoopsScheduler_KEY_MAX_THREADS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersEventLoopsScheduler, KEY_MAX_THREADS, NSString *)

/*!
 @brief The maximum number of computation scheduler threads.
 */
inline jint RxInternalSchedulersEventLoopsScheduler_get_MAX_THREADS();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint RxInternalSchedulersEventLoopsScheduler_MAX_THREADS;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(RxInternalSchedulersEventLoopsScheduler, MAX_THREADS, jint)

inline RxInternalSchedulersEventLoopsScheduler_PoolWorker *RxInternalSchedulersEventLoopsScheduler_get_SHUTDOWN_WORKER();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_PoolWorker *RxInternalSchedulersEventLoopsScheduler_SHUTDOWN_WORKER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersEventLoopsScheduler, SHUTDOWN_WORKER, RxInternalSchedulersEventLoopsScheduler_PoolWorker *)

/*!
 @brief This will indicate no pool is active.
 */
inline RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *RxInternalSchedulersEventLoopsScheduler_get_NONE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *RxInternalSchedulersEventLoopsScheduler_NONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersEventLoopsScheduler, NONE, RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *)

FOUNDATION_EXPORT void RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersEventLoopsScheduler *self, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler *new_RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler *create_RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalSchedulersEventLoopsScheduler)

#endif

#if !defined (RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_) && (INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler || defined(INCLUDE_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool))
#define RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_

@class IOSObjectArray;
@class RxInternalSchedulersEventLoopsScheduler_PoolWorker;
@protocol JavaUtilConcurrentThreadFactory;

@interface RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool : NSObject {
 @public
  jint cores_;
  IOSObjectArray *eventLoops_;
  jlong n_;
}

#pragma mark Public

- (RxInternalSchedulersEventLoopsScheduler_PoolWorker *)getEventLoop;

- (void)shutdown;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory
                                                withInt:(jint)maxThreads;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool)

J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool, eventLoops_, IOSObjectArray *)

FOUNDATION_EXPORT void RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *self, id<JavaUtilConcurrentThreadFactory> threadFactory, jint maxThreads);

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *new_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(id<JavaUtilConcurrentThreadFactory> threadFactory, jint maxThreads) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *create_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(id<JavaUtilConcurrentThreadFactory> threadFactory, jint maxThreads);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool)

#endif

#if !defined (RxInternalSchedulersEventLoopsScheduler_PoolWorker_) && (INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler || defined(INCLUDE_RxInternalSchedulersEventLoopsScheduler_PoolWorker))
#define RxInternalSchedulersEventLoopsScheduler_PoolWorker_

#define RESTRICT_RxInternalSchedulersNewThreadWorker 1
#define INCLUDE_RxInternalSchedulersNewThreadWorker 1
#include "rx/internal/schedulers/NewThreadWorker.h"

@protocol JavaUtilConcurrentThreadFactory;

@interface RxInternalSchedulersEventLoopsScheduler_PoolWorker : RxInternalSchedulersNewThreadWorker

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersEventLoopsScheduler_PoolWorker)

FOUNDATION_EXPORT void RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersEventLoopsScheduler_PoolWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_PoolWorker *new_RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_PoolWorker *create_RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalSchedulersEventLoopsScheduler_PoolWorker)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler")
