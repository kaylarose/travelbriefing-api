//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/schedulers/NewThreadWorker.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Boolean.h"
#include "java/lang/Exception.h"
#include "java/lang/Integer.h"
#include "java/lang/Runnable.h"
#include "java/lang/reflect/Method.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/Set.h"
#include "java/util/concurrent/ConcurrentHashMap.h"
#include "java/util/concurrent/Executors.h"
#include "java/util/concurrent/Future.h"
#include "java/util/concurrent/ScheduledExecutorService.h"
#include "java/util/concurrent/ScheduledFuture.h"
#include "java/util/concurrent/ScheduledThreadPoolExecutor.h"
#include "java/util/concurrent/ThreadFactory.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/atomic/AtomicReference.h"
#include "rx/Scheduler.h"
#include "rx/Subscription.h"
#include "rx/exceptions/Exceptions.h"
#include "rx/functions/Action0.h"
#include "rx/internal/schedulers/NewThreadWorker.h"
#include "rx/internal/schedulers/ScheduledAction.h"
#include "rx/internal/util/PlatformDependent.h"
#include "rx/internal/util/RxThreadFactory.h"
#include "rx/internal/util/SubscriptionList.h"
#include "rx/plugins/RxJavaErrorHandler.h"
#include "rx/plugins/RxJavaPlugins.h"
#include "rx/plugins/RxJavaSchedulersHook.h"
#include "rx/subscriptions/CompositeSubscription.h"
#include "rx/subscriptions/Subscriptions.h"

@interface RxInternalSchedulersNewThreadWorker () {
 @public
  id<JavaUtilConcurrentScheduledExecutorService> executor_;
  RxPluginsRxJavaSchedulersHook *schedulersHook_;
}

@end

J2OBJC_FIELD_SETTER(RxInternalSchedulersNewThreadWorker, executor_, id<JavaUtilConcurrentScheduledExecutorService>)
J2OBJC_FIELD_SETTER(RxInternalSchedulersNewThreadWorker, schedulersHook_, RxPluginsRxJavaSchedulersHook *)

/*!
 @brief The purge frequency in milliseconds.
 */
inline NSString *RxInternalSchedulersNewThreadWorker_get_FREQUENCY_KEY();
static NSString *RxInternalSchedulersNewThreadWorker_FREQUENCY_KEY = @"rx.scheduler.jdk6.purge-frequency-millis";
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, FREQUENCY_KEY, NSString *)

/*!
 @brief Force the use of purge (true/false).
 */
inline NSString *RxInternalSchedulersNewThreadWorker_get_PURGE_FORCE_KEY();
static NSString *RxInternalSchedulersNewThreadWorker_PURGE_FORCE_KEY = @"rx.scheduler.jdk6.purge-force";
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, PURGE_FORCE_KEY, NSString *)

inline NSString *RxInternalSchedulersNewThreadWorker_get_PURGE_THREAD_PREFIX();
static NSString *RxInternalSchedulersNewThreadWorker_PURGE_THREAD_PREFIX = @"RxSchedulerPurge-";
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, PURGE_THREAD_PREFIX, NSString *)

inline jboolean RxInternalSchedulersNewThreadWorker_get_SHOULD_TRY_ENABLE_CANCEL_POLICY();
static jboolean RxInternalSchedulersNewThreadWorker_SHOULD_TRY_ENABLE_CANCEL_POLICY;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(RxInternalSchedulersNewThreadWorker, SHOULD_TRY_ENABLE_CANCEL_POLICY, jboolean)

inline JavaUtilConcurrentConcurrentHashMap *RxInternalSchedulersNewThreadWorker_get_EXECUTORS();
static JavaUtilConcurrentConcurrentHashMap *RxInternalSchedulersNewThreadWorker_EXECUTORS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, EXECUTORS, JavaUtilConcurrentConcurrentHashMap *)

inline JavaUtilConcurrentAtomicAtomicReference *RxInternalSchedulersNewThreadWorker_get_PURGE();
static JavaUtilConcurrentAtomicAtomicReference *RxInternalSchedulersNewThreadWorker_PURGE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, PURGE, JavaUtilConcurrentAtomicAtomicReference *)

/*!
 @brief Improves performance of <code>tryEnableCancelPolicy(ScheduledExecutorService)</code>.
 Also, it works even for inheritance: <code>Method</code> of base class can be invoked on the instance of child class.
 */
inline id RxInternalSchedulersNewThreadWorker_get_cachedSetRemoveOnCancelPolicyMethod();
inline id RxInternalSchedulersNewThreadWorker_set_cachedSetRemoveOnCancelPolicyMethod(id value);
static volatile_id RxInternalSchedulersNewThreadWorker_cachedSetRemoveOnCancelPolicyMethod;
J2OBJC_STATIC_FIELD_OBJ_VOLATILE(RxInternalSchedulersNewThreadWorker, cachedSetRemoveOnCancelPolicyMethod, id)

/*!
 @brief Possible value of <code>cachedSetRemoveOnCancelPolicyMethod</code> which means that cancel policy is not supported.
 */
inline id RxInternalSchedulersNewThreadWorker_get_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED();
static id RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED, id)

@interface RxInternalSchedulersNewThreadWorker_$1 : NSObject < JavaLangRunnable >

- (void)run;

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersNewThreadWorker_$1)

__attribute__((unused)) static void RxInternalSchedulersNewThreadWorker_$1_init(RxInternalSchedulersNewThreadWorker_$1 *self);

__attribute__((unused)) static RxInternalSchedulersNewThreadWorker_$1 *new_RxInternalSchedulersNewThreadWorker_$1_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalSchedulersNewThreadWorker_$1 *create_RxInternalSchedulersNewThreadWorker_$1_init();

J2OBJC_TYPE_LITERAL_HEADER(RxInternalSchedulersNewThreadWorker_$1)

J2OBJC_INITIALIZED_DEFN(RxInternalSchedulersNewThreadWorker)

jint RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY;

@implementation RxInternalSchedulersNewThreadWorker

+ (jint)PURGE_FREQUENCY {
  return RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY;
}

+ (void)registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor:(JavaUtilConcurrentScheduledThreadPoolExecutor *)service {
  RxInternalSchedulersNewThreadWorker_registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor_(service);
}

+ (void)deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService>)service {
  RxInternalSchedulersNewThreadWorker_deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService_(service);
}

+ (void)purgeExecutors {
  RxInternalSchedulersNewThreadWorker_purgeExecutors();
}

+ (jboolean)tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService>)executor {
  return RxInternalSchedulersNewThreadWorker_tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService_(executor);
}

+ (JavaLangReflectMethod *)findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService>)executor {
  return RxInternalSchedulersNewThreadWorker_findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService_(executor);
}

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory {
  RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  return self;
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action {
  return [self scheduleWithRxFunctionsAction0:action withLong:0 withJavaUtilConcurrentTimeUnit:nil];
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                            withLong:(jlong)delayTime
                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if (JreLoadVolatileBoolean(&isUnsubscribed_)) {
    return RxSubscriptionsSubscriptions_unsubscribed();
  }
  return [self scheduleActualWithRxFunctionsAction0:action withLong:delayTime withJavaUtilConcurrentTimeUnit:unit];
}

- (RxInternalSchedulersScheduledAction *)scheduleActualWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                                                     withLong:(jlong)delayTime
                                               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  id<RxFunctionsAction0> decoratedAction = [((RxPluginsRxJavaSchedulersHook *) nil_chk(schedulersHook_)) onScheduleWithRxFunctionsAction0:action];
  RxInternalSchedulersScheduledAction *run = new_RxInternalSchedulersScheduledAction_initWithRxFunctionsAction0_(decoratedAction);
  id<JavaUtilConcurrentFuture> f;
  if (delayTime <= 0) {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) submitWithJavaLangRunnable:run];
  }
  else {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) scheduleWithJavaLangRunnable:run withLong:delayTime withJavaUtilConcurrentTimeUnit:unit];
  }
  [run addWithJavaUtilConcurrentFuture:f];
  return run;
}

- (RxInternalSchedulersScheduledAction *)scheduleActualWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                                                     withLong:(jlong)delayTime
                                               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                     withRxSubscriptionsCompositeSubscription:(RxSubscriptionsCompositeSubscription *)parent {
  id<RxFunctionsAction0> decoratedAction = [((RxPluginsRxJavaSchedulersHook *) nil_chk(schedulersHook_)) onScheduleWithRxFunctionsAction0:action];
  RxInternalSchedulersScheduledAction *run = new_RxInternalSchedulersScheduledAction_initWithRxFunctionsAction0_withRxSubscriptionsCompositeSubscription_(decoratedAction, parent);
  [((RxSubscriptionsCompositeSubscription *) nil_chk(parent)) addWithRxSubscription:run];
  id<JavaUtilConcurrentFuture> f;
  if (delayTime <= 0) {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) submitWithJavaLangRunnable:run];
  }
  else {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) scheduleWithJavaLangRunnable:run withLong:delayTime withJavaUtilConcurrentTimeUnit:unit];
  }
  [run addWithJavaUtilConcurrentFuture:f];
  return run;
}

- (RxInternalSchedulersScheduledAction *)scheduleActualWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                                                     withLong:(jlong)delayTime
                                               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                           withRxInternalUtilSubscriptionList:(RxInternalUtilSubscriptionList *)parent {
  id<RxFunctionsAction0> decoratedAction = [((RxPluginsRxJavaSchedulersHook *) nil_chk(schedulersHook_)) onScheduleWithRxFunctionsAction0:action];
  RxInternalSchedulersScheduledAction *run = new_RxInternalSchedulersScheduledAction_initWithRxFunctionsAction0_withRxInternalUtilSubscriptionList_(decoratedAction, parent);
  [((RxInternalUtilSubscriptionList *) nil_chk(parent)) addWithRxSubscription:run];
  id<JavaUtilConcurrentFuture> f;
  if (delayTime <= 0) {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) submitWithJavaLangRunnable:run];
  }
  else {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) scheduleWithJavaLangRunnable:run withLong:delayTime withJavaUtilConcurrentTimeUnit:unit];
  }
  [run addWithJavaUtilConcurrentFuture:f];
  return run;
}

- (void)unsubscribe {
  JreAssignVolatileBoolean(&isUnsubscribed_, true);
  (void) [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) shutdownNow];
  RxInternalSchedulersNewThreadWorker_deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService_(executor_);
}

- (jboolean)isUnsubscribed {
  return JreLoadVolatileBoolean(&isUnsubscribed_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor:", "V", 0x9, 0, 1, -1, -1, -1, -1 },
    { "deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService:", "V", 0x9, 2, 3, -1, -1, -1, -1 },
    { "purgeExecutors", "V", 0x8, -1, -1, -1, -1, -1, -1 },
    { "tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService:", "Z", 0x9, 4, 3, -1, -1, -1, -1 },
    { "findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService:", "LJavaLangReflectMethod;", 0x8, 5, 3, -1, -1, -1, -1 },
    { "initWithJavaUtilConcurrentThreadFactory:", NULL, 0x1, -1, 6, -1, -1, -1, -1 },
    { "scheduleWithRxFunctionsAction0:", "LRxSubscription;", 0x1, 7, 8, -1, -1, -1, -1 },
    { "scheduleWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:", "LRxSubscription;", 0x1, 7, 9, -1, -1, -1, -1 },
    { "scheduleActualWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:", "LRxInternalSchedulersScheduledAction;", 0x1, 10, 9, -1, -1, -1, -1 },
    { "scheduleActualWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:withRxSubscriptionsCompositeSubscription:", "LRxInternalSchedulersScheduledAction;", 0x1, 10, 11, -1, -1, -1, -1 },
    { "scheduleActualWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:withRxInternalUtilSubscriptionList:", "LRxInternalSchedulersScheduledAction;", 0x1, 10, 12, -1, -1, -1, -1 },
    { "unsubscribe", "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { "isUnsubscribed", "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "executor_", "LJavaUtilConcurrentScheduledExecutorService;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "schedulersHook_", "LRxPluginsRxJavaSchedulersHook;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "isUnsubscribed_", "Z", .constantValue.asLong = 0, 0x40, -1, -1, -1, -1 },
    { "FREQUENCY_KEY", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 13, -1, -1 },
    { "PURGE_FORCE_KEY", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 14, -1, -1 },
    { "PURGE_THREAD_PREFIX", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 15, -1, -1 },
    { "SHOULD_TRY_ENABLE_CANCEL_POLICY", "Z", .constantValue.asLong = 0, 0x1a, -1, 16, -1, -1 },
    { "PURGE_FREQUENCY", "I", .constantValue.asLong = 0, 0x19, -1, 17, -1, -1 },
    { "EXECUTORS", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x1a, -1, 18, 19, -1 },
    { "PURGE", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1a, -1, 20, 21, -1 },
    { "cachedSetRemoveOnCancelPolicyMethod", "LNSObject;", .constantValue.asLong = 0, 0x4a, -1, 22, -1, -1 },
    { "SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED", "LNSObject;", .constantValue.asLong = 0, 0x1a, -1, 23, -1, -1 },
  };
  static const void *ptrTable[] = { "registerExecutor", "LJavaUtilConcurrentScheduledThreadPoolExecutor;", "deregisterExecutor", "LJavaUtilConcurrentScheduledExecutorService;", "tryEnableCancelPolicy", "findSetRemoveOnCancelPolicyMethod", "LJavaUtilConcurrentThreadFactory;", "schedule", "LRxFunctionsAction0;", "LRxFunctionsAction0;JLJavaUtilConcurrentTimeUnit;", "scheduleActual", "LRxFunctionsAction0;JLJavaUtilConcurrentTimeUnit;LRxSubscriptionsCompositeSubscription;", "LRxFunctionsAction0;JLJavaUtilConcurrentTimeUnit;LRxInternalUtilSubscriptionList;", &RxInternalSchedulersNewThreadWorker_FREQUENCY_KEY, &RxInternalSchedulersNewThreadWorker_PURGE_FORCE_KEY, &RxInternalSchedulersNewThreadWorker_PURGE_THREAD_PREFIX, &RxInternalSchedulersNewThreadWorker_SHOULD_TRY_ENABLE_CANCEL_POLICY, &RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY, &RxInternalSchedulersNewThreadWorker_EXECUTORS, "Ljava/util/concurrent/ConcurrentHashMap<Ljava/util/concurrent/ScheduledThreadPoolExecutor;Ljava/util/concurrent/ScheduledThreadPoolExecutor;>;", &RxInternalSchedulersNewThreadWorker_PURGE, "Ljava/util/concurrent/atomic/AtomicReference<Ljava/util/concurrent/ScheduledExecutorService;>;", &RxInternalSchedulersNewThreadWorker_cachedSetRemoveOnCancelPolicyMethod, &RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED };
  static const J2ObjcClassInfo _RxInternalSchedulersNewThreadWorker = { "NewThreadWorker", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x1, 13, 12, -1, -1, -1, -1, -1 };
  return &_RxInternalSchedulersNewThreadWorker;
}

+ (void)initialize {
  if (self == [RxInternalSchedulersNewThreadWorker class]) {
    {
      RxInternalSchedulersNewThreadWorker_EXECUTORS = new_JavaUtilConcurrentConcurrentHashMap_init();
      RxInternalSchedulersNewThreadWorker_PURGE = new_JavaUtilConcurrentAtomicAtomicReference_init();
      RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY = [((JavaLangInteger *) nil_chk(JavaLangInteger_getIntegerWithNSString_withInt_(RxInternalSchedulersNewThreadWorker_FREQUENCY_KEY, 1000))) intValue];
      jboolean purgeForce = JavaLangBoolean_getBooleanWithNSString_(RxInternalSchedulersNewThreadWorker_PURGE_FORCE_KEY);
      jint androidApiVersion = RxInternalUtilPlatformDependent_getAndroidApiVersion();
      RxInternalSchedulersNewThreadWorker_SHOULD_TRY_ENABLE_CANCEL_POLICY = (!purgeForce && (androidApiVersion == RxInternalUtilPlatformDependent_ANDROID_API_VERSION_IS_NOT_ANDROID || androidApiVersion >= 21));
    }
    RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED = new_NSObject_init();
    J2OBJC_SET_INITIALIZED(RxInternalSchedulersNewThreadWorker)
  }
}

@end

void RxInternalSchedulersNewThreadWorker_registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor_(JavaUtilConcurrentScheduledThreadPoolExecutor *service) {
  RxInternalSchedulersNewThreadWorker_initialize();
  do {
    id<JavaUtilConcurrentScheduledExecutorService> exec = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(RxInternalSchedulersNewThreadWorker_PURGE)) get];
    if (exec != nil) {
      break;
    }
    exec = JavaUtilConcurrentExecutors_newScheduledThreadPoolWithInt_withJavaUtilConcurrentThreadFactory_(1, new_RxInternalUtilRxThreadFactory_initWithNSString_(RxInternalSchedulersNewThreadWorker_PURGE_THREAD_PREFIX));
    if ([RxInternalSchedulersNewThreadWorker_PURGE compareAndSetWithId:nil withId:exec]) {
      (void) [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(exec)) scheduleAtFixedRateWithJavaLangRunnable:new_RxInternalSchedulersNewThreadWorker_$1_init() withLong:RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY withLong:RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, MILLISECONDS)];
      break;
    }
    else {
      (void) [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(exec)) shutdownNow];
    }
  }
  while (true);
  (void) [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(RxInternalSchedulersNewThreadWorker_EXECUTORS)) putIfAbsentWithId:service withId:service];
}

void RxInternalSchedulersNewThreadWorker_deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService_(id<JavaUtilConcurrentScheduledExecutorService> service) {
  RxInternalSchedulersNewThreadWorker_initialize();
  (void) [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(RxInternalSchedulersNewThreadWorker_EXECUTORS)) removeWithId:service];
}

void RxInternalSchedulersNewThreadWorker_purgeExecutors() {
  RxInternalSchedulersNewThreadWorker_initialize();
  @try {
    id<JavaUtilIterator> it = [((id<JavaUtilSet>) nil_chk([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(RxInternalSchedulersNewThreadWorker_EXECUTORS)) keySet])) iterator];
    while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
      JavaUtilConcurrentScheduledThreadPoolExecutor *exec = [it next];
      if (![((JavaUtilConcurrentScheduledThreadPoolExecutor *) nil_chk(exec)) isShutdown]) {
        [exec purge];
      }
      else {
        [it remove];
      }
    }
  }
  @catch (NSException *t) {
    RxExceptionsExceptions_throwIfFatalWithNSException_(t);
    [((RxPluginsRxJavaErrorHandler *) nil_chk([((RxPluginsRxJavaPlugins *) nil_chk(RxPluginsRxJavaPlugins_getInstance())) getErrorHandler])) handleErrorWithNSException:t];
  }
}

jboolean RxInternalSchedulersNewThreadWorker_tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService_(id<JavaUtilConcurrentScheduledExecutorService> executor) {
  RxInternalSchedulersNewThreadWorker_initialize();
  if (RxInternalSchedulersNewThreadWorker_SHOULD_TRY_ENABLE_CANCEL_POLICY) {
    jboolean isInstanceOfScheduledThreadPoolExecutor = [executor isKindOfClass:[JavaUtilConcurrentScheduledThreadPoolExecutor class]];
    JavaLangReflectMethod *methodToCall;
    if (isInstanceOfScheduledThreadPoolExecutor) {
      id localSetRemoveOnCancelPolicyMethod = JreLoadVolatileId(&RxInternalSchedulersNewThreadWorker_cachedSetRemoveOnCancelPolicyMethod);
      if (localSetRemoveOnCancelPolicyMethod == RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED) {
        return false;
      }
      if (localSetRemoveOnCancelPolicyMethod == nil) {
        JavaLangReflectMethod *method = RxInternalSchedulersNewThreadWorker_findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService_(executor);
        (void) JreVolatileStrongAssign(&RxInternalSchedulersNewThreadWorker_cachedSetRemoveOnCancelPolicyMethod, method != nil ? method : RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED);
        methodToCall = method;
      }
      else {
        methodToCall = (JavaLangReflectMethod *) cast_chk(localSetRemoveOnCancelPolicyMethod, [JavaLangReflectMethod class]);
      }
    }
    else {
      methodToCall = RxInternalSchedulersNewThreadWorker_findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService_(executor);
    }
    if (methodToCall != nil) {
      @try {
        (void) [methodToCall invokeWithId:executor withNSObjectArray:[IOSObjectArray newArrayWithObjects:(id[]){ JavaLangBoolean_valueOfWithBoolean_(true) } count:1 type:NSObject_class_()]];
        return true;
      }
      @catch (JavaLangException *e) {
        [((RxPluginsRxJavaErrorHandler *) nil_chk([((RxPluginsRxJavaPlugins *) nil_chk(RxPluginsRxJavaPlugins_getInstance())) getErrorHandler])) handleErrorWithNSException:e];
      }
    }
  }
  return false;
}

JavaLangReflectMethod *RxInternalSchedulersNewThreadWorker_findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService_(id<JavaUtilConcurrentScheduledExecutorService> executor) {
  RxInternalSchedulersNewThreadWorker_initialize();
  {
    IOSObjectArray *a__ = [[((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor)) getClass] getMethods];
    JavaLangReflectMethod * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    JavaLangReflectMethod * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      JavaLangReflectMethod *method = *b__++;
      if ([((NSString *) nil_chk([((JavaLangReflectMethod *) nil_chk(method)) getName])) isEqual:@"setRemoveOnCancelPolicy"]) {
        IOSObjectArray *parameterTypes = [method getParameterTypes];
        if (((IOSObjectArray *) nil_chk(parameterTypes))->size_ == 1 && IOSObjectArray_Get(parameterTypes, 0) == JreLoadStatic(JavaLangBoolean, TYPE)) {
          return method;
        }
      }
    }
  }
  return nil;
}

void RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersNewThreadWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  RxScheduler_Worker_init(self);
  id<JavaUtilConcurrentScheduledExecutorService> exec = JavaUtilConcurrentExecutors_newScheduledThreadPoolWithInt_withJavaUtilConcurrentThreadFactory_(1, threadFactory);
  jboolean cancelSupported = RxInternalSchedulersNewThreadWorker_tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService_(exec);
  if (!cancelSupported && [exec isKindOfClass:[JavaUtilConcurrentScheduledThreadPoolExecutor class]]) {
    RxInternalSchedulersNewThreadWorker_registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor_((JavaUtilConcurrentScheduledThreadPoolExecutor *) cast_chk(exec, [JavaUtilConcurrentScheduledThreadPoolExecutor class]));
  }
  self->schedulersHook_ = [((RxPluginsRxJavaPlugins *) nil_chk(RxPluginsRxJavaPlugins_getInstance())) getSchedulersHook];
  self->executor_ = exec;
}

RxInternalSchedulersNewThreadWorker *new_RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersNewThreadWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

RxInternalSchedulersNewThreadWorker *create_RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersNewThreadWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersNewThreadWorker)

@implementation RxInternalSchedulersNewThreadWorker_$1

- (void)run {
  RxInternalSchedulersNewThreadWorker_purgeExecutors();
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxInternalSchedulersNewThreadWorker_$1_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "run", "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { "init", NULL, 0x0, -1, -1, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxInternalSchedulersNewThreadWorker;", "registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor:" };
  static const J2ObjcClassInfo _RxInternalSchedulersNewThreadWorker_$1 = { "", "rx.internal.schedulers", ptrTable, methods, NULL, 7, 0x8008, 2, 0, 0, -1, 1, -1, -1 };
  return &_RxInternalSchedulersNewThreadWorker_$1;
}

@end

void RxInternalSchedulersNewThreadWorker_$1_init(RxInternalSchedulersNewThreadWorker_$1 *self) {
  NSObject_init(self);
}

RxInternalSchedulersNewThreadWorker_$1 *new_RxInternalSchedulersNewThreadWorker_$1_init() {
  J2OBJC_NEW_IMPL(RxInternalSchedulersNewThreadWorker_$1, init)
}

RxInternalSchedulersNewThreadWorker_$1 *create_RxInternalSchedulersNewThreadWorker_$1_init() {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersNewThreadWorker_$1, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersNewThreadWorker_$1)
