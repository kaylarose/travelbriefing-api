//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/schedulers/SleepingAction.java
//

#include "J2ObjC_source.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Thread.h"
#include "rx/Scheduler.h"
#include "rx/functions/Action0.h"
#include "rx/internal/schedulers/SleepingAction.h"

@interface RxInternalSchedulersSleepingAction () {
 @public
  id<RxFunctionsAction0> underlying_;
  RxScheduler_Worker *innerScheduler_;
  jlong execTime_;
}

@end

J2OBJC_FIELD_SETTER(RxInternalSchedulersSleepingAction, underlying_, id<RxFunctionsAction0>)
J2OBJC_FIELD_SETTER(RxInternalSchedulersSleepingAction, innerScheduler_, RxScheduler_Worker *)

@implementation RxInternalSchedulersSleepingAction

- (instancetype)initWithRxFunctionsAction0:(id<RxFunctionsAction0>)underlying
                    withRxScheduler_Worker:(RxScheduler_Worker *)scheduler
                                  withLong:(jlong)execTime {
  RxInternalSchedulersSleepingAction_initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_(self, underlying, scheduler, execTime);
  return self;
}

- (void)call {
  if ([((RxScheduler_Worker *) nil_chk(innerScheduler_)) isUnsubscribed]) {
    return;
  }
  jlong delay = execTime_ - [innerScheduler_ now];
  if (delay > 0) {
    @try {
      JavaLangThread_sleepWithLong_(delay);
    }
    @catch (JavaLangInterruptedException *e) {
      [((JavaLangThread *) nil_chk(JavaLangThread_currentThread())) interrupt];
      @throw new_JavaLangRuntimeException_initWithNSException_(e);
    }
  }
  if ([innerScheduler_ isUnsubscribed]) {
    return;
  }
  [((id<RxFunctionsAction0>) nil_chk(underlying_)) call];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithRxFunctionsAction0:withRxScheduler_Worker:withLong:", NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { "call", "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "underlying_", "LRxFunctionsAction0;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "innerScheduler_", "LRxScheduler_Worker;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "execTime_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxFunctionsAction0;LRxScheduler_Worker;J" };
  static const J2ObjcClassInfo _RxInternalSchedulersSleepingAction = { "SleepingAction", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x0, 2, 3, -1, -1, -1, -1, -1 };
  return &_RxInternalSchedulersSleepingAction;
}

@end

void RxInternalSchedulersSleepingAction_initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_(RxInternalSchedulersSleepingAction *self, id<RxFunctionsAction0> underlying, RxScheduler_Worker *scheduler, jlong execTime) {
  NSObject_init(self);
  self->underlying_ = underlying;
  self->innerScheduler_ = scheduler;
  self->execTime_ = execTime;
}

RxInternalSchedulersSleepingAction *new_RxInternalSchedulersSleepingAction_initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_(id<RxFunctionsAction0> underlying, RxScheduler_Worker *scheduler, jlong execTime) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersSleepingAction, initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_, underlying, scheduler, execTime)
}

RxInternalSchedulersSleepingAction *create_RxInternalSchedulersSleepingAction_initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_(id<RxFunctionsAction0> underlying, RxScheduler_Worker *scheduler, jlong execTime) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersSleepingAction, initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_, underlying, scheduler, execTime)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersSleepingAction)
