//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/operators/OperatorPublish.java
//

/*!
 @brief Copyright 2014 Netflix, Inc.
 Licensed under the Apache License, Version 2.0 (the "License"); you may not
 use this file except in compliance with the License. You may obtain a copy of
 the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 License for the specific language governing permissions and limitations under
 the License.
 */
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalOperatorsOperatorPublish")
#ifdef RESTRICT_RxInternalOperatorsOperatorPublish
#define INCLUDE_ALL_RxInternalOperatorsOperatorPublish 0
#else
#define INCLUDE_ALL_RxInternalOperatorsOperatorPublish 1
#endif
#undef RESTRICT_RxInternalOperatorsOperatorPublish

#if !defined (RxInternalOperatorsOperatorPublish_) && (INCLUDE_ALL_RxInternalOperatorsOperatorPublish || defined(INCLUDE_RxInternalOperatorsOperatorPublish))
#define RxInternalOperatorsOperatorPublish_

#define RESTRICT_RxObservablesConnectableObservable 1
#define INCLUDE_RxObservablesConnectableObservable 1
#include "rx/observables/ConnectableObservable.h"

@class JavaUtilConcurrentAtomicAtomicReference;
@class RxObservable;
@protocol RxFunctionsAction1;
@protocol RxFunctionsFunc1;

/*!
 @brief A connectable observable which shares an underlying source and dispatches source values to subscribers in a backpressure-aware
 manner.
 */
@interface RxInternalOperatorsOperatorPublish : RxObservablesConnectableObservable {
 @public
  /*!
   @brief The source observable.
   */
  RxObservable *source_;
  /*!
   @brief Holds the current subscriber that is, will be or just was subscribed to the source observable.
   */
  JavaUtilConcurrentAtomicAtomicReference *current_;
}

#pragma mark Public

- (void)connectWithRxFunctionsAction1:(id<RxFunctionsAction1>)connection;

/*!
 @brief Creates a OperatorPublish instance to publish values of the given source observable.
 @param source the source observable
 @return the connectable observable
 */
+ (RxObservablesConnectableObservable *)createWithRxObservable:(RxObservable *)source;

+ (RxObservable *)createWithRxObservable:(RxObservable *)source
                    withRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector;

+ (RxObservable *)createWithRxObservable:(RxObservable *)source
                    withRxFunctionsFunc1:(id<RxFunctionsFunc1>)selector
                             withBoolean:(jboolean)delayError;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalOperatorsOperatorPublish)

J2OBJC_FIELD_SETTER(RxInternalOperatorsOperatorPublish, source_, RxObservable *)
J2OBJC_FIELD_SETTER(RxInternalOperatorsOperatorPublish, current_, JavaUtilConcurrentAtomicAtomicReference *)

FOUNDATION_EXPORT RxObservablesConnectableObservable *RxInternalOperatorsOperatorPublish_createWithRxObservable_(RxObservable *source);

FOUNDATION_EXPORT RxObservable *RxInternalOperatorsOperatorPublish_createWithRxObservable_withRxFunctionsFunc1_(RxObservable *source, id<RxFunctionsFunc1> selector);

FOUNDATION_EXPORT RxObservable *RxInternalOperatorsOperatorPublish_createWithRxObservable_withRxFunctionsFunc1_withBoolean_(RxObservable *source, id<RxFunctionsFunc1> selector, jboolean delayError);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalOperatorsOperatorPublish)

#endif

#if !defined (RxInternalOperatorsOperatorPublish_PublishSubscriber_) && (INCLUDE_ALL_RxInternalOperatorsOperatorPublish || defined(INCLUDE_RxInternalOperatorsOperatorPublish_PublishSubscriber))
#define RxInternalOperatorsOperatorPublish_PublishSubscriber_

#define RESTRICT_RxSubscriber 1
#define INCLUDE_RxSubscriber 1
#include "rx/Subscriber.h"

#define RESTRICT_RxSubscription 1
#define INCLUDE_RxSubscription 1
#include "rx/Subscription.h"

@class IOSObjectArray;
@class JavaUtilConcurrentAtomicAtomicBoolean;
@class JavaUtilConcurrentAtomicAtomicReference;
@class RxInternalOperatorsNotificationLite;
@class RxInternalOperatorsOperatorPublish_InnerProducer;
@protocol JavaUtilQueue;

@interface RxInternalOperatorsOperatorPublish_PublishSubscriber : RxSubscriber < RxSubscription > {
 @public
  /*!
   @brief Holds notifications from upstream.
   */
  id<JavaUtilQueue> queue_;
  /*!
   @brief The notification-lite factory.
   */
  RxInternalOperatorsNotificationLite *nl_;
  /*!
   @brief Holds onto the current connected PublishSubscriber.
   */
  JavaUtilConcurrentAtomicAtomicReference *current_;
  /*!
   @brief Contains either an onCompleted or an onError token from upstream.
   */
  volatile_id terminalEvent_;
  /*!
   @brief Tracks the subscribed producers.
   */
  JavaUtilConcurrentAtomicAtomicReference *producers_;
  /*!
   @brief Atomically changed from false to true by connect to make sure the 
 connection is only performed by one thread.
   */
  JavaUtilConcurrentAtomicAtomicBoolean *shouldConnect_;
  /*!
   @brief Guarded by this.
   */
  jboolean emitting_;
  /*!
   @brief Guarded by this.
   */
  jboolean missed_;
}

+ (IOSObjectArray *)EMPTY;

+ (IOSObjectArray *)TERMINATED;

#pragma mark Public

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)current;

- (void)onCompleted;

- (void)onErrorWithNSException:(NSException *)e;

- (void)onNextWithId:(id)t;

- (void)onStart;

#pragma mark Package-Private

/*!
 @brief Atomically try adding a new InnerProducer to this Subscriber or return false if this
 Subscriber was terminated.
 @param producer the producer to add
 @return true if succeeded, false otherwise
 */
- (jboolean)addWithRxInternalOperatorsOperatorPublish_InnerProducer:(RxInternalOperatorsOperatorPublish_InnerProducer *)producer;

/*!
 @brief Perform termination actions in case the source has terminated in some way and
 the queue has also become empty.
 @param term the terminal event (a NotificationLite.error or completed)
 @param empty set to true if the queue is empty
 @return true if there is indeed a terminal condition
 */
- (jboolean)checkTerminatedWithId:(id)term
                      withBoolean:(jboolean)empty;

/*!
 @brief The common serialization point of events arriving from upstream and child-subscribers
 requesting more.
 */
- (void)dispatch;

/*!
 @brief Should be called after the constructor finished to setup nulling-out the current reference.
 */
- (void)init__ OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Atomically removes the given producer from the producers array.
 @param producer the producer to remove
 */
- (void)removeWithRxInternalOperatorsOperatorPublish_InnerProducer:(RxInternalOperatorsOperatorPublish_InnerProducer *)producer;

@end

J2OBJC_STATIC_INIT(RxInternalOperatorsOperatorPublish_PublishSubscriber)

J2OBJC_FIELD_SETTER(RxInternalOperatorsOperatorPublish_PublishSubscriber, queue_, id<JavaUtilQueue>)
J2OBJC_FIELD_SETTER(RxInternalOperatorsOperatorPublish_PublishSubscriber, nl_, RxInternalOperatorsNotificationLite *)
J2OBJC_FIELD_SETTER(RxInternalOperatorsOperatorPublish_PublishSubscriber, current_, JavaUtilConcurrentAtomicAtomicReference *)
J2OBJC_VOLATILE_FIELD_SETTER(RxInternalOperatorsOperatorPublish_PublishSubscriber, terminalEvent_, id)
J2OBJC_FIELD_SETTER(RxInternalOperatorsOperatorPublish_PublishSubscriber, producers_, JavaUtilConcurrentAtomicAtomicReference *)
J2OBJC_FIELD_SETTER(RxInternalOperatorsOperatorPublish_PublishSubscriber, shouldConnect_, JavaUtilConcurrentAtomicAtomicBoolean *)

/*!
 @brief Indicates an empty array of inner producers.
 */
inline IOSObjectArray *RxInternalOperatorsOperatorPublish_PublishSubscriber_get_EMPTY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *RxInternalOperatorsOperatorPublish_PublishSubscriber_EMPTY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalOperatorsOperatorPublish_PublishSubscriber, EMPTY, IOSObjectArray *)

/*!
 @brief Indicates a terminated PublishSubscriber.
 */
inline IOSObjectArray *RxInternalOperatorsOperatorPublish_PublishSubscriber_get_TERMINATED();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *RxInternalOperatorsOperatorPublish_PublishSubscriber_TERMINATED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalOperatorsOperatorPublish_PublishSubscriber, TERMINATED, IOSObjectArray *)

FOUNDATION_EXPORT void RxInternalOperatorsOperatorPublish_PublishSubscriber_initWithJavaUtilConcurrentAtomicAtomicReference_(RxInternalOperatorsOperatorPublish_PublishSubscriber *self, JavaUtilConcurrentAtomicAtomicReference *current);

FOUNDATION_EXPORT RxInternalOperatorsOperatorPublish_PublishSubscriber *new_RxInternalOperatorsOperatorPublish_PublishSubscriber_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *current) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalOperatorsOperatorPublish_PublishSubscriber *create_RxInternalOperatorsOperatorPublish_PublishSubscriber_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *current);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalOperatorsOperatorPublish_PublishSubscriber)

#endif

#if !defined (RxInternalOperatorsOperatorPublish_InnerProducer_) && (INCLUDE_ALL_RxInternalOperatorsOperatorPublish || defined(INCLUDE_RxInternalOperatorsOperatorPublish_InnerProducer))
#define RxInternalOperatorsOperatorPublish_InnerProducer_

#define RESTRICT_JavaUtilConcurrentAtomicAtomicLong 1
#define INCLUDE_JavaUtilConcurrentAtomicAtomicLong 1
#include "java/util/concurrent/atomic/AtomicLong.h"

#define RESTRICT_RxProducer 1
#define INCLUDE_RxProducer 1
#include "rx/Producer.h"

#define RESTRICT_RxSubscription 1
#define INCLUDE_RxSubscription 1
#include "rx/Subscription.h"

@class RxInternalOperatorsOperatorPublish_PublishSubscriber;
@class RxSubscriber;

/*!
 @brief A Producer and Subscription that manages the request and unsubscription state of a
 child subscriber in thread-safe manner.
 We use AtomicLong as a base class to save on extra allocation of an AtomicLong and also
 save the overhead of the AtomicIntegerFieldUpdater.
 */
@interface RxInternalOperatorsOperatorPublish_InnerProducer : JavaUtilConcurrentAtomicAtomicLong < RxProducer, RxSubscription > {
 @public
  /*!
   @brief The parent subscriber-to-source used to allow removing the child in case of
 child unsubscription.
   */
  RxInternalOperatorsOperatorPublish_PublishSubscriber *parent_;
  /*!
   @brief The actual child subscriber.
   */
  RxSubscriber *child_;
}

+ (jlong)UNSUBSCRIBED;

+ (jlong)NOT_REQUESTED;

#pragma mark Public

- (instancetype)initWithRxInternalOperatorsOperatorPublish_PublishSubscriber:(RxInternalOperatorsOperatorPublish_PublishSubscriber *)parent
                                                            withRxSubscriber:(RxSubscriber *)child;

- (jboolean)isUnsubscribed;

/*!
 @brief Indicate that values have been emitted to this child subscriber by the dispatch() method.
 @param n the number of items emitted
 @return the updated request value (may indicate how much can be produced or a terminal state)
 */
- (jlong)producedWithLong:(jlong)n;

- (void)requestWithLong:(jlong)n;

- (void)unsubscribe;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalOperatorsOperatorPublish_InnerProducer)

J2OBJC_FIELD_SETTER(RxInternalOperatorsOperatorPublish_InnerProducer, parent_, RxInternalOperatorsOperatorPublish_PublishSubscriber *)
J2OBJC_FIELD_SETTER(RxInternalOperatorsOperatorPublish_InnerProducer, child_, RxSubscriber *)

/*!
 @brief Indicates this child has been unsubscribed: the state is swapped in atomically and
 will prevent the dispatch() to emit (too many) values to a terminated child subscriber.
 */
inline jlong RxInternalOperatorsOperatorPublish_InnerProducer_get_UNSUBSCRIBED();
#define RxInternalOperatorsOperatorPublish_InnerProducer_UNSUBSCRIBED ((jlong) 0x8000000000000000LL)
J2OBJC_STATIC_FIELD_CONSTANT(RxInternalOperatorsOperatorPublish_InnerProducer, UNSUBSCRIBED, jlong)

/*!
 @brief Indicates this child has not yet requested any value.
 We pretend we don't
 see such child subscribers in dispatch() to allow other child subscribers who
 have requested to make progress. In a concurrent subscription scenario,
 one can't be sure when a subscription happens exactly so this virtual shift
 should not cause any problems.
 */
inline jlong RxInternalOperatorsOperatorPublish_InnerProducer_get_NOT_REQUESTED();
#define RxInternalOperatorsOperatorPublish_InnerProducer_NOT_REQUESTED -4611686018427387904LL
J2OBJC_STATIC_FIELD_CONSTANT(RxInternalOperatorsOperatorPublish_InnerProducer, NOT_REQUESTED, jlong)

FOUNDATION_EXPORT void RxInternalOperatorsOperatorPublish_InnerProducer_initWithRxInternalOperatorsOperatorPublish_PublishSubscriber_withRxSubscriber_(RxInternalOperatorsOperatorPublish_InnerProducer *self, RxInternalOperatorsOperatorPublish_PublishSubscriber *parent, RxSubscriber *child);

FOUNDATION_EXPORT RxInternalOperatorsOperatorPublish_InnerProducer *new_RxInternalOperatorsOperatorPublish_InnerProducer_initWithRxInternalOperatorsOperatorPublish_PublishSubscriber_withRxSubscriber_(RxInternalOperatorsOperatorPublish_PublishSubscriber *parent, RxSubscriber *child) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalOperatorsOperatorPublish_InnerProducer *create_RxInternalOperatorsOperatorPublish_InnerProducer_initWithRxInternalOperatorsOperatorPublish_PublishSubscriber_withRxSubscriber_(RxInternalOperatorsOperatorPublish_PublishSubscriber *parent, RxSubscriber *child);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalOperatorsOperatorPublish_InnerProducer)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalOperatorsOperatorPublish")
