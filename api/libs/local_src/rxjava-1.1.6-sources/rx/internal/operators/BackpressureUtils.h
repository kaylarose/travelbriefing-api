//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/internal/operators/BackpressureUtils.java
//

/*!
 @brief Copyright 2015 Netflix, Inc.
 Licensed under the Apache License, Version 2.0 (the "License"); you may not
 use this file except in compliance with the License. You may obtain a copy of
 the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 License for the specific language governing permissions and limitations under
 the License.
 */
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalOperatorsBackpressureUtils")
#ifdef RESTRICT_RxInternalOperatorsBackpressureUtils
#define INCLUDE_ALL_RxInternalOperatorsBackpressureUtils 0
#else
#define INCLUDE_ALL_RxInternalOperatorsBackpressureUtils 1
#endif
#undef RESTRICT_RxInternalOperatorsBackpressureUtils

#if !defined (RxInternalOperatorsBackpressureUtils_) && (INCLUDE_ALL_RxInternalOperatorsBackpressureUtils || defined(INCLUDE_RxInternalOperatorsBackpressureUtils))
#define RxInternalOperatorsBackpressureUtils_

@class JavaUtilConcurrentAtomicAtomicLong;
@class JavaUtilConcurrentAtomicAtomicLongFieldUpdater;
@class RxSubscriber;
@protocol JavaUtilQueue;
@protocol RxFunctionsFunc1;

/*!
 @brief Utility functions for use with backpressure.
 */
@interface RxInternalOperatorsBackpressureUtils : NSObject

+ (jlong)COMPLETED_MASK;

+ (jlong)REQUESTED_MASK;

#pragma mark Public

/*!
 @brief Adds two positive longs and caps the result at Long.MAX_VALUE.
 @param a the first value
 @param b the second value
 @return the capped sum of a and b
 */
+ (jlong)addCapWithLong:(jlong)a
               withLong:(jlong)b;

/*!
 @brief Adds <code>n</code> to <code>requested</code> and returns the value prior to addition once the
 addition is successful (uses CAS semantics).
 If overflows then sets
 <code>requested</code> field to <code>Long.MAX_VALUE</code>.
 @param requested
 atomic long that should be updated
 @param n
 the number of requests to add to the requested count
 @return requested value just prior to successful addition
 */
+ (jlong)getAndAddRequestWithJavaUtilConcurrentAtomicAtomicLong:(JavaUtilConcurrentAtomicAtomicLong *)requested
                                                       withLong:(jlong)n;

/*!
 @brief Adds <code>n</code> to <code>requested</code> field and returns the value prior to
 addition once the addition is successful (uses CAS semantics).
 If
 overflows then sets <code>requested</code> field to <code>Long.MAX_VALUE</code>.
 @param requested
 atomic field updater for a request count
 @param object
 contains the field updated by the updater
 @param n
 the number of requests to add to the requested count
 @return requested value just prior to successful addition
 */
+ (jlong)getAndAddRequestWithJavaUtilConcurrentAtomicAtomicLongFieldUpdater:(JavaUtilConcurrentAtomicAtomicLongFieldUpdater *)requested
                                                                     withId:(id)object
                                                                   withLong:(jlong)n;

/*!
 @brief Multiplies two positive longs and caps the result at Long.MAX_VALUE.
 @param a the first value
 @param b the second value
 @return the capped product of a and b
 */
+ (jlong)multiplyCapWithLong:(jlong)a
                    withLong:(jlong)b;

/*!
 @brief Signals the completion of the main sequence and switches to post-completion replay mode
 and allows exit transformation on the queued values.
 <p>
 Don't modify the queue after calling this method!
 <p>
 Post-completion backpressure handles the case when a source produces values based on
 requests when it is active but more values are available even after its completion.
 In this case, the onCompleted() can't just emit the contents of the queue but has to
 coordinate with the requested amounts. This requires two distinct modes: active and
 completed. In active mode, requests flow through and the queue is not accessed but
 in completed mode, requests no-longer reach the upstream but help in draining the queue.
 <p>
 The algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since
 request amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't
 allowed.
 @param requested the holder of current requested amount
 @param queue the queue holding values to be emitted after completion
 @param actual the subscriber to receive the values
 @param exitTransform the transformation to apply on the dequeued value to get the value to be emitted
 */
+ (void)postCompleteDoneWithJavaUtilConcurrentAtomicAtomicLong:(JavaUtilConcurrentAtomicAtomicLong *)requested
                                             withJavaUtilQueue:(id<JavaUtilQueue>)queue
                                              withRxSubscriber:(RxSubscriber *)actual
                                          withRxFunctionsFunc1:(id<RxFunctionsFunc1>)exitTransform;

/*!
 @brief Signals the completion of the main sequence and switches to post-completion replay mode.
 <p>
 Don't modify the queue after calling this method!
 <p>
 Post-completion backpressure handles the case when a source produces values based on
 requests when it is active but more values are available even after its completion.
 In this case, the onCompleted() can't just emit the contents of the queue but has to
 coordinate with the requested amounts. This requires two distinct modes: active and
 completed. In active mode, requests flow through and the queue is not accessed but
 in completed mode, requests no-longer reach the upstream but help in draining the queue.
 <p>
 The algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since
 request amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't
 allowed.
 @param requested the holder of current requested amount
 @param queue the queue holding values to be emitted after completion
 @param actual the subscriber to receive the values
 */
+ (void)postCompleteDoneWithJavaUtilConcurrentAtomicAtomicLong:(JavaUtilConcurrentAtomicAtomicLong *)requested
                                             withJavaUtilQueue:(id<JavaUtilQueue>)queue
                                              withRxSubscriber:(RxSubscriber *)actual;

/*!
 @brief Accumulates requests (validated) and handles the completed mode draining of the queue based on the requests
 and allows exit transformation on the queued values.
 <p>
 Post-completion backpressure handles the case when a source produces values based on
 requests when it is active but more values are available even after its completion.
 In this case, the onCompleted() can't just emit the contents of the queue but has to
 coordinate with the requested amounts. This requires two distinct modes: active and
 completed. In active mode, requests flow through and the queue is not accessed but
 in completed mode, requests no-longer reach the upstream but help in draining the queue.
 @param requested the holder of current requested amount
 @param n the value requested;
 @param queue the queue holding values to be emitted after completion
 @param actual the subscriber to receive the values
 @param exitTransform the transformation to apply on the dequeued value to get the value to be emitted
 @return true if in the active mode and the request amount of n can be relayed to upstream, false if
 in the post-completed mode and the queue is draining.
 */
+ (jboolean)postCompleteRequestWithJavaUtilConcurrentAtomicAtomicLong:(JavaUtilConcurrentAtomicAtomicLong *)requested
                                                             withLong:(jlong)n
                                                    withJavaUtilQueue:(id<JavaUtilQueue>)queue
                                                     withRxSubscriber:(RxSubscriber *)actual
                                                 withRxFunctionsFunc1:(id<RxFunctionsFunc1>)exitTransform;

/*!
 @brief Accumulates requests (validated) and handles the completed mode draining of the queue based on the requests.
 <p>
 Post-completion backpressure handles the case when a source produces values based on
 requests when it is active but more values are available even after its completion.
 In this case, the onCompleted() can't just emit the contents of the queue but has to
 coordinate with the requested amounts. This requires two distinct modes: active and
 completed. In active mode, requests flow through and the queue is not accessed but
 in completed mode, requests no-longer reach the upstream but help in draining the queue.
 @param requested the holder of current requested amount
 @param n the value requested;
 @param queue the queue holding values to be emitted after completion
 @param actual the subscriber to receive the values
 @return true if in the active mode and the request amount of n can be relayed to upstream, false if
 in the post-completed mode and the queue is draining.
 */
+ (jboolean)postCompleteRequestWithJavaUtilConcurrentAtomicAtomicLong:(JavaUtilConcurrentAtomicAtomicLong *)requested
                                                             withLong:(jlong)n
                                                    withJavaUtilQueue:(id<JavaUtilQueue>)queue
                                                     withRxSubscriber:(RxSubscriber *)actual;

/*!
 @brief Atomically subtracts a value from the requested amount unless it's at Long.MAX_VALUE.
 @param requested the requested amount holder
 @param n the value to subtract from the requested amount, has to be positive (not verified)
 @return the new requested amount
 @throws IllegalStateException if n is greater than the current requested amount, which
 indicates a bug in the request accounting logic
 */
+ (jlong)producedWithJavaUtilConcurrentAtomicAtomicLong:(JavaUtilConcurrentAtomicAtomicLong *)requested
                                               withLong:(jlong)n;

#pragma mark Package-Private

/*!
 @brief Drains the queue based on the outstanding requests in post-completed mode (only!)
 and allows exit transformation on the queued values.
 @param requested the holder of current requested amount
 @param queue the queue holding values to be emitted after completion
 @param subscriber the subscriber to receive the values
 @param exitTransform the transformation to apply on the dequeued value to get the value to be emitted
 */
+ (void)postCompleteDrainWithJavaUtilConcurrentAtomicAtomicLong:(JavaUtilConcurrentAtomicAtomicLong *)requested
                                              withJavaUtilQueue:(id<JavaUtilQueue>)queue
                                               withRxSubscriber:(RxSubscriber *)subscriber
                                           withRxFunctionsFunc1:(id<RxFunctionsFunc1>)exitTransform;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalOperatorsBackpressureUtils)

/*!
 @brief Masks the most significant bit, i.e., 0x8000_0000_0000_0000L.
 */
inline jlong RxInternalOperatorsBackpressureUtils_get_COMPLETED_MASK();
#define RxInternalOperatorsBackpressureUtils_COMPLETED_MASK ((jlong) 0x8000000000000000LL)
J2OBJC_STATIC_FIELD_CONSTANT(RxInternalOperatorsBackpressureUtils, COMPLETED_MASK, jlong)

/*!
 @brief Masks the request amount bits, i.e., 0x7FFF_FFFF_FFFF_FFFF.
 */
inline jlong RxInternalOperatorsBackpressureUtils_get_REQUESTED_MASK();
#define RxInternalOperatorsBackpressureUtils_REQUESTED_MASK 9223372036854775807LL
J2OBJC_STATIC_FIELD_CONSTANT(RxInternalOperatorsBackpressureUtils, REQUESTED_MASK, jlong)

FOUNDATION_EXPORT jlong RxInternalOperatorsBackpressureUtils_getAndAddRequestWithJavaUtilConcurrentAtomicAtomicLongFieldUpdater_withId_withLong_(JavaUtilConcurrentAtomicAtomicLongFieldUpdater *requested, id object, jlong n);

FOUNDATION_EXPORT jlong RxInternalOperatorsBackpressureUtils_getAndAddRequestWithJavaUtilConcurrentAtomicAtomicLong_withLong_(JavaUtilConcurrentAtomicAtomicLong *requested, jlong n);

FOUNDATION_EXPORT jlong RxInternalOperatorsBackpressureUtils_multiplyCapWithLong_withLong_(jlong a, jlong b);

FOUNDATION_EXPORT jlong RxInternalOperatorsBackpressureUtils_addCapWithLong_withLong_(jlong a, jlong b);

FOUNDATION_EXPORT void RxInternalOperatorsBackpressureUtils_postCompleteDoneWithJavaUtilConcurrentAtomicAtomicLong_withJavaUtilQueue_withRxSubscriber_(JavaUtilConcurrentAtomicAtomicLong *requested, id<JavaUtilQueue> queue, RxSubscriber *actual);

FOUNDATION_EXPORT jboolean RxInternalOperatorsBackpressureUtils_postCompleteRequestWithJavaUtilConcurrentAtomicAtomicLong_withLong_withJavaUtilQueue_withRxSubscriber_(JavaUtilConcurrentAtomicAtomicLong *requested, jlong n, id<JavaUtilQueue> queue, RxSubscriber *actual);

FOUNDATION_EXPORT void RxInternalOperatorsBackpressureUtils_postCompleteDoneWithJavaUtilConcurrentAtomicAtomicLong_withJavaUtilQueue_withRxSubscriber_withRxFunctionsFunc1_(JavaUtilConcurrentAtomicAtomicLong *requested, id<JavaUtilQueue> queue, RxSubscriber *actual, id<RxFunctionsFunc1> exitTransform);

FOUNDATION_EXPORT jboolean RxInternalOperatorsBackpressureUtils_postCompleteRequestWithJavaUtilConcurrentAtomicAtomicLong_withLong_withJavaUtilQueue_withRxSubscriber_withRxFunctionsFunc1_(JavaUtilConcurrentAtomicAtomicLong *requested, jlong n, id<JavaUtilQueue> queue, RxSubscriber *actual, id<RxFunctionsFunc1> exitTransform);

FOUNDATION_EXPORT void RxInternalOperatorsBackpressureUtils_postCompleteDrainWithJavaUtilConcurrentAtomicAtomicLong_withJavaUtilQueue_withRxSubscriber_withRxFunctionsFunc1_(JavaUtilConcurrentAtomicAtomicLong *requested, id<JavaUtilQueue> queue, RxSubscriber *subscriber, id<RxFunctionsFunc1> exitTransform);

FOUNDATION_EXPORT jlong RxInternalOperatorsBackpressureUtils_producedWithJavaUtilConcurrentAtomicAtomicLong_withLong_(JavaUtilConcurrentAtomicAtomicLong *requested, jlong n);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalOperatorsBackpressureUtils)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalOperatorsBackpressureUtils")
