//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/rxjava-1.1.6-sources/rx/schedulers/Schedulers.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "java/util/concurrent/Executor.h"
#include "java/util/concurrent/atomic/AtomicReference.h"
#include "rx/Scheduler.h"
#include "rx/internal/schedulers/ExecutorScheduler.h"
#include "rx/internal/schedulers/GenericScheduledExecutorService.h"
#include "rx/internal/schedulers/ImmediateScheduler.h"
#include "rx/internal/schedulers/SchedulerLifecycle.h"
#include "rx/internal/schedulers/TrampolineScheduler.h"
#include "rx/internal/util/ObjectPool.h"
#include "rx/internal/util/RxRingBuffer.h"
#include "rx/plugins/RxJavaPlugins.h"
#include "rx/plugins/RxJavaSchedulersHook.h"
#include "rx/schedulers/Schedulers.h"
#include "rx/schedulers/TestScheduler.h"

@interface RxSchedulersSchedulers () {
 @public
  RxScheduler *computationScheduler_;
  RxScheduler *ioScheduler_;
  RxScheduler *newThreadScheduler_;
}

+ (RxSchedulersSchedulers *)getInstance;

- (instancetype)init;

@end

J2OBJC_FIELD_SETTER(RxSchedulersSchedulers, computationScheduler_, RxScheduler *)
J2OBJC_FIELD_SETTER(RxSchedulersSchedulers, ioScheduler_, RxScheduler *)
J2OBJC_FIELD_SETTER(RxSchedulersSchedulers, newThreadScheduler_, RxScheduler *)

inline JavaUtilConcurrentAtomicAtomicReference *RxSchedulersSchedulers_get_INSTANCE();
static JavaUtilConcurrentAtomicAtomicReference *RxSchedulersSchedulers_INSTANCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxSchedulersSchedulers, INSTANCE, JavaUtilConcurrentAtomicAtomicReference *)

__attribute__((unused)) static RxSchedulersSchedulers *RxSchedulersSchedulers_getInstance();

__attribute__((unused)) static void RxSchedulersSchedulers_init(RxSchedulersSchedulers *self);

__attribute__((unused)) static RxSchedulersSchedulers *new_RxSchedulersSchedulers_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static RxSchedulersSchedulers *create_RxSchedulersSchedulers_init();

J2OBJC_INITIALIZED_DEFN(RxSchedulersSchedulers)

@implementation RxSchedulersSchedulers

+ (RxSchedulersSchedulers *)getInstance {
  return RxSchedulersSchedulers_getInstance();
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxSchedulersSchedulers_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (RxScheduler *)immediate {
  return RxSchedulersSchedulers_immediate();
}

+ (RxScheduler *)trampoline {
  return RxSchedulersSchedulers_trampoline();
}

+ (RxScheduler *)newThread {
  return RxSchedulersSchedulers_newThread();
}

+ (RxScheduler *)computation {
  return RxSchedulersSchedulers_computation();
}

+ (RxScheduler *)io {
  return RxSchedulersSchedulers_io();
}

+ (RxSchedulersTestScheduler *)test {
  return RxSchedulersSchedulers_test();
}

+ (RxScheduler *)fromWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor {
  return RxSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(executor);
}

+ (void)reset {
  RxSchedulersSchedulers_reset();
}

+ (void)start {
  RxSchedulersSchedulers_start();
}

+ (void)shutdown {
  RxSchedulersSchedulers_shutdown();
}

- (void)startInstance {
  @synchronized(self) {
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:computationScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(computationScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) start];
    }
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:ioScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(ioScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) start];
    }
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:newThreadScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(newThreadScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) start];
    }
  }
}

- (void)shutdownInstance {
  @synchronized(self) {
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:computationScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(computationScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) shutdown];
    }
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:ioScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(ioScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) shutdown];
    }
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:newThreadScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(newThreadScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) shutdown];
    }
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getInstance", "LRxSchedulersSchedulers;", 0xa, -1, -1, -1, -1, -1, -1 },
    { "init", NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { "immediate", "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { "trampoline", "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { "newThread", "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { "computation", "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { "io", "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { "test", "LRxSchedulersTestScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { "fromWithJavaUtilConcurrentExecutor:", "LRxScheduler;", 0x9, 0, 1, -1, -1, -1, -1 },
    { "reset", "V", 0x9, -1, -1, -1, -1, -1, -1 },
    { "start", "V", 0x8, -1, -1, -1, -1, -1, -1 },
    { "shutdown", "V", 0x9, -1, -1, -1, -1, -1, -1 },
    { "startInstance", "V", 0x20, -1, -1, -1, -1, -1, -1 },
    { "shutdownInstance", "V", 0x20, -1, -1, -1, -1, -1, -1 },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "computationScheduler_", "LRxScheduler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "ioScheduler_", "LRxScheduler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "newThreadScheduler_", "LRxScheduler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "INSTANCE", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1a, -1, 2, 3, -1 },
  };
  static const void *ptrTable[] = { "from", "LJavaUtilConcurrentExecutor;", &RxSchedulersSchedulers_INSTANCE, "Ljava/util/concurrent/atomic/AtomicReference<Lrx/schedulers/Schedulers;>;" };
  static const J2ObjcClassInfo _RxSchedulersSchedulers = { "Schedulers", "rx.schedulers", ptrTable, methods, fields, 7, 0x11, 14, 4, -1, -1, -1, -1, -1 };
  return &_RxSchedulersSchedulers;
}

+ (void)initialize {
  if (self == [RxSchedulersSchedulers class]) {
    RxSchedulersSchedulers_INSTANCE = new_JavaUtilConcurrentAtomicAtomicReference_init();
    J2OBJC_SET_INITIALIZED(RxSchedulersSchedulers)
  }
}

@end

RxSchedulersSchedulers *RxSchedulersSchedulers_getInstance() {
  RxSchedulersSchedulers_initialize();
  for (; ; ) {
    RxSchedulersSchedulers *current = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(RxSchedulersSchedulers_INSTANCE)) get];
    if (current != nil) {
      return current;
    }
    current = new_RxSchedulersSchedulers_init();
    if ([RxSchedulersSchedulers_INSTANCE compareAndSetWithId:nil withId:current]) {
      return current;
    }
    else {
      [current shutdownInstance];
    }
  }
}

void RxSchedulersSchedulers_init(RxSchedulersSchedulers *self) {
  NSObject_init(self);
  RxPluginsRxJavaSchedulersHook *hook = [((RxPluginsRxJavaPlugins *) nil_chk(RxPluginsRxJavaPlugins_getInstance())) getSchedulersHook];
  RxScheduler *c = [((RxPluginsRxJavaSchedulersHook *) nil_chk(hook)) getComputationScheduler];
  if (c != nil) {
    self->computationScheduler_ = c;
  }
  else {
    self->computationScheduler_ = RxPluginsRxJavaSchedulersHook_createComputationScheduler();
  }
  RxScheduler *io = [hook getIOScheduler];
  if (io != nil) {
    self->ioScheduler_ = io;
  }
  else {
    self->ioScheduler_ = RxPluginsRxJavaSchedulersHook_createIoScheduler();
  }
  RxScheduler *nt = [hook getNewThreadScheduler];
  if (nt != nil) {
    self->newThreadScheduler_ = nt;
  }
  else {
    self->newThreadScheduler_ = RxPluginsRxJavaSchedulersHook_createNewThreadScheduler();
  }
}

RxSchedulersSchedulers *new_RxSchedulersSchedulers_init() {
  J2OBJC_NEW_IMPL(RxSchedulersSchedulers, init)
}

RxSchedulersSchedulers *create_RxSchedulersSchedulers_init() {
  J2OBJC_CREATE_IMPL(RxSchedulersSchedulers, init)
}

RxScheduler *RxSchedulersSchedulers_immediate() {
  RxSchedulersSchedulers_initialize();
  return JreLoadStatic(RxInternalSchedulersImmediateScheduler, INSTANCE);
}

RxScheduler *RxSchedulersSchedulers_trampoline() {
  RxSchedulersSchedulers_initialize();
  return JreLoadStatic(RxInternalSchedulersTrampolineScheduler, INSTANCE);
}

RxScheduler *RxSchedulersSchedulers_newThread() {
  RxSchedulersSchedulers_initialize();
  return ((RxSchedulersSchedulers *) nil_chk(RxSchedulersSchedulers_getInstance()))->newThreadScheduler_;
}

RxScheduler *RxSchedulersSchedulers_computation() {
  RxSchedulersSchedulers_initialize();
  return ((RxSchedulersSchedulers *) nil_chk(RxSchedulersSchedulers_getInstance()))->computationScheduler_;
}

RxScheduler *RxSchedulersSchedulers_io() {
  RxSchedulersSchedulers_initialize();
  return ((RxSchedulersSchedulers *) nil_chk(RxSchedulersSchedulers_getInstance()))->ioScheduler_;
}

RxSchedulersTestScheduler *RxSchedulersSchedulers_test() {
  RxSchedulersSchedulers_initialize();
  return new_RxSchedulersTestScheduler_init();
}

RxScheduler *RxSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor) {
  RxSchedulersSchedulers_initialize();
  return new_RxInternalSchedulersExecutorScheduler_initWithJavaUtilConcurrentExecutor_(executor);
}

void RxSchedulersSchedulers_reset() {
  RxSchedulersSchedulers_initialize();
  RxSchedulersSchedulers *s = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(RxSchedulersSchedulers_INSTANCE)) getAndSetWithId:nil];
  if (s != nil) {
    [s shutdownInstance];
  }
}

void RxSchedulersSchedulers_start() {
  RxSchedulersSchedulers_initialize();
  RxSchedulersSchedulers *s = RxSchedulersSchedulers_getInstance();
  [((RxSchedulersSchedulers *) nil_chk(s)) startInstance];
  @synchronized(s) {
    [((RxInternalSchedulersGenericScheduledExecutorService *) nil_chk(JreLoadStatic(RxInternalSchedulersGenericScheduledExecutorService, INSTANCE))) start];
    [((RxInternalUtilObjectPool *) nil_chk(JreLoadStatic(RxInternalUtilRxRingBuffer, SPSC_POOL))) start];
    [((RxInternalUtilObjectPool *) nil_chk(JreLoadStatic(RxInternalUtilRxRingBuffer, SPMC_POOL))) start];
  }
}

void RxSchedulersSchedulers_shutdown() {
  RxSchedulersSchedulers_initialize();
  RxSchedulersSchedulers *s = RxSchedulersSchedulers_getInstance();
  [((RxSchedulersSchedulers *) nil_chk(s)) shutdownInstance];
  @synchronized(s) {
    [((RxInternalSchedulersGenericScheduledExecutorService *) nil_chk(JreLoadStatic(RxInternalSchedulersGenericScheduledExecutorService, INSTANCE))) shutdown];
    [((RxInternalUtilObjectPool *) nil_chk(JreLoadStatic(RxInternalUtilRxRingBuffer, SPSC_POOL))) shutdown];
    [((RxInternalUtilObjectPool *) nil_chk(JreLoadStatic(RxInternalUtilRxRingBuffer, SPMC_POOL))) shutdown];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxSchedulersSchedulers)
