//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/okio-1.9.0-sources/okio/BufferedSink.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OkioBufferedSink")
#ifdef RESTRICT_OkioBufferedSink
#define INCLUDE_ALL_OkioBufferedSink 0
#else
#define INCLUDE_ALL_OkioBufferedSink 1
#endif
#undef RESTRICT_OkioBufferedSink

#if !defined (OkioBufferedSink_) && (INCLUDE_ALL_OkioBufferedSink || defined(INCLUDE_OkioBufferedSink))
#define OkioBufferedSink_

#define RESTRICT_OkioSink 1
#define INCLUDE_OkioSink 1
#include "okio/Sink.h"

@class IOSByteArray;
@class JavaIoOutputStream;
@class JavaNioCharsetCharset;
@class OkioBuffer;
@class OkioByteString;
@protocol OkioSource;

/*!
 @brief A sink that keeps a buffer internally so that callers can do small writes
 without a performance penalty.
 */
@protocol OkioBufferedSink < OkioSink, JavaObject >

/*!
 @brief Returns this sink's internal buffer.
 */
- (OkioBuffer *)buffer;

- (id<OkioBufferedSink>)writeWithOkioByteString:(OkioByteString *)byteString;

/*!
 @brief Like <code>OutputStream.write(byte[])</code>, this writes a complete byte array to
 this sink.
 */
- (id<OkioBufferedSink>)writeWithByteArray:(IOSByteArray *)source;

/*!
 @brief Like <code>OutputStream.write(byte[],int,int)</code>, this writes <code>byteCount</code>
 bytes of <code>source</code>, starting at <code>offset</code>.
 */
- (id<OkioBufferedSink>)writeWithByteArray:(IOSByteArray *)source
                                   withInt:(jint)offset
                                   withInt:(jint)byteCount;

/*!
 @brief Removes all bytes from <code>source</code> and appends them to this sink.
 Returns the
 number of bytes read which will be 0 if <code>source</code> is exhausted.
 */
- (jlong)writeAllWithOkioSource:(id<OkioSource>)source;

/*!
 @brief Removes <code>byteCount</code> bytes from <code>source</code> and appends them to this sink.
 */
- (id<OkioBufferedSink>)writeWithOkioSource:(id<OkioSource>)source
                                   withLong:(jlong)byteCount;

/*!
 @brief Encodes <code>string</code> in UTF-8 and writes it to this sink.
 @code
  Buffer buffer = new Buffer();
   buffer.writeUtf8("Uh uh uh!");
   buffer.writeByte(' ');
   buffer.writeUtf8("You didn't say the magic word!");
   assertEquals("Uh uh uh! You didn't say the magic word!", buffer.readUtf8());
 
@endcode
 */
- (id<OkioBufferedSink>)writeUtf8WithNSString:(NSString *)string;

/*!
 @brief Encodes the characters at <code>beginIndex</code> up to <code>endIndex</code> from <code>string</code> in
 UTF-8 and writes it to this sink.
 @code
  Buffer buffer = new Buffer();
   buffer.writeUtf8("I'm a hacker!\n", 6, 12);
   buffer.writeByte(' ');
   buffer.writeUtf8("That's what I said: you're a nerd.\n", 29, 33);
   buffer.writeByte(' ');
   buffer.writeUtf8("I prefer to be called a hacker!\n", 24, 31);
   assertEquals("hacker nerd hacker!", buffer.readUtf8());
 
@endcode
 */
- (id<OkioBufferedSink>)writeUtf8WithNSString:(NSString *)string
                                      withInt:(jint)beginIndex
                                      withInt:(jint)endIndex;

/*!
 @brief Encodes <code>codePoint</code> in UTF-8 and writes it to this sink.
 */
- (id<OkioBufferedSink>)writeUtf8CodePointWithInt:(jint)codePoint;

/*!
 @brief Encodes <code>string</code> in <code>charset</code> and writes it to this sink.
 */
- (id<OkioBufferedSink>)writeStringWithNSString:(NSString *)string
                      withJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset;

/*!
 @brief Encodes the characters at <code>beginIndex</code> up to <code>endIndex</code> from <code>string</code> in
 <code>charset</code> and writes it to this sink.
 */
- (id<OkioBufferedSink>)writeStringWithNSString:(NSString *)string
                                        withInt:(jint)beginIndex
                                        withInt:(jint)endIndex
                      withJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset;

/*!
 @brief Writes a byte to this sink.
 */
- (id<OkioBufferedSink>)writeByteWithInt:(jint)b;

/*!
 @brief Writes a big-endian short to this sink using two bytes.
 @code
  Buffer buffer = new Buffer();
   buffer.writeShort(32767);
   buffer.writeShort(15);
   assertEquals(4, buffer.size());
   assertEquals((byte) 0x7f, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x0f, buffer.readByte());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (id<OkioBufferedSink>)writeShortWithInt:(jint)s;

/*!
 @brief Writes a little-endian short to this sink using two bytes.
 @code
  Buffer buffer = new Buffer();
   buffer.writeShortLe(32767);
   buffer.writeShortLe(15);
   assertEquals(4, buffer.size());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0x7f, buffer.readByte());
   assertEquals((byte) 0x0f, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (id<OkioBufferedSink>)writeShortLeWithInt:(jint)s;

/*!
 @brief Writes a big-endian int to this sink using four bytes.
 @code
  Buffer buffer = new Buffer();
   buffer.writeInt(2147483647);
   buffer.writeInt(15);
   assertEquals(8, buffer.size());
   assertEquals((byte) 0x7f, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x0f, buffer.readByte());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (id<OkioBufferedSink>)writeIntWithInt:(jint)i;

/*!
 @brief Writes a little-endian int to this sink using four bytes.
 @code
  Buffer buffer = new Buffer();
   buffer.writeIntLe(2147483647);
   buffer.writeIntLe(15);
   assertEquals(8, buffer.size());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0x7f, buffer.readByte());
   assertEquals((byte) 0x0f, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (id<OkioBufferedSink>)writeIntLeWithInt:(jint)i;

/*!
 @brief Writes a big-endian long to this sink using eight bytes.
 @code
  Buffer buffer = new Buffer();
   buffer.writeLong(9223372036854775807L);
   buffer.writeLong(15);
   assertEquals(16, buffer.size());
   assertEquals((byte) 0x7f, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x0f, buffer.readByte());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (id<OkioBufferedSink>)writeLongWithLong:(jlong)v;

/*!
 @brief Writes a little-endian long to this sink using eight bytes.
 @code
  Buffer buffer = new Buffer();
   buffer.writeLongLe(9223372036854775807L);
   buffer.writeLongLe(15);
   assertEquals(16, buffer.size());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0xff, buffer.readByte());
   assertEquals((byte) 0x7f, buffer.readByte());
   assertEquals((byte) 0x0f, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals((byte) 0x00, buffer.readByte());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (id<OkioBufferedSink>)writeLongLeWithLong:(jlong)v;

/*!
 @brief Writes a long to this sink in signed decimal form (i.e., as a string in base 10).
 @code
  Buffer buffer = new Buffer();
   buffer.writeDecimalLong(8675309L);
   buffer.writeByte(' ');
   buffer.writeDecimalLong(-123L);
   buffer.writeByte(' ');
   buffer.writeDecimalLong(1L);
   assertEquals("8675309 -123 1", buffer.readUtf8());
 
@endcode
 */
- (id<OkioBufferedSink>)writeDecimalLongWithLong:(jlong)v;

/*!
 @brief Writes a long to this sink in hexadecimal form (i.e., as a string in base 16).
 @code
  Buffer buffer = new Buffer();
   buffer.writeHexadecimalUnsignedLong(65535L);
   buffer.writeByte(' ');
   buffer.writeHexadecimalUnsignedLong(0xcafebabeL);
   buffer.writeByte(' ');
   buffer.writeHexadecimalUnsignedLong(0x10L);
   assertEquals("ffff cafebabe 10", buffer.readUtf8());
 
@endcode
 */
- (id<OkioBufferedSink>)writeHexadecimalUnsignedLongWithLong:(jlong)v;

/*!
 @brief Writes all buffered data to the underlying sink, if one exists.
 Then that sink is recursively
 flushed which pushes data as far as possible towards its ultimate destination. Typically that
 destination is a network socket or file. 
@code
  BufferedSink b0 = new Buffer();
   BufferedSink b1 = Okio.buffer(b0);
   BufferedSink b2 = Okio.buffer(b1);
   b2.writeUtf8("hello");
   assertEquals(5, b2.buffer().size());
   assertEquals(0, b1.buffer().size());
   assertEquals(0, b0.buffer().size());
   b2.flush();
   assertEquals(0, b2.buffer().size());
   assertEquals(0, b1.buffer().size());
   assertEquals(5, b0.buffer().size());
 
@endcode
 */
- (void)flush;

/*!
 @brief Writes all buffered data to the underlying sink, if one exists.
 Like <code>flush</code>, but
 weaker. Call this before this buffered sink goes out of scope so that its data can reach its
 destination. 
@code
  BufferedSink b0 = new Buffer();
   BufferedSink b1 = Okio.buffer(b0);
   BufferedSink b2 = Okio.buffer(b1);
   b2.writeUtf8("hello");
   assertEquals(5, b2.buffer().size());
   assertEquals(0, b1.buffer().size());
   assertEquals(0, b0.buffer().size());
   b2.emit();
   assertEquals(0, b2.buffer().size());
   assertEquals(5, b1.buffer().size());
   assertEquals(0, b0.buffer().size());
   b1.emit();
   assertEquals(0, b2.buffer().size());
   assertEquals(0, b1.buffer().size());
   assertEquals(5, b0.buffer().size());
 
@endcode
 */
- (id<OkioBufferedSink>)emit;

/*!
 @brief Writes complete segments to the underlying sink, if one exists.
 Like <code>flush</code>, but
 weaker. Use this to limit the memory held in the buffer to a single segment. Typically
 application code will not need to call this: it is only necessary when application code writes
 directly to this sink's buffer. 
@code
  BufferedSink b0 = new Buffer();
   BufferedSink b1 = Okio.buffer(b0);
   BufferedSink b2 = Okio.buffer(b1);
   b2.buffer().write(new byte[20_000]);
   assertEquals(20_000, b2.buffer().size());
   assertEquals(     0, b1.buffer().size());
   assertEquals(     0, b0.buffer().size());
   b2.emitCompleteSegments();
   assertEquals( 3_616, b2.buffer().size());
   assertEquals(     0, b1.buffer().size());
   assertEquals(16_384, b0.buffer().size()); // This example assumes 8192 byte segments.
 
@endcode
 */
- (id<OkioBufferedSink>)emitCompleteSegments;

/*!
 @brief Returns an output stream that writes to this sink.
 */
- (JavaIoOutputStream *)outputStream;

@end

J2OBJC_EMPTY_STATIC_INIT(OkioBufferedSink)

J2OBJC_TYPE_LITERAL_HEADER(OkioBufferedSink)

#endif

#pragma pop_macro("INCLUDE_ALL_OkioBufferedSink")
