//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/okio-1.9.0-sources/okio/SegmentedByteString.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OkioSegmentedByteString")
#ifdef RESTRICT_OkioSegmentedByteString
#define INCLUDE_ALL_OkioSegmentedByteString 0
#else
#define INCLUDE_ALL_OkioSegmentedByteString 1
#endif
#undef RESTRICT_OkioSegmentedByteString

#if !defined (OkioSegmentedByteString_) && (INCLUDE_ALL_OkioSegmentedByteString || defined(INCLUDE_OkioSegmentedByteString))
#define OkioSegmentedByteString_

#define RESTRICT_OkioByteString 1
#define INCLUDE_OkioByteString 1
#include "okio/ByteString.h"

@class IOSByteArray;
@class IOSIntArray;
@class IOSObjectArray;
@class JavaIoOutputStream;
@class JavaNioByteBuffer;
@class OkioBuffer;

/*!
 @brief An immutable byte string composed of segments of byte arrays.
 This class exists to implement
 efficient snapshots of buffers. It is implemented as an array of segments, plus a directory in
 two halves that describes how the segments compose this byte string.
 <p>The first half of the directory is the cumulative byte count covered by each segment. The
 element at <code>directory[0]</code> contains the number of bytes held in <code>segments[0]</code>; the
 element at <code>directory[1]</code> contains the number of bytes held in <code>segments[0] +
 segments[1]</code>
 , and so on. The element at <code>directory[segments.length - 1]</code> contains the total
 size of this byte string. The first half of the directory is always monotonically increasing.
 <p>The second half of the directory is the offset in <code>segments</code> of the first content byte.
 Bytes preceding this offset are unused, as are bytes beyond the segment's effective size.
 <p>Suppose we have a byte string, <code>[A, B, C, D, E, F, G, H, I, J, K, L, M]</code> that is stored
 across three byte arrays: <code>[x, x, x, x, A, B, C, D, E, x, x, x]</code>, <code>[x, F, G]</code>, and
 <code>[H, I, J, K, L, M, x, x, x, x, x, x]</code>. The three byte arrays would be stored in <code>segments</code>
  in order. Since the arrays contribute 5, 2, and 6 elements respectively, the directory
 starts with <code>[5, 7, 13</code> to hold the cumulative total at each position. Since the offsets
 into the arrays are 4, 1, and 0 respectively, the directory ends with <code>4, 1, 0]</code>.
 Concatenating these two halves, the complete directory is <code>[5, 7, 13, 4, 1, 0]</code>.
 <p>This structure is chosen so that the segment holding a particular offset can be found by
 binary search. We use one array rather than two for the directory as a micro-optimization.
 */
@interface OkioSegmentedByteString : OkioByteString {
 @public
  IOSObjectArray *segments_;
  IOSIntArray *directory_;
}

#pragma mark Public

- (JavaNioByteBuffer *)asByteBuffer;

- (NSString *)base64;

- (NSString *)base64Url;

- (jboolean)isEqual:(id)o;

- (jbyte)getByteWithInt:(jint)pos;

- (NSUInteger)hash;

- (NSString *)hex;

- (jint)indexOfWithByteArray:(IOSByteArray *)other
                     withInt:(jint)fromIndex;

- (jint)lastIndexOfWithByteArray:(IOSByteArray *)other
                         withInt:(jint)fromIndex;

- (OkioByteString *)md5;

- (jboolean)rangeEqualsWithInt:(jint)offset
                 withByteArray:(IOSByteArray *)other
                       withInt:(jint)otherOffset
                       withInt:(jint)byteCount;

- (jboolean)rangeEqualsWithInt:(jint)offset
            withOkioByteString:(OkioByteString *)other
                       withInt:(jint)otherOffset
                       withInt:(jint)byteCount;

- (OkioByteString *)sha256;

- (jint)size;

- (OkioByteString *)substringWithInt:(jint)beginIndex;

- (OkioByteString *)substringWithInt:(jint)beginIndex
                             withInt:(jint)endIndex;

- (OkioByteString *)toAsciiLowercase;

- (OkioByteString *)toAsciiUppercase;

- (IOSByteArray *)toByteArray;

- (NSString *)description;

- (NSString *)utf8;

- (void)writeWithJavaIoOutputStream:(JavaIoOutputStream *)outArg;

#pragma mark Package-Private

- (instancetype)initWithOkioBuffer:(OkioBuffer *)buffer
                           withInt:(jint)byteCount;

- (IOSByteArray *)internalArray;

- (void)writeWithOkioBuffer:(OkioBuffer *)buffer;

@end

J2OBJC_EMPTY_STATIC_INIT(OkioSegmentedByteString)

J2OBJC_FIELD_SETTER(OkioSegmentedByteString, segments_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(OkioSegmentedByteString, directory_, IOSIntArray *)

FOUNDATION_EXPORT void OkioSegmentedByteString_initWithOkioBuffer_withInt_(OkioSegmentedByteString *self, OkioBuffer *buffer, jint byteCount);

FOUNDATION_EXPORT OkioSegmentedByteString *new_OkioSegmentedByteString_initWithOkioBuffer_withInt_(OkioBuffer *buffer, jint byteCount) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OkioSegmentedByteString *create_OkioSegmentedByteString_initWithOkioBuffer_withInt_(OkioBuffer *buffer, jint byteCount);

J2OBJC_TYPE_LITERAL_HEADER(OkioSegmentedByteString)

#endif

#pragma pop_macro("INCLUDE_ALL_OkioSegmentedByteString")
