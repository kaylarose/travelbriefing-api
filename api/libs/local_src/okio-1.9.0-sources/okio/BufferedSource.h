//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/okio-1.9.0-sources/okio/BufferedSource.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OkioBufferedSource")
#ifdef RESTRICT_OkioBufferedSource
#define INCLUDE_ALL_OkioBufferedSource 0
#else
#define INCLUDE_ALL_OkioBufferedSource 1
#endif
#undef RESTRICT_OkioBufferedSource

#if !defined (OkioBufferedSource_) && (INCLUDE_ALL_OkioBufferedSource || defined(INCLUDE_OkioBufferedSource))
#define OkioBufferedSource_

#define RESTRICT_OkioSource 1
#define INCLUDE_OkioSource 1
#include "okio/Source.h"

@class IOSByteArray;
@class JavaIoInputStream;
@class JavaNioCharsetCharset;
@class OkioBuffer;
@class OkioByteString;
@class OkioOptions;
@protocol OkioSink;

/*!
 @brief A source that keeps a buffer internally so that callers can do small reads without a performance
 penalty.
 It also allows clients to read ahead, buffering as much as necessary before consuming
 input.
 */
@protocol OkioBufferedSource < OkioSource, JavaObject >

/*!
 @brief Returns this source's internal buffer.
 */
- (OkioBuffer *)buffer;

/*!
 @brief Returns true if there are no more bytes in this source.
 This will block until there are bytes
 to read or the source is definitely exhausted.
 */
- (jboolean)exhausted;

/*!
 @brief Returns when the buffer contains at least <code>byteCount</code> bytes.
 Throws an
 <code>java.io.EOFException</code> if the source is exhausted before the required bytes can be read.
 */
- (void)requireWithLong:(jlong)byteCount;

/*!
 @brief Returns true when the buffer contains at least <code>byteCount</code> bytes, expanding it as
 necessary.
 Returns false if the source is exhausted before the requested bytes can be read.
 */
- (jboolean)requestWithLong:(jlong)byteCount;

/*!
 @brief Removes a byte from this source and returns it.
 */
- (jbyte)readByte;

/*!
 @brief Removes two bytes from this source and returns a big-endian short.
 @code
  Buffer buffer = new Buffer()
       .writeByte(0x7f)
       .writeByte(0xff)
       .writeByte(0x00)
       .writeByte(0x0f);
   assertEquals(4, buffer.size());
   assertEquals(32767, buffer.readShort());
   assertEquals(2, buffer.size());
   assertEquals(15, buffer.readShort());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (jshort)readShort;

/*!
 @brief Removes two bytes from this source and returns a little-endian short.
 @code
  Buffer buffer = new Buffer()
       .writeByte(0xff)
       .writeByte(0x7f)
       .writeByte(0x0f)
       .writeByte(0x00);
   assertEquals(4, buffer.size());
   assertEquals(32767, buffer.readShortLe());
   assertEquals(2, buffer.size());
   assertEquals(15, buffer.readShortLe());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (jshort)readShortLe;

/*!
 @brief Removes four bytes from this source and returns a big-endian int.
 @code
  Buffer buffer = new Buffer()
       .writeByte(0x7f)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x0f);
   assertEquals(8, buffer.size());
   assertEquals(2147483647, buffer.readInt());
   assertEquals(4, buffer.size());
   assertEquals(15, buffer.readInt());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (jint)readInt;

/*!
 @brief Removes four bytes from this source and returns a little-endian int.
 @code
  Buffer buffer = new Buffer()
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0x7f)
       .writeByte(0x0f)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00);
   assertEquals(8, buffer.size());
   assertEquals(2147483647, buffer.readIntLe());
   assertEquals(4, buffer.size());
   assertEquals(15, buffer.readIntLe());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (jint)readIntLe;

/*!
 @brief Removes eight bytes from this source and returns a big-endian long.
 @code
  Buffer buffer = new Buffer()
       .writeByte(0x7f)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x0f);
   assertEquals(16, buffer.size());
   assertEquals(9223372036854775807L, buffer.readLong());
   assertEquals(8, buffer.size());
   assertEquals(15, buffer.readLong());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (jlong)readLong;

/*!
 @brief Removes eight bytes from this source and returns a little-endian long.
 @code
  Buffer buffer = new Buffer()
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0xff)
       .writeByte(0x7f)
       .writeByte(0x0f)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00)
       .writeByte(0x00);
   assertEquals(16, buffer.size());
   assertEquals(9223372036854775807L, buffer.readLongLe());
   assertEquals(8, buffer.size());
   assertEquals(15, buffer.readLongLe());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (jlong)readLongLe;

/*!
 @brief Reads a long from this source in signed decimal form (i.e., as a string in base 10 with
 optional leading '-').
 This will iterate until a non-digit character is found. 
@code
  Buffer buffer = new Buffer()
       .writeUtf8("8675309 -123 00001");
   assertEquals(8675309L, buffer.readDecimalLong());
   assertEquals(' ', buffer.readByte());
   assertEquals(-123L, buffer.readDecimalLong());
   assertEquals(' ', buffer.readByte());
   assertEquals(1L, buffer.readDecimalLong());
 
@endcode
 @throws NumberFormatException if the found digits do not fit into a <code>long</code> or a decimal
 number was not present.
 */
- (jlong)readDecimalLong;

/*!
 @brief Reads a long form this source in hexadecimal form (i.e., as a string in base 16).
 This will
 iterate until a non-hexadecimal character is found. 
@code
  Buffer buffer = new Buffer()
       .writeUtf8("ffff CAFEBABE 10");
   assertEquals(65535L, buffer.readHexadecimalUnsignedLong());
   assertEquals(' ', buffer.readByte());
   assertEquals(0xcafebabeL, buffer.readHexadecimalUnsignedLong());
   assertEquals(' ', buffer.readByte());
   assertEquals(0x10L, buffer.readHexadecimalUnsignedLong());
 
@endcode
 @throws NumberFormatException if the found hexadecimal does not fit into a <code>long</code> or
 hexadecimal was not found.
 */
- (jlong)readHexadecimalUnsignedLong;

/*!
 @brief Reads and discards <code>byteCount</code> bytes from this source.
 Throws an
 <code>java.io.EOFException</code> if the source is exhausted before the
 requested bytes can be skipped.
 */
- (void)skipWithLong:(jlong)byteCount;

/*!
 @brief Removes all bytes bytes from this and returns them as a byte string.
 */
- (OkioByteString *)readByteString;

/*!
 @brief Removes <code>byteCount</code> bytes from this and returns them as a byte string.
 */
- (OkioByteString *)readByteStringWithLong:(jlong)byteCount;

/*!
 @brief Finds the first string in <code>options</code> that is a prefix of this buffer, consumes it from
 this buffer, and returns its index.
 If no byte string in <code>options</code> is a prefix of this
 buffer this returns -1 and no bytes are consumed.
 <p>This can be used as an alternative to <code>readByteString</code> or even <code>readUtf8</code> if
 the set of expected values is known in advance. 
@code
  Options FIELDS = Options.of(
       ByteString.encodeUtf8("depth="),
       ByteString.encodeUtf8("height="),
       ByteString.encodeUtf8("width="));
   Buffer buffer = new Buffer()
       .writeUtf8("width=640\n")
       .writeUtf8("height=480\n");
   assertEquals(2, buffer.select(FIELDS));
   assertEquals(640, buffer.readDecimalLong());
   assertEquals('\n', buffer.readByte());
   assertEquals(1, buffer.select(FIELDS));
   assertEquals(480, buffer.readDecimalLong());
   assertEquals('\n', buffer.readByte());
 
@endcode
 */
- (jint)selectWithOkioOptions:(OkioOptions *)options;

/*!
 @brief Removes all bytes from this and returns them as a byte array.
 */
- (IOSByteArray *)readByteArray;

/*!
 @brief Removes <code>byteCount</code> bytes from this and returns them as a byte array.
 */
- (IOSByteArray *)readByteArrayWithLong:(jlong)byteCount;

/*!
 @brief Removes up to <code>sink.length</code> bytes from this and copies them into <code>sink</code>.
 Returns
 the number of bytes read, or -1 if this source is exhausted.
 */
- (jint)readWithByteArray:(IOSByteArray *)sink;

/*!
 @brief Removes exactly <code>sink.length</code> bytes from this and copies them into <code>sink</code>.
 Throws
 an <code>java.io.EOFException</code> if the requested number of bytes cannot be read.
 */
- (void)readFullyWithByteArray:(IOSByteArray *)sink;

/*!
 @brief Removes up to <code>byteCount</code> bytes from this and copies them into <code>sink</code> at <code>offset</code>
 .
 Returns the number of bytes read, or -1 if this source is exhausted.
 */
- (jint)readWithByteArray:(IOSByteArray *)sink
                  withInt:(jint)offset
                  withInt:(jint)byteCount;

/*!
 @brief Removes exactly <code>byteCount</code> bytes from this and appends them to <code>sink</code>.
 Throws an
 <code>java.io.EOFException</code> if the requested number of bytes cannot be read.
 */
- (void)readFullyWithOkioBuffer:(OkioBuffer *)sink
                       withLong:(jlong)byteCount;

/*!
 @brief Removes all bytes from this and appends them to <code>sink</code>.
 Returns the total number of bytes
 written to <code>sink</code> which will be 0 if this is exhausted.
 */
- (jlong)readAllWithOkioSink:(id<OkioSink>)sink;

/*!
 @brief Removes all bytes from this, decodes them as UTF-8, and returns the string.
 Returns the empty
 string if this source is empty. 
@code
  Buffer buffer = new Buffer()
       .writeUtf8("Uh uh uh!")
       .writeByte(' ')
       .writeUtf8("You didn't say the magic word!");
   assertEquals("Uh uh uh! You didn't say the magic word!", buffer.readUtf8());
   assertEquals(0, buffer.size());
   assertEquals("", buffer.readUtf8());
   assertEquals(0, buffer.size());
 
@endcode
 */
- (NSString *)readUtf8;

/*!
 @brief Removes <code>byteCount</code> bytes from this, decodes them as UTF-8, and returns the string.
 @code
  Buffer buffer = new Buffer()
       .writeUtf8("Uh uh uh!")
       .writeByte(' ')
       .writeUtf8("You didn't say the magic word!");
   assertEquals(40, buffer.size());
   assertEquals("Uh uh uh! You ", buffer.readUtf8(14));
   assertEquals(26, buffer.size());
   assertEquals("didn't say the", buffer.readUtf8(14));
   assertEquals(12, buffer.size());
   assertEquals(" magic word!", buffer.readUtf8(12));
   assertEquals(0, buffer.size());
 
@endcode
 */
- (NSString *)readUtf8WithLong:(jlong)byteCount;

/*!
 @brief Removes and returns characters up to but not including the next line break.
 A line break is
 either <code>"\n"</code> or <code>"\r\n"</code>; these characters are not included in the result.
 @code
  Buffer buffer = new Buffer()
       .writeUtf8("I'm a hacker!\n")
       .writeUtf8("That's what I said: you're a nerd.\n")
       .writeUtf8("I prefer to be called a hacker!\n");
   assertEquals(81, buffer.size());
   assertEquals("I'm a hacker!", buffer.readUtf8Line());
   assertEquals(67, buffer.size());
   assertEquals("That's what I said: you're a nerd.", buffer.readUtf8Line());
   assertEquals(32, buffer.size());
   assertEquals("I prefer to be called a hacker!", buffer.readUtf8Line());
   assertEquals(0, buffer.size());
   assertEquals(null, buffer.readUtf8Line());
   assertEquals(0, buffer.size());
 
@endcode
 <p><strong>On the end of the stream this method returns null,</strong> just like <code>java.io.BufferedReader</code>
 . If the source doesn't end with a line break then an implicit line
 break is assumed. Null is returned once the source is exhausted. Use this for human-generated
 data, where a trailing line break is optional.
 */
- (NSString *)readUtf8Line;

/*!
 @brief Removes and returns characters up to but not including the next line break.
 A line break is
 either <code>"\n"</code> or <code>"\r\n"</code>; these characters are not included in the result.
 <p><strong>On the end of the stream this method throws.</strong> Every call must consume either
 '\r\n' or '\n'. If these characters are absent in the stream, an <code>java.io.EOFException</code>
 is thrown. Use this for machine-generated data where a missing line break implies truncated
 input.
 */
- (NSString *)readUtf8LineStrict;

/*!
 @brief Removes and returns a single UTF-8 code point, reading between 1 and 4 bytes as necessary.
 <p>If this source is exhausted before a complete code point can be read, this throws an <code>java.io.EOFException</code>
  and consumes no input.
 <p>If this source doesn't start with a properly-encoded UTF-8 code point, this method will
 remove 1 or more non-UTF-8 bytes and return the replacement character (<code>U+FFFD</code>). This
 covers encoding problems (the input is not properly-encoded UTF-8), characters out of range
 (beyond the 0x10ffff limit of Unicode), code points for UTF-16 surrogates (U+d800..U+dfff) and
 overlong encodings (such as <code>0xc080</code> for the NUL character in modified UTF-8).
 */
- (jint)readUtf8CodePoint;

/*!
 @brief Removes all bytes from this, decodes them as <code>charset</code>, and returns the string.
 */
- (NSString *)readStringWithJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset;

/*!
 @brief Removes <code>byteCount</code> bytes from this, decodes them as <code>charset</code>, and returns the
 string.
 */
- (NSString *)readStringWithLong:(jlong)byteCount
       withJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset;

/*!
 @brief Equivalent to <code>indexOf(b, 0)</code>.
 */
- (jlong)indexOfWithByte:(jbyte)b;

/*!
 @brief Returns the index of the first <code>b</code> in the buffer at or after <code>fromIndex</code>.
 This
 expands the buffer as necessary until <code>b</code> is found. This reads an unbounded number of
 bytes into the buffer. Returns -1 if the stream is exhausted before the requested byte is
 found. 
@code
  Buffer buffer = new Buffer();
   buffer.writeUtf8("Don't move! He can't see us if we don't move.");
   byte m = 'm';
   assertEquals(6,  buffer.indexOf(m));
   assertEquals(40, buffer.indexOf(m, 12));
 
@endcode
 */
- (jlong)indexOfWithByte:(jbyte)b
                withLong:(jlong)fromIndex;

/*!
 @brief Equivalent to <code>indexOf(bytes, 0)</code>.
 */
- (jlong)indexOfWithOkioByteString:(OkioByteString *)bytes;

/*!
 @brief Returns the index of the first match for <code>bytes</code> in the buffer at or after <code>fromIndex</code>
 .
 This expands the buffer as necessary until <code>bytes</code> is found. This reads an
 unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the
 requested bytes are found. 
@code
  ByteString MOVE = ByteString.encodeUtf8("move");
   Buffer buffer = new Buffer();
   buffer.writeUtf8("Don't move! He can't see us if we don't move.");
   assertEquals(6,  buffer.indexOf(MOVE));
   assertEquals(40, buffer.indexOf(MOVE, 12));
 
@endcode
 */
- (jlong)indexOfWithOkioByteString:(OkioByteString *)bytes
                          withLong:(jlong)fromIndex;

/*!
 @brief Equivalent to <code>indexOfElement(targetBytes, 0)</code>.
 */
- (jlong)indexOfElementWithOkioByteString:(OkioByteString *)targetBytes;

/*!
 @brief Returns the first index in this buffer that is at or after <code>fromIndex</code> and that contains
 any of the bytes in <code>targetBytes</code>.
 This expands the buffer as necessary until a target
 byte is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the
 stream is exhausted before the requested byte is found. 
@code
  ByteString ANY_VOWEL = ByteString.encodeUtf8("AEOIUaeoiu");
   Buffer buffer = new Buffer();
   buffer.writeUtf8("Dr. Alan Grant");
   assertEquals(4,  buffer.indexOfElement(ANY_VOWEL));    // 'A' in 'Alan'.
   assertEquals(11, buffer.indexOfElement(ANY_VOWEL, 9)); // 'a' in 'Grant'.
 
@endcode
 */
- (jlong)indexOfElementWithOkioByteString:(OkioByteString *)targetBytes
                                 withLong:(jlong)fromIndex;

/*!
 @brief Returns true if the bytes at <code>offset</code> in this source equal <code>bytes</code>.
 This expands
 the buffer as necessary until a byte does not match, all bytes are matched, or if the stream
 is exhausted before enough bytes could determine a match.  
@code
  ByteString simonSays = ByteString.encodeUtf8("Simon says:");
   Buffer standOnOneLeg = new Buffer().writeUtf8("Simon says: Stand on one leg.");
   assertTrue(standOnOneLeg.rangeEquals(0, simonSays));
   Buffer payMeMoney = new Buffer().writeUtf8("Pay me $1,000,000.");
   assertFalse(payMeMoney.rangeEquals(0, simonSays));
 
@endcode
 */
- (jboolean)rangeEqualsWithLong:(jlong)offset
             withOkioByteString:(OkioByteString *)bytes;

/*!
 @brief Returns true if <code>byteCount</code> bytes at <code>offset</code> in this source equal <code>bytes</code>
 at <code>bytesOffset</code>.
 This expands the buffer as necessary until a byte does not match, all
 bytes are matched, or if the stream is exhausted before enough bytes could determine a match.
 */
- (jboolean)rangeEqualsWithLong:(jlong)offset
             withOkioByteString:(OkioByteString *)bytes
                        withInt:(jint)bytesOffset
                        withInt:(jint)byteCount;

/*!
 @brief Returns an input stream that reads from this source.
 */
- (JavaIoInputStream *)inputStream;

@end

J2OBJC_EMPTY_STATIC_INIT(OkioBufferedSource)

J2OBJC_TYPE_LITERAL_HEADER(OkioBufferedSource)

#endif

#pragma pop_macro("INCLUDE_ALL_OkioBufferedSource")
