//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/okio-1.9.0-sources/okio/Buffer.java
//

#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/EOFException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/AssertionError.h"
#include "java/lang/IllegalAccessError.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/System.h"
#include "java/nio/charset/Charset.h"
#include "java/security/MessageDigest.h"
#include "java/security/NoSuchAlgorithmException.h"
#include "java/util/ArrayList.h"
#include "java/util/Collections.h"
#include "java/util/List.h"
#include "okio/Buffer.h"
#include "okio/BufferedSink.h"
#include "okio/ByteString.h"
#include "okio/Options.h"
#include "okio/Segment.h"
#include "okio/SegmentPool.h"
#include "okio/SegmentedByteString.h"
#include "okio/Sink.h"
#include "okio/Source.h"
#include "okio/Timeout.h"
#include "okio/Util.h"

@interface OkioBuffer ()

- (void)readFromWithJavaIoInputStream:(JavaIoInputStream *)inArg
                             withLong:(jlong)byteCount
                          withBoolean:(jboolean)forever;

/*!
 @brief Returns true if the range within this buffer starting at <code>segmentPos</code> in <code>segment</code>
 is equal to <code>bytes[bytesOffset..bytesLimit)</code>.
 */
- (jboolean)rangeEqualsWithOkioSegment:(OkioSegment *)segment
                               withInt:(jint)segmentPos
                    withOkioByteString:(OkioByteString *)bytes
                               withInt:(jint)bytesOffset
                               withInt:(jint)bytesLimit;

- (OkioByteString *)digestWithNSString:(NSString *)algorithm;

@end

inline IOSByteArray *OkioBuffer_get_DIGITS();
static IOSByteArray *OkioBuffer_DIGITS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OkioBuffer, DIGITS, IOSByteArray *)

__attribute__((unused)) static void OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(OkioBuffer *self, JavaIoInputStream *inArg, jlong byteCount, jboolean forever);

__attribute__((unused)) static jboolean OkioBuffer_rangeEqualsWithOkioSegment_withInt_withOkioByteString_withInt_withInt_(OkioBuffer *self, OkioSegment *segment, jint segmentPos, OkioByteString *bytes, jint bytesOffset, jint bytesLimit);

__attribute__((unused)) static OkioByteString *OkioBuffer_digestWithNSString_(OkioBuffer *self, NSString *algorithm);

@interface OkioBuffer_$1 : JavaIoOutputStream {
 @public
  OkioBuffer *this$0_;
}

- (void)writeWithInt:(jint)b;

- (void)writeWithByteArray:(IOSByteArray *)data
                   withInt:(jint)offset
                   withInt:(jint)byteCount;

- (void)flush;

- (void)close;

- (NSString *)description;

- (instancetype)initWithOkioBuffer:(OkioBuffer *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(OkioBuffer_$1)

J2OBJC_FIELD_SETTER(OkioBuffer_$1, this$0_, OkioBuffer *)

__attribute__((unused)) static void OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer_$1 *self, OkioBuffer *outer$);

__attribute__((unused)) static OkioBuffer_$1 *new_OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static OkioBuffer_$1 *create_OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer *outer$);

J2OBJC_TYPE_LITERAL_HEADER(OkioBuffer_$1)

@interface OkioBuffer_$2 : JavaIoInputStream {
 @public
  OkioBuffer *this$0_;
}

- (jint)read;

- (jint)readWithByteArray:(IOSByteArray *)sink
                  withInt:(jint)offset
                  withInt:(jint)byteCount;

- (jint)available;

- (void)close;

- (NSString *)description;

- (instancetype)initWithOkioBuffer:(OkioBuffer *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(OkioBuffer_$2)

J2OBJC_FIELD_SETTER(OkioBuffer_$2, this$0_, OkioBuffer *)

__attribute__((unused)) static void OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer_$2 *self, OkioBuffer *outer$);

__attribute__((unused)) static OkioBuffer_$2 *new_OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static OkioBuffer_$2 *create_OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer *outer$);

J2OBJC_TYPE_LITERAL_HEADER(OkioBuffer_$2)

J2OBJC_INITIALIZED_DEFN(OkioBuffer)

@implementation OkioBuffer

+ (jint)REPLACEMENT_CHARACTER {
  return OkioBuffer_REPLACEMENT_CHARACTER;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  OkioBuffer_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (jlong)size {
  return size_;
}

- (OkioBuffer *)buffer {
  return self;
}

- (JavaIoOutputStream *)outputStream {
  return new_OkioBuffer_$1_initWithOkioBuffer_(self);
}

- (OkioBuffer *)emitCompleteSegments {
  return self;
}

- (id<OkioBufferedSink>)emit {
  return self;
}

- (jboolean)exhausted {
  return size_ == 0;
}

- (void)requireWithLong:(jlong)byteCount {
  if (size_ < byteCount) @throw new_JavaIoEOFException_init();
}

- (jboolean)requestWithLong:(jlong)byteCount {
  return size_ >= byteCount;
}

- (JavaIoInputStream *)inputStream {
  return new_OkioBuffer_$2_initWithOkioBuffer_(self);
}

- (OkioBuffer *)copyToWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  return [self copyToWithJavaIoOutputStream:outArg withLong:0 withLong:size_];
}

- (OkioBuffer *)copyToWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                    withLong:(jlong)offset
                                    withLong:(jlong)byteCount {
  if (outArg == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"out == null");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, offset, byteCount);
  if (byteCount == 0) return self;
  OkioSegment *s = head_;
  for (; offset >= (((OkioSegment *) nil_chk(s))->limit_ - s->pos_); s = s->next_) {
    offset -= (s->limit_ - s->pos_);
  }
  for (; byteCount > 0; s = s->next_) {
    jint pos = (jint) (((OkioSegment *) nil_chk(s))->pos_ + offset);
    jint toCopy = (jint) JavaLangMath_minWithLong_withLong_(s->limit_ - pos, byteCount);
    [outArg writeWithByteArray:s->data_ withInt:pos withInt:toCopy];
    byteCount -= toCopy;
    offset = 0;
  }
  return self;
}

- (OkioBuffer *)copyToWithOkioBuffer:(OkioBuffer *)outArg
                            withLong:(jlong)offset
                            withLong:(jlong)byteCount {
  if (outArg == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"out == null");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, offset, byteCount);
  if (byteCount == 0) return self;
  outArg->size_ += byteCount;
  OkioSegment *s = head_;
  for (; offset >= (((OkioSegment *) nil_chk(s))->limit_ - s->pos_); s = s->next_) {
    offset -= (s->limit_ - s->pos_);
  }
  for (; byteCount > 0; s = ((OkioSegment *) nil_chk(s))->next_) {
    OkioSegment *copy_ = new_OkioSegment_initWithOkioSegment_(s);
    copy_->pos_ += offset;
    copy_->limit_ = JavaLangMath_minWithInt_withInt_(copy_->pos_ + (jint) byteCount, copy_->limit_);
    if (outArg->head_ == nil) {
      outArg->head_ = copy_->next_ = copy_->prev_ = copy_;
    }
    else {
      (void) [((OkioSegment *) nil_chk(outArg->head_->prev_)) pushWithOkioSegment:copy_];
    }
    byteCount -= copy_->limit_ - copy_->pos_;
    offset = 0;
  }
  return self;
}

- (OkioBuffer *)writeToWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  return [self writeToWithJavaIoOutputStream:outArg withLong:size_];
}

- (OkioBuffer *)writeToWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                     withLong:(jlong)byteCount {
  if (outArg == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"out == null");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, 0, byteCount);
  OkioSegment *s = head_;
  while (byteCount > 0) {
    jint toCopy = (jint) JavaLangMath_minWithLong_withLong_(byteCount, ((OkioSegment *) nil_chk(s))->limit_ - s->pos_);
    [outArg writeWithByteArray:s->data_ withInt:s->pos_ withInt:toCopy];
    s->pos_ += toCopy;
    size_ -= toCopy;
    byteCount -= toCopy;
    if (s->pos_ == s->limit_) {
      OkioSegment *toRecycle = s;
      head_ = s = [toRecycle pop];
      OkioSegmentPool_recycleWithOkioSegment_(toRecycle);
    }
  }
  return self;
}

- (OkioBuffer *)readFromWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(self, inArg, JavaLangLong_MAX_VALUE, true);
  return self;
}

- (OkioBuffer *)readFromWithJavaIoInputStream:(JavaIoInputStream *)inArg
                                     withLong:(jlong)byteCount {
  if (byteCount < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"byteCount < 0: ", byteCount));
  OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(self, inArg, byteCount, false);
  return self;
}

- (void)readFromWithJavaIoInputStream:(JavaIoInputStream *)inArg
                             withLong:(jlong)byteCount
                          withBoolean:(jboolean)forever {
  OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(self, inArg, byteCount, forever);
}

- (jlong)completeSegmentByteCount {
  jlong result = size_;
  if (result == 0) return 0;
  OkioSegment *tail = ((OkioSegment *) nil_chk(head_))->prev_;
  if (((OkioSegment *) nil_chk(tail))->limit_ < OkioSegment_SIZE && tail->owner_) {
    result -= tail->limit_ - tail->pos_;
  }
  return result;
}

- (jbyte)readByte {
  if (size_ == 0) @throw new_JavaLangIllegalStateException_initWithNSString_(@"size == 0");
  OkioSegment *segment = head_;
  jint pos = ((OkioSegment *) nil_chk(segment))->pos_;
  jint limit = segment->limit_;
  IOSByteArray *data = segment->data_;
  jbyte b = IOSByteArray_Get(nil_chk(data), pos++);
  size_ -= 1;
  if (pos == limit) {
    head_ = [segment pop];
    OkioSegmentPool_recycleWithOkioSegment_(segment);
  }
  else {
    segment->pos_ = pos;
  }
  return b;
}

- (jbyte)getByteWithLong:(jlong)pos {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, pos, 1);
  for (OkioSegment *s = head_; true; s = s->next_) {
    jint segmentByteCount = ((OkioSegment *) nil_chk(s))->limit_ - s->pos_;
    if (pos < segmentByteCount) return IOSByteArray_Get(nil_chk(s->data_), s->pos_ + (jint) pos);
    pos -= segmentByteCount;
  }
}

- (jshort)readShort {
  if (size_ < 2) @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$J", @"size < 2: ", size_));
  OkioSegment *segment = head_;
  jint pos = ((OkioSegment *) nil_chk(segment))->pos_;
  jint limit = segment->limit_;
  if (limit - pos < 2) {
    jint s = (JreLShift32(([self readByte] & (jint) 0xff), 8)) | ([self readByte] & (jint) 0xff);
    return (jshort) s;
  }
  IOSByteArray *data = segment->data_;
  jint unseq$1 = pos++;
  jint s = (JreLShift32((IOSByteArray_Get(nil_chk(data), unseq$1) & (jint) 0xff), 8)) | (IOSByteArray_Get(data, pos++) & (jint) 0xff);
  size_ -= 2;
  if (pos == limit) {
    head_ = [segment pop];
    OkioSegmentPool_recycleWithOkioSegment_(segment);
  }
  else {
    segment->pos_ = pos;
  }
  return (jshort) s;
}

- (jint)readInt {
  if (size_ < 4) @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$J", @"size < 4: ", size_));
  OkioSegment *segment = head_;
  jint pos = ((OkioSegment *) nil_chk(segment))->pos_;
  jint limit = segment->limit_;
  if (limit - pos < 4) {
    return (JreLShift32(([self readByte] & (jint) 0xff), 24)) | (JreLShift32(([self readByte] & (jint) 0xff), 16)) | (JreLShift32(([self readByte] & (jint) 0xff), 8)) | ([self readByte] & (jint) 0xff);
  }
  IOSByteArray *data = segment->data_;
  jint unseq$1 = pos++;
  jint unseq$2 = pos++;
  jint unseq$3 = pos++;
  jint i = (JreLShift32((IOSByteArray_Get(nil_chk(data), unseq$1) & (jint) 0xff), 24)) | (JreLShift32((IOSByteArray_Get(data, unseq$2) & (jint) 0xff), 16)) | (JreLShift32((IOSByteArray_Get(data, unseq$3) & (jint) 0xff), 8)) | (IOSByteArray_Get(data, pos++) & (jint) 0xff);
  size_ -= 4;
  if (pos == limit) {
    head_ = [segment pop];
    OkioSegmentPool_recycleWithOkioSegment_(segment);
  }
  else {
    segment->pos_ = pos;
  }
  return i;
}

- (jlong)readLong {
  if (size_ < 8) @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$J", @"size < 8: ", size_));
  OkioSegment *segment = head_;
  jint pos = ((OkioSegment *) nil_chk(segment))->pos_;
  jint limit = segment->limit_;
  if (limit - pos < 8) {
    return (JreLShift64(([self readInt] & (jlong) 0xffffffffLL), 32)) | ([self readInt] & (jlong) 0xffffffffLL);
  }
  IOSByteArray *data = segment->data_;
  jint unseq$1 = pos++;
  jint unseq$2 = pos++;
  jint unseq$3 = pos++;
  jint unseq$4 = pos++;
  jint unseq$5 = pos++;
  jint unseq$6 = pos++;
  jint unseq$7 = pos++;
  jlong v = (JreLShift64((IOSByteArray_Get(nil_chk(data), unseq$1) & (jlong) 0xffLL), 56)) | (JreLShift64((IOSByteArray_Get(data, unseq$2) & (jlong) 0xffLL), 48)) | (JreLShift64((IOSByteArray_Get(data, unseq$3) & (jlong) 0xffLL), 40)) | (JreLShift64((IOSByteArray_Get(data, unseq$4) & (jlong) 0xffLL), 32)) | (JreLShift64((IOSByteArray_Get(data, unseq$5) & (jlong) 0xffLL), 24)) | (JreLShift64((IOSByteArray_Get(data, unseq$6) & (jlong) 0xffLL), 16)) | (JreLShift64((IOSByteArray_Get(data, unseq$7) & (jlong) 0xffLL), 8)) | (IOSByteArray_Get(data, pos++) & (jlong) 0xffLL);
  size_ -= 8;
  if (pos == limit) {
    head_ = [segment pop];
    OkioSegmentPool_recycleWithOkioSegment_(segment);
  }
  else {
    segment->pos_ = pos;
  }
  return v;
}

- (jshort)readShortLe {
  return OkioUtil_reverseBytesShortWithShort_([self readShort]);
}

- (jint)readIntLe {
  return OkioUtil_reverseBytesIntWithInt_([self readInt]);
}

- (jlong)readLongLe {
  return OkioUtil_reverseBytesLongWithLong_([self readLong]);
}

- (jlong)readDecimalLong {
  if (size_ == 0) @throw new_JavaLangIllegalStateException_initWithNSString_(@"size == 0");
  jlong value = 0;
  jint seen = 0;
  jboolean negative = false;
  jboolean done = false;
  jlong overflowZone = JavaLangLong_MIN_VALUE / 10;
  jlong overflowDigit = (JavaLangLong_MIN_VALUE % 10) + 1;
  do {
    OkioSegment *segment = head_;
    IOSByteArray *data = ((OkioSegment *) nil_chk(segment))->data_;
    jint pos = segment->pos_;
    jint limit = segment->limit_;
    for (; pos < limit; pos++, seen++) {
      jbyte b = IOSByteArray_Get(nil_chk(data), pos);
      if (b >= '0' && b <= '9') {
        jint digit = '0' - b;
        if (value < overflowZone || (value == overflowZone && digit < overflowDigit)) {
          OkioBuffer *buffer = [((OkioBuffer *) nil_chk([new_OkioBuffer_init() writeDecimalLongWithLong:value])) writeByteWithInt:b];
          if (!negative) [((OkioBuffer *) nil_chk(buffer)) readByte];
          @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$", @"Number too large: ", [((OkioBuffer *) nil_chk(buffer)) readUtf8]));
        }
        value *= 10;
        value += digit;
      }
      else if (b == '-' && seen == 0) {
        negative = true;
        overflowDigit -= 1;
      }
      else {
        if (seen == 0) {
          @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$", @"Expected leading [0-9] or '-' character but was 0x", JavaLangInteger_toHexStringWithInt_(b)));
        }
        done = true;
        break;
      }
    }
    if (pos == limit) {
      head_ = [segment pop];
      OkioSegmentPool_recycleWithOkioSegment_(segment);
    }
    else {
      segment->pos_ = pos;
    }
  }
  while (!done && head_ != nil);
  size_ -= seen;
  return negative ? value : -value;
}

- (jlong)readHexadecimalUnsignedLong {
  if (size_ == 0) @throw new_JavaLangIllegalStateException_initWithNSString_(@"size == 0");
  jlong value = 0;
  jint seen = 0;
  jboolean done = false;
  do {
    OkioSegment *segment = head_;
    IOSByteArray *data = ((OkioSegment *) nil_chk(segment))->data_;
    jint pos = segment->pos_;
    jint limit = segment->limit_;
    for (; pos < limit; pos++, seen++) {
      jint digit;
      jbyte b = IOSByteArray_Get(nil_chk(data), pos);
      if (b >= '0' && b <= '9') {
        digit = b - '0';
      }
      else if (b >= 'a' && b <= 'f') {
        digit = b - 'a' + 10;
      }
      else if (b >= 'A' && b <= 'F') {
        digit = b - 'A' + 10;
      }
      else {
        if (seen == 0) {
          @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$", @"Expected leading [0-9a-fA-F] character but was 0x", JavaLangInteger_toHexStringWithInt_(b)));
        }
        done = true;
        break;
      }
      if ((value & (jlong) 0xf000000000000000LL) != 0) {
        OkioBuffer *buffer = [((OkioBuffer *) nil_chk([new_OkioBuffer_init() writeHexadecimalUnsignedLongWithLong:value])) writeByteWithInt:b];
        @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$", @"Number too large: ", [((OkioBuffer *) nil_chk(buffer)) readUtf8]));
      }
      JreLShiftAssignLong(&value, 4);
      value |= digit;
    }
    if (pos == limit) {
      head_ = [segment pop];
      OkioSegmentPool_recycleWithOkioSegment_(segment);
    }
    else {
      segment->pos_ = pos;
    }
  }
  while (!done && head_ != nil);
  size_ -= seen;
  return value;
}

- (OkioByteString *)readByteString {
  return new_OkioByteString_initWithByteArray_([self readByteArray]);
}

- (OkioByteString *)readByteStringWithLong:(jlong)byteCount {
  return new_OkioByteString_initWithByteArray_([self readByteArrayWithLong:byteCount]);
}

- (jint)selectWithOkioOptions:(OkioOptions *)options {
  OkioSegment *s = head_;
  if (s == nil) return [((OkioOptions *) nil_chk(options)) indexOfWithId:JreLoadStatic(OkioByteString, EMPTY)];
  IOSObjectArray *byteStrings = ((OkioOptions *) nil_chk(options))->byteStrings_;
  for (jint i = 0, listSize = ((IOSObjectArray *) nil_chk(byteStrings))->size_; i < listSize; i++) {
    OkioByteString *b = IOSObjectArray_Get(byteStrings, i);
    if (size_ >= [((OkioByteString *) nil_chk(b)) size] && OkioBuffer_rangeEqualsWithOkioSegment_withInt_withOkioByteString_withInt_withInt_(self, s, s->pos_, b, 0, [b size])) {
      @try {
        [self skipWithLong:[b size]];
        return i;
      }
      @catch (JavaIoEOFException *e) {
        @throw new_JavaLangAssertionError_initWithId_(e);
      }
    }
  }
  return -1;
}

- (jint)selectPrefixWithOkioOptions:(OkioOptions *)options {
  OkioSegment *s = head_;
  IOSObjectArray *byteStrings = ((OkioOptions *) nil_chk(options))->byteStrings_;
  for (jint i = 0, listSize = ((IOSObjectArray *) nil_chk(byteStrings))->size_; i < listSize; i++) {
    OkioByteString *b = IOSObjectArray_Get(byteStrings, i);
    jint bytesLimit = (jint) JavaLangMath_minWithLong_withLong_(size_, [((OkioByteString *) nil_chk(b)) size]);
    if (bytesLimit == 0 || OkioBuffer_rangeEqualsWithOkioSegment_withInt_withOkioByteString_withInt_withInt_(self, s, ((OkioSegment *) nil_chk(s))->pos_, b, 0, bytesLimit)) {
      return i;
    }
  }
  return -1;
}

- (void)readFullyWithOkioBuffer:(OkioBuffer *)sink
                       withLong:(jlong)byteCount {
  if (size_ < byteCount) {
    [((OkioBuffer *) nil_chk(sink)) writeWithOkioBuffer:self withLong:size_];
    @throw new_JavaIoEOFException_init();
  }
  [((OkioBuffer *) nil_chk(sink)) writeWithOkioBuffer:self withLong:byteCount];
}

- (jlong)readAllWithOkioSink:(id<OkioSink>)sink {
  jlong byteCount = size_;
  if (byteCount > 0) {
    [((id<OkioSink>) nil_chk(sink)) writeWithOkioBuffer:self withLong:byteCount];
  }
  return byteCount;
}

- (NSString *)readUtf8 {
  @try {
    return [self readStringWithLong:size_ withJavaNioCharsetCharset:JreLoadStatic(OkioUtil, UTF_8)];
  }
  @catch (JavaIoEOFException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

- (NSString *)readUtf8WithLong:(jlong)byteCount {
  return [self readStringWithLong:byteCount withJavaNioCharsetCharset:JreLoadStatic(OkioUtil, UTF_8)];
}

- (NSString *)readStringWithJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset {
  @try {
    return [self readStringWithLong:size_ withJavaNioCharsetCharset:charset];
  }
  @catch (JavaIoEOFException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

- (NSString *)readStringWithLong:(jlong)byteCount
       withJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, 0, byteCount);
  if (charset == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"charset == null");
  if (byteCount > JavaLangInteger_MAX_VALUE) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"byteCount > Integer.MAX_VALUE: ", byteCount));
  }
  if (byteCount == 0) return @"";
  OkioSegment *s = head_;
  if (((OkioSegment *) nil_chk(s))->pos_ + byteCount > s->limit_) {
    return [NSString stringWithBytes:[self readByteArrayWithLong:byteCount] charset:charset];
  }
  NSString *result = [NSString stringWithBytes:s->data_ offset:s->pos_ length:(jint) byteCount charset:charset];
  s->pos_ += byteCount;
  size_ -= byteCount;
  if (s->pos_ == s->limit_) {
    head_ = [s pop];
    OkioSegmentPool_recycleWithOkioSegment_(s);
  }
  return result;
}

- (NSString *)readUtf8Line {
  jlong newline = [self indexOfWithByte:(jbyte) 0x000a];
  if (newline == -1) {
    return size_ != 0 ? [self readUtf8WithLong:size_] : nil;
  }
  return [self readUtf8LineWithLong:newline];
}

- (NSString *)readUtf8LineStrict {
  jlong newline = [self indexOfWithByte:(jbyte) 0x000a];
  if (newline == -1) {
    OkioBuffer *data = new_OkioBuffer_init();
    (void) [self copyToWithOkioBuffer:data withLong:0 withLong:JavaLangMath_minWithLong_withLong_(32, size_)];
    @throw new_JavaIoEOFException_initWithNSString_(JreStrcat("$J$$C", @"\\n not found: size=", [self size], @" content=", [((OkioByteString *) nil_chk([data readByteString])) hex], 0x2026));
  }
  return [self readUtf8LineWithLong:newline];
}

- (NSString *)readUtf8LineWithLong:(jlong)newline {
  if (newline > 0 && [self getByteWithLong:newline - 1] == 0x000d) {
    NSString *result = [self readUtf8WithLong:(newline - 1)];
    [self skipWithLong:2];
    return result;
  }
  else {
    NSString *result = [self readUtf8WithLong:newline];
    [self skipWithLong:1];
    return result;
  }
}

- (jint)readUtf8CodePoint {
  if (size_ == 0) @throw new_JavaIoEOFException_init();
  jbyte b0 = [self getByteWithLong:0];
  jint codePoint;
  jint byteCount;
  jint min;
  if ((b0 & (jint) 0x80) == 0) {
    codePoint = b0 & (jint) 0x7f;
    byteCount = 1;
    min = (jint) 0x0;
  }
  else if ((b0 & (jint) 0xe0) == (jint) 0xc0) {
    codePoint = b0 & (jint) 0x1f;
    byteCount = 2;
    min = (jint) 0x80;
  }
  else if ((b0 & (jint) 0xf0) == (jint) 0xe0) {
    codePoint = b0 & (jint) 0x0f;
    byteCount = 3;
    min = (jint) 0x800;
  }
  else if ((b0 & (jint) 0xf8) == (jint) 0xf0) {
    codePoint = b0 & (jint) 0x07;
    byteCount = 4;
    min = (jint) 0x10000;
  }
  else {
    [self skipWithLong:1];
    return OkioBuffer_REPLACEMENT_CHARACTER;
  }
  if (size_ < byteCount) {
    @throw new_JavaIoEOFException_initWithNSString_(JreStrcat("$I$J$$C", @"size < ", byteCount, @": ", size_, @" (to read code point prefixed 0x", JavaLangInteger_toHexStringWithInt_(b0), ')'));
  }
  for (jint i = 1; i < byteCount; i++) {
    jbyte b = [self getByteWithLong:i];
    if ((b & (jint) 0xc0) == (jint) 0x80) {
      JreLShiftAssignInt(&codePoint, 6);
      codePoint |= b & (jint) 0x3f;
    }
    else {
      [self skipWithLong:i];
      return OkioBuffer_REPLACEMENT_CHARACTER;
    }
  }
  [self skipWithLong:byteCount];
  if (codePoint > (jint) 0x10ffff) {
    return OkioBuffer_REPLACEMENT_CHARACTER;
  }
  if (codePoint >= (jint) 0xd800 && codePoint <= (jint) 0xdfff) {
    return OkioBuffer_REPLACEMENT_CHARACTER;
  }
  if (codePoint < min) {
    return OkioBuffer_REPLACEMENT_CHARACTER;
  }
  return codePoint;
}

- (IOSByteArray *)readByteArray {
  @try {
    return [self readByteArrayWithLong:size_];
  }
  @catch (JavaIoEOFException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

- (IOSByteArray *)readByteArrayWithLong:(jlong)byteCount {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, 0, byteCount);
  if (byteCount > JavaLangInteger_MAX_VALUE) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"byteCount > Integer.MAX_VALUE: ", byteCount));
  }
  IOSByteArray *result = [IOSByteArray newArrayWithLength:(jint) byteCount];
  [self readFullyWithByteArray:result];
  return result;
}

- (jint)readWithByteArray:(IOSByteArray *)sink {
  return [self readWithByteArray:sink withInt:0 withInt:((IOSByteArray *) nil_chk(sink))->size_];
}

- (void)readFullyWithByteArray:(IOSByteArray *)sink {
  jint offset = 0;
  while (offset < ((IOSByteArray *) nil_chk(sink))->size_) {
    jint read = [self readWithByteArray:sink withInt:offset withInt:sink->size_ - offset];
    if (read == -1) @throw new_JavaIoEOFException_init();
    offset += read;
  }
}

- (jint)readWithByteArray:(IOSByteArray *)sink
                  withInt:(jint)offset
                  withInt:(jint)byteCount {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(((IOSByteArray *) nil_chk(sink))->size_, offset, byteCount);
  OkioSegment *s = head_;
  if (s == nil) return -1;
  jint toCopy = JavaLangMath_minWithInt_withInt_(byteCount, s->limit_ - s->pos_);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(s->data_, s->pos_, sink, offset, toCopy);
  s->pos_ += toCopy;
  size_ -= toCopy;
  if (s->pos_ == s->limit_) {
    head_ = [s pop];
    OkioSegmentPool_recycleWithOkioSegment_(s);
  }
  return toCopy;
}

- (void)clear {
  @try {
    [self skipWithLong:size_];
  }
  @catch (JavaIoEOFException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

- (void)skipWithLong:(jlong)byteCount {
  while (byteCount > 0) {
    if (head_ == nil) @throw new_JavaIoEOFException_init();
    jint toSkip = (jint) JavaLangMath_minWithLong_withLong_(byteCount, head_->limit_ - head_->pos_);
    size_ -= toSkip;
    byteCount -= toSkip;
    ((OkioSegment *) nil_chk(head_))->pos_ += toSkip;
    if (head_->pos_ == head_->limit_) {
      OkioSegment *toRecycle = head_;
      head_ = [toRecycle pop];
      OkioSegmentPool_recycleWithOkioSegment_(toRecycle);
    }
  }
}

- (OkioBuffer *)writeWithOkioByteString:(OkioByteString *)byteString {
  if (byteString == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"byteString == null");
  [byteString writeWithOkioBuffer:self];
  return self;
}

- (OkioBuffer *)writeUtf8WithNSString:(NSString *)string {
  return [self writeUtf8WithNSString:string withInt:0 withInt:((jint) [((NSString *) nil_chk(string)) length])];
}

- (OkioBuffer *)writeUtf8WithNSString:(NSString *)string
                              withInt:(jint)beginIndex
                              withInt:(jint)endIndex {
  if (string == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"string == null");
  if (beginIndex < 0) @throw new_JavaLangIllegalAccessError_initWithNSString_(JreStrcat("$I", @"beginIndex < 0: ", beginIndex));
  if (endIndex < beginIndex) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I$I", @"endIndex < beginIndex: ", endIndex, @" < ", beginIndex));
  }
  if (endIndex > ((jint) [string length])) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I$I", @"endIndex > string.length: ", endIndex, @" > ", ((jint) [string length])));
  }
  for (jint i = beginIndex; i < endIndex; ) {
    jint c = [string charAtWithInt:i];
    if (c < (jint) 0x80) {
      OkioSegment *tail = [self writableSegmentWithInt:1];
      IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
      jint segmentOffset = tail->limit_ - i;
      jint runLimit = JavaLangMath_minWithInt_withInt_(endIndex, OkioSegment_SIZE - segmentOffset);
      *IOSByteArray_GetRef(nil_chk(data), segmentOffset + i++) = (jbyte) c;
      while (i < runLimit) {
        c = [string charAtWithInt:i];
        if (c >= (jint) 0x80) break;
        *IOSByteArray_GetRef(data, segmentOffset + i++) = (jbyte) c;
      }
      jint runSize = i + segmentOffset - tail->limit_;
      tail->limit_ += runSize;
      size_ += runSize;
    }
    else if (c < (jint) 0x800) {
      (void) [self writeByteWithInt:(JreRShift32(c, 6)) | (jint) 0xc0];
      (void) [self writeByteWithInt:(c & (jint) 0x3f) | (jint) 0x80];
      i++;
    }
    else if (c < (jint) 0xd800 || c > (jint) 0xdfff) {
      (void) [self writeByteWithInt:(JreRShift32(c, 12)) | (jint) 0xe0];
      (void) [self writeByteWithInt:((JreRShift32(c, 6)) & (jint) 0x3f) | (jint) 0x80];
      (void) [self writeByteWithInt:(c & (jint) 0x3f) | (jint) 0x80];
      i++;
    }
    else {
      jint low = i + 1 < endIndex ? [string charAtWithInt:i + 1] : 0;
      if (c > (jint) 0xdbff || low < (jint) 0xdc00 || low > (jint) 0xdfff) {
        (void) [self writeByteWithInt:'?'];
        i++;
        continue;
      }
      jint codePoint = (jint) 0x010000 + ((JreLShift32((c & ~(jint) 0xd800), 10)) | (low & ~(jint) 0xdc00));
      (void) [self writeByteWithInt:(JreRShift32(codePoint, 18)) | (jint) 0xf0];
      (void) [self writeByteWithInt:((JreRShift32(codePoint, 12)) & (jint) 0x3f) | (jint) 0x80];
      (void) [self writeByteWithInt:((JreRShift32(codePoint, 6)) & (jint) 0x3f) | (jint) 0x80];
      (void) [self writeByteWithInt:(codePoint & (jint) 0x3f) | (jint) 0x80];
      i += 2;
    }
  }
  return self;
}

- (OkioBuffer *)writeUtf8CodePointWithInt:(jint)codePoint {
  if (codePoint < (jint) 0x80) {
    (void) [self writeByteWithInt:codePoint];
  }
  else if (codePoint < (jint) 0x800) {
    (void) [self writeByteWithInt:(JreRShift32(codePoint, 6)) | (jint) 0xc0];
    (void) [self writeByteWithInt:(codePoint & (jint) 0x3f) | (jint) 0x80];
  }
  else if (codePoint < (jint) 0x10000) {
    if (codePoint >= (jint) 0xd800 && codePoint <= (jint) 0xdfff) {
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"Unexpected code point: ", JavaLangInteger_toHexStringWithInt_(codePoint)));
    }
    (void) [self writeByteWithInt:(JreRShift32(codePoint, 12)) | (jint) 0xe0];
    (void) [self writeByteWithInt:((JreRShift32(codePoint, 6)) & (jint) 0x3f) | (jint) 0x80];
    (void) [self writeByteWithInt:(codePoint & (jint) 0x3f) | (jint) 0x80];
  }
  else if (codePoint <= (jint) 0x10ffff) {
    (void) [self writeByteWithInt:(JreRShift32(codePoint, 18)) | (jint) 0xf0];
    (void) [self writeByteWithInt:((JreRShift32(codePoint, 12)) & (jint) 0x3f) | (jint) 0x80];
    (void) [self writeByteWithInt:((JreRShift32(codePoint, 6)) & (jint) 0x3f) | (jint) 0x80];
    (void) [self writeByteWithInt:(codePoint & (jint) 0x3f) | (jint) 0x80];
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"Unexpected code point: ", JavaLangInteger_toHexStringWithInt_(codePoint)));
  }
  return self;
}

- (OkioBuffer *)writeStringWithNSString:(NSString *)string
              withJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset {
  return [self writeStringWithNSString:string withInt:0 withInt:((jint) [((NSString *) nil_chk(string)) length]) withJavaNioCharsetCharset:charset];
}

- (OkioBuffer *)writeStringWithNSString:(NSString *)string
                                withInt:(jint)beginIndex
                                withInt:(jint)endIndex
              withJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset {
  if (string == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"string == null");
  if (beginIndex < 0) @throw new_JavaLangIllegalAccessError_initWithNSString_(JreStrcat("$I", @"beginIndex < 0: ", beginIndex));
  if (endIndex < beginIndex) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I$I", @"endIndex < beginIndex: ", endIndex, @" < ", beginIndex));
  }
  if (endIndex > ((jint) [string length])) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I$I", @"endIndex > string.length: ", endIndex, @" > ", ((jint) [string length])));
  }
  if (charset == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"charset == null");
  if ([charset isEqual:JreLoadStatic(OkioUtil, UTF_8)]) return [self writeUtf8WithNSString:string];
  IOSByteArray *data = [((NSString *) nil_chk([string substring:beginIndex endIndex:endIndex])) getBytesWithCharset:charset];
  return [self writeWithByteArray:data withInt:0 withInt:((IOSByteArray *) nil_chk(data))->size_];
}

- (OkioBuffer *)writeWithByteArray:(IOSByteArray *)source {
  if (source == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == null");
  return [self writeWithByteArray:source withInt:0 withInt:source->size_];
}

- (OkioBuffer *)writeWithByteArray:(IOSByteArray *)source
                           withInt:(jint)offset
                           withInt:(jint)byteCount {
  if (source == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == null");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(source->size_, offset, byteCount);
  jint limit = offset + byteCount;
  while (offset < limit) {
    OkioSegment *tail = [self writableSegmentWithInt:1];
    jint toCopy = JavaLangMath_minWithInt_withInt_(limit - offset, OkioSegment_SIZE - ((OkioSegment *) nil_chk(tail))->limit_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(source, offset, tail->data_, tail->limit_, toCopy);
    offset += toCopy;
    tail->limit_ += toCopy;
  }
  size_ += byteCount;
  return self;
}

- (jlong)writeAllWithOkioSource:(id<OkioSource>)source {
  if (source == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == null");
  jlong totalBytesRead = 0;
  for (jlong readCount; (readCount = [source readWithOkioBuffer:self withLong:OkioSegment_SIZE]) != -1; ) {
    totalBytesRead += readCount;
  }
  return totalBytesRead;
}

- (id<OkioBufferedSink>)writeWithOkioSource:(id<OkioSource>)source
                                   withLong:(jlong)byteCount {
  while (byteCount > 0) {
    jlong read = [((id<OkioSource>) nil_chk(source)) readWithOkioBuffer:self withLong:byteCount];
    if (read == -1) @throw new_JavaIoEOFException_init();
    byteCount -= read;
  }
  return self;
}

- (OkioBuffer *)writeByteWithInt:(jint)b {
  OkioSegment *tail = [self writableSegmentWithInt:1];
  *IOSByteArray_GetRef(nil_chk(((OkioSegment *) nil_chk(tail))->data_), tail->limit_++) = (jbyte) b;
  size_ += 1;
  return self;
}

- (OkioBuffer *)writeShortWithInt:(jint)s {
  OkioSegment *tail = [self writableSegmentWithInt:2];
  IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
  jint limit = tail->limit_;
  *IOSByteArray_GetRef(nil_chk(data), limit++) = (jbyte) ((JreURShift32(s, 8)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) (s & (jint) 0xff);
  tail->limit_ = limit;
  size_ += 2;
  return self;
}

- (OkioBuffer *)writeShortLeWithInt:(jint)s {
  return [self writeShortWithInt:OkioUtil_reverseBytesShortWithShort_((jshort) s)];
}

- (OkioBuffer *)writeIntWithInt:(jint)i {
  OkioSegment *tail = [self writableSegmentWithInt:4];
  IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
  jint limit = tail->limit_;
  *IOSByteArray_GetRef(nil_chk(data), limit++) = (jbyte) ((JreURShift32(i, 24)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift32(i, 16)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift32(i, 8)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) (i & (jint) 0xff);
  tail->limit_ = limit;
  size_ += 4;
  return self;
}

- (OkioBuffer *)writeIntLeWithInt:(jint)i {
  return [self writeIntWithInt:OkioUtil_reverseBytesIntWithInt_(i)];
}

- (OkioBuffer *)writeLongWithLong:(jlong)v {
  OkioSegment *tail = [self writableSegmentWithInt:8];
  IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
  jint limit = tail->limit_;
  *IOSByteArray_GetRef(nil_chk(data), limit++) = (jbyte) ((JreURShift64(v, 56LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 48LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 40LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 32LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 24LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 16LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 8LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) (v & (jint) 0xff);
  tail->limit_ = limit;
  size_ += 8;
  return self;
}

- (OkioBuffer *)writeLongLeWithLong:(jlong)v {
  return [self writeLongWithLong:OkioUtil_reverseBytesLongWithLong_(v)];
}

- (OkioBuffer *)writeDecimalLongWithLong:(jlong)v {
  if (v == 0) {
    return [self writeByteWithInt:'0'];
  }
  jboolean negative = false;
  if (v < 0) {
    v = -v;
    if (v < 0) {
      return [self writeUtf8WithNSString:@"-9223372036854775808"];
    }
    negative = true;
  }
  jint width = v < 100000000LL ? v < 10000LL ? v < 100LL ? v < 10LL ? 1 : 2 : v < 1000LL ? 3 : 4 : v < 1000000LL ? v < 100000LL ? 5 : 6 : v < 10000000LL ? 7 : 8 : v < 1000000000000LL ? v < 10000000000LL ? v < 1000000000LL ? 9 : 10 : v < 100000000000LL ? 11 : 12 : v < 1000000000000000LL ? v < 10000000000000LL ? 13 : v < 100000000000000LL ? 14 : 15 : v < 100000000000000000LL ? v < 10000000000000000LL ? 16 : 17 : v < 1000000000000000000LL ? 18 : 19;
  if (negative) {
    ++width;
  }
  OkioSegment *tail = [self writableSegmentWithInt:width];
  IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
  jint pos = tail->limit_ + width;
  while (v != 0) {
    jint digit = (jint) (v % 10);
    *IOSByteArray_GetRef(nil_chk(data), --pos) = IOSByteArray_Get(nil_chk(OkioBuffer_DIGITS), digit);
    v /= 10;
  }
  if (negative) {
    *IOSByteArray_GetRef(nil_chk(data), --pos) = '-';
  }
  tail->limit_ += width;
  self->size_ += width;
  return self;
}

- (OkioBuffer *)writeHexadecimalUnsignedLongWithLong:(jlong)v {
  if (v == 0) {
    return [self writeByteWithInt:'0'];
  }
  jint width = JavaLangLong_numberOfTrailingZerosWithLong_(JavaLangLong_highestOneBitWithLong_(v)) / 4 + 1;
  OkioSegment *tail = [self writableSegmentWithInt:width];
  IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
  for (jint pos = tail->limit_ + width - 1, start = tail->limit_; pos >= start; pos--) {
    *IOSByteArray_GetRef(nil_chk(data), pos) = IOSByteArray_Get(nil_chk(OkioBuffer_DIGITS), (jint) (v & (jint) 0xF));
    JreURShiftAssignLong(&v, 4);
  }
  tail->limit_ += width;
  size_ += width;
  return self;
}

- (OkioSegment *)writableSegmentWithInt:(jint)minimumCapacity {
  if (minimumCapacity < 1 || minimumCapacity > OkioSegment_SIZE) @throw new_JavaLangIllegalArgumentException_init();
  if (head_ == nil) {
    head_ = OkioSegmentPool_take();
    return ((OkioSegment *) nil_chk(head_))->next_ = head_->prev_ = head_;
  }
  OkioSegment *tail = head_->prev_;
  if (((OkioSegment *) nil_chk(tail))->limit_ + minimumCapacity > OkioSegment_SIZE || !tail->owner_) {
    tail = [tail pushWithOkioSegment:OkioSegmentPool_take()];
  }
  return tail;
}

- (void)writeWithOkioBuffer:(OkioBuffer *)source
                   withLong:(jlong)byteCount {
  if (source == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == null");
  if (source == self) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == this");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(source->size_, 0, byteCount);
  while (byteCount > 0) {
    if (byteCount < (((OkioSegment *) nil_chk(source->head_))->limit_ - source->head_->pos_)) {
      OkioSegment *tail = head_ != nil ? head_->prev_ : nil;
      if (tail != nil && tail->owner_ && (byteCount + tail->limit_ - (tail->shared_ ? 0 : tail->pos_) <= OkioSegment_SIZE)) {
        [source->head_ writeToWithOkioSegment:tail withInt:(jint) byteCount];
        source->size_ -= byteCount;
        size_ += byteCount;
        return;
      }
      else {
        source->head_ = [source->head_ splitWithInt:(jint) byteCount];
      }
    }
    OkioSegment *segmentToMove = source->head_;
    jlong movedByteCount = ((OkioSegment *) nil_chk(segmentToMove))->limit_ - segmentToMove->pos_;
    source->head_ = [segmentToMove pop];
    if (head_ == nil) {
      head_ = segmentToMove;
      head_->next_ = head_->prev_ = head_;
    }
    else {
      OkioSegment *tail = head_->prev_;
      tail = [((OkioSegment *) nil_chk(tail)) pushWithOkioSegment:segmentToMove];
      [((OkioSegment *) nil_chk(tail)) compact];
    }
    source->size_ -= movedByteCount;
    size_ += movedByteCount;
    byteCount -= movedByteCount;
  }
}

- (jlong)readWithOkioBuffer:(OkioBuffer *)sink
                   withLong:(jlong)byteCount {
  if (sink == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"sink == null");
  if (byteCount < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"byteCount < 0: ", byteCount));
  if (size_ == 0) return -1LL;
  if (byteCount > size_) byteCount = size_;
  [sink writeWithOkioBuffer:self withLong:byteCount];
  return byteCount;
}

- (jlong)indexOfWithByte:(jbyte)b {
  return [self indexOfWithByte:b withLong:0];
}

- (jlong)indexOfWithByte:(jbyte)b
                withLong:(jlong)fromIndex {
  if (fromIndex < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"fromIndex < 0");
  OkioSegment *s;
  jlong offset;
  findSegmentAndOffset: {
    s = head_;
    if (s == nil) {
      return -1LL;
    }
    else if (size_ - fromIndex < fromIndex) {
      offset = size_;
      while (offset > fromIndex) {
        s = s->prev_;
        offset -= (((OkioSegment *) nil_chk(s))->limit_ - s->pos_);
      }
    }
    else {
      offset = 0LL;
      for (jlong nextOffset; (nextOffset = offset + (((OkioSegment *) nil_chk(s))->limit_ - s->pos_)) < fromIndex; ) {
        s = s->next_;
        offset = nextOffset;
      }
    }
  }
  while (offset < size_) {
    IOSByteArray *data = ((OkioSegment *) nil_chk(s))->data_;
    for (jint pos = (jint) (s->pos_ + fromIndex - offset), limit = s->limit_; pos < limit; pos++) {
      if (IOSByteArray_Get(nil_chk(data), pos) == b) {
        return pos - s->pos_ + offset;
      }
    }
    offset += (s->limit_ - s->pos_);
    fromIndex = offset;
    s = s->next_;
  }
  return -1LL;
}

- (jlong)indexOfWithOkioByteString:(OkioByteString *)bytes {
  return [self indexOfWithOkioByteString:bytes withLong:0];
}

- (jlong)indexOfWithOkioByteString:(OkioByteString *)bytes
                          withLong:(jlong)fromIndex {
  if ([((OkioByteString *) nil_chk(bytes)) size] == 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"bytes is empty");
  if (fromIndex < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"fromIndex < 0");
  OkioSegment *s;
  jlong offset;
  findSegmentAndOffset: {
    s = head_;
    if (s == nil) {
      return -1LL;
    }
    else if (size_ - fromIndex < fromIndex) {
      offset = size_;
      while (offset > fromIndex) {
        s = s->prev_;
        offset -= (((OkioSegment *) nil_chk(s))->limit_ - s->pos_);
      }
    }
    else {
      offset = 0LL;
      for (jlong nextOffset; (nextOffset = offset + (((OkioSegment *) nil_chk(s))->limit_ - s->pos_)) < fromIndex; ) {
        s = s->next_;
        offset = nextOffset;
      }
    }
  }
  jbyte b0 = [bytes getByteWithInt:0];
  jint bytesSize = [bytes size];
  jlong resultLimit = size_ - bytesSize + 1;
  while (offset < resultLimit) {
    IOSByteArray *data = ((OkioSegment *) nil_chk(s))->data_;
    jint segmentLimit = (jint) JavaLangMath_minWithLong_withLong_(s->limit_, s->pos_ + resultLimit - offset);
    for (jint pos = (jint) (s->pos_ + fromIndex - offset); pos < segmentLimit; pos++) {
      if (IOSByteArray_Get(nil_chk(data), pos) == b0 && OkioBuffer_rangeEqualsWithOkioSegment_withInt_withOkioByteString_withInt_withInt_(self, s, pos + 1, bytes, 1, bytesSize)) {
        return pos - s->pos_ + offset;
      }
    }
    offset += (s->limit_ - s->pos_);
    fromIndex = offset;
    s = s->next_;
  }
  return -1LL;
}

- (jlong)indexOfElementWithOkioByteString:(OkioByteString *)targetBytes {
  return [self indexOfElementWithOkioByteString:targetBytes withLong:0];
}

- (jlong)indexOfElementWithOkioByteString:(OkioByteString *)targetBytes
                                 withLong:(jlong)fromIndex {
  if (fromIndex < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"fromIndex < 0");
  OkioSegment *s;
  jlong offset;
  findSegmentAndOffset: {
    s = head_;
    if (s == nil) {
      return -1LL;
    }
    else if (size_ - fromIndex < fromIndex) {
      offset = size_;
      while (offset > fromIndex) {
        s = s->prev_;
        offset -= (((OkioSegment *) nil_chk(s))->limit_ - s->pos_);
      }
    }
    else {
      offset = 0LL;
      for (jlong nextOffset; (nextOffset = offset + (((OkioSegment *) nil_chk(s))->limit_ - s->pos_)) < fromIndex; ) {
        s = s->next_;
        offset = nextOffset;
      }
    }
  }
  if ([((OkioByteString *) nil_chk(targetBytes)) size] == 2) {
    jbyte b0 = [targetBytes getByteWithInt:0];
    jbyte b1 = [targetBytes getByteWithInt:1];
    while (offset < size_) {
      IOSByteArray *data = ((OkioSegment *) nil_chk(s))->data_;
      for (jint pos = (jint) (s->pos_ + fromIndex - offset), limit = s->limit_; pos < limit; pos++) {
        jint b = IOSByteArray_Get(nil_chk(data), pos);
        if (b == b0 || b == b1) {
          return pos - s->pos_ + offset;
        }
      }
      offset += (s->limit_ - s->pos_);
      fromIndex = offset;
      s = s->next_;
    }
  }
  else {
    IOSByteArray *targetByteArray = [targetBytes internalArray];
    while (offset < size_) {
      IOSByteArray *data = ((OkioSegment *) nil_chk(s))->data_;
      for (jint pos = (jint) (s->pos_ + fromIndex - offset), limit = s->limit_; pos < limit; pos++) {
        jint b = IOSByteArray_Get(nil_chk(data), pos);
        {
          IOSByteArray *a__ = targetByteArray;
          jbyte const *b__ = ((IOSByteArray *) nil_chk(a__))->buffer_;
          jbyte const *e__ = b__ + a__->size_;
          while (b__ < e__) {
            jbyte t = *b__++;
            if (b == t) return pos - s->pos_ + offset;
          }
        }
      }
      offset += (s->limit_ - s->pos_);
      fromIndex = offset;
      s = s->next_;
    }
  }
  return -1LL;
}

- (jboolean)rangeEqualsWithLong:(jlong)offset
             withOkioByteString:(OkioByteString *)bytes {
  return [self rangeEqualsWithLong:offset withOkioByteString:bytes withInt:0 withInt:[((OkioByteString *) nil_chk(bytes)) size]];
}

- (jboolean)rangeEqualsWithLong:(jlong)offset
             withOkioByteString:(OkioByteString *)bytes
                        withInt:(jint)bytesOffset
                        withInt:(jint)byteCount {
  if (offset < 0 || bytesOffset < 0 || byteCount < 0 || size_ - offset < byteCount || [((OkioByteString *) nil_chk(bytes)) size] - bytesOffset < byteCount) {
    return false;
  }
  for (jint i = 0; i < byteCount; i++) {
    if ([self getByteWithLong:offset + i] != [((OkioByteString *) nil_chk(bytes)) getByteWithInt:bytesOffset + i]) {
      return false;
    }
  }
  return true;
}

- (jboolean)rangeEqualsWithOkioSegment:(OkioSegment *)segment
                               withInt:(jint)segmentPos
                    withOkioByteString:(OkioByteString *)bytes
                               withInt:(jint)bytesOffset
                               withInt:(jint)bytesLimit {
  return OkioBuffer_rangeEqualsWithOkioSegment_withInt_withOkioByteString_withInt_withInt_(self, segment, segmentPos, bytes, bytesOffset, bytesLimit);
}

- (void)flush {
}

- (void)close {
}

- (OkioTimeout *)timeout {
  return JreLoadStatic(OkioTimeout, NONE);
}

- (id<JavaUtilList>)segmentSizes {
  if (head_ == nil) return JavaUtilCollections_emptyList();
  id<JavaUtilList> result = new_JavaUtilArrayList_init();
  [result addWithId:JavaLangInteger_valueOfWithInt_(((OkioSegment *) nil_chk(head_))->limit_ - head_->pos_)];
  for (OkioSegment *s = ((OkioSegment *) nil_chk(head_))->next_; s != head_; s = s->next_) {
    [result addWithId:JavaLangInteger_valueOfWithInt_(((OkioSegment *) nil_chk(s))->limit_ - s->pos_)];
  }
  return result;
}

- (OkioByteString *)md5 {
  return OkioBuffer_digestWithNSString_(self, @"MD5");
}

- (OkioByteString *)sha1 {
  return OkioBuffer_digestWithNSString_(self, @"SHA-1");
}

- (OkioByteString *)sha256 {
  return OkioBuffer_digestWithNSString_(self, @"SHA-256");
}

- (OkioByteString *)digestWithNSString:(NSString *)algorithm {
  return OkioBuffer_digestWithNSString_(self, algorithm);
}

- (jboolean)isEqual:(id)o {
  if (self == o) return true;
  if (!([o isKindOfClass:[OkioBuffer class]])) return false;
  OkioBuffer *that = (OkioBuffer *) cast_chk(o, [OkioBuffer class]);
  if (size_ != ((OkioBuffer *) nil_chk(that))->size_) return false;
  if (size_ == 0) return true;
  OkioSegment *sa = self->head_;
  OkioSegment *sb = that->head_;
  jint posA = ((OkioSegment *) nil_chk(sa))->pos_;
  jint posB = ((OkioSegment *) nil_chk(sb))->pos_;
  for (jlong pos = 0, count; pos < size_; pos += count) {
    count = JavaLangMath_minWithInt_withInt_(sa->limit_ - posA, sb->limit_ - posB);
    for (jint i = 0; i < count; i++) {
      if (IOSByteArray_Get(nil_chk(sa->data_), posA++) != IOSByteArray_Get(sb->data_, posB++)) return false;
    }
    if (posA == sa->limit_) {
      sa = sa->next_;
      posA = ((OkioSegment *) nil_chk(sa))->pos_;
    }
    if (posB == sb->limit_) {
      sb = sb->next_;
      posB = ((OkioSegment *) nil_chk(sb))->pos_;
    }
  }
  return true;
}

- (NSUInteger)hash {
  OkioSegment *s = head_;
  if (s == nil) return 0;
  jint result = 1;
  do {
    for (jint pos = ((OkioSegment *) nil_chk(s))->pos_, limit = s->limit_; pos < limit; pos++) {
      result = 31 * result + IOSByteArray_Get(nil_chk(s->data_), pos);
    }
    s = s->next_;
  }
  while (s != head_);
  return result;
}

- (NSString *)description {
  return [((OkioByteString *) nil_chk([self snapshot])) description];
}

- (OkioBuffer *)clone {
  OkioBuffer *result = new_OkioBuffer_init();
  if (size_ == 0) return result;
  result->head_ = new_OkioSegment_initWithOkioSegment_(head_);
  result->head_->next_ = result->head_->prev_ = result->head_;
  for (OkioSegment *s = head_->next_; s != head_; s = ((OkioSegment *) nil_chk(s))->next_) {
    (void) [((OkioSegment *) nil_chk(((OkioSegment *) nil_chk(result->head_))->prev_)) pushWithOkioSegment:new_OkioSegment_initWithOkioSegment_(s)];
  }
  result->size_ = size_;
  return result;
}

- (OkioByteString *)snapshot {
  if (size_ > JavaLangInteger_MAX_VALUE) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"size > Integer.MAX_VALUE: ", size_));
  }
  return [self snapshotWithInt:(jint) size_];
}

- (OkioByteString *)snapshotWithInt:(jint)byteCount {
  if (byteCount == 0) return JreLoadStatic(OkioByteString, EMPTY);
  return new_OkioSegmentedByteString_initWithOkioBuffer_withInt_(self, byteCount);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { "size", "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { "buffer", "LOkioBuffer;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "outputStream", "LJavaIoOutputStream;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "emitCompleteSegments", "LOkioBuffer;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "emit", "LOkioBufferedSink;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "exhausted", "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { "requireWithLong:", "V", 0x1, 0, 1, 2, -1, -1, -1 },
    { "requestWithLong:", "Z", 0x1, 3, 1, -1, -1, -1, -1 },
    { "inputStream", "LJavaIoInputStream;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "copyToWithJavaIoOutputStream:", "LOkioBuffer;", 0x1, 4, 5, 6, -1, -1, -1 },
    { "copyToWithJavaIoOutputStream:withLong:withLong:", "LOkioBuffer;", 0x1, 4, 7, 6, -1, -1, -1 },
    { "copyToWithOkioBuffer:withLong:withLong:", "LOkioBuffer;", 0x1, 4, 8, -1, -1, -1, -1 },
    { "writeToWithJavaIoOutputStream:", "LOkioBuffer;", 0x1, 9, 5, 6, -1, -1, -1 },
    { "writeToWithJavaIoOutputStream:withLong:", "LOkioBuffer;", 0x1, 9, 10, 6, -1, -1, -1 },
    { "readFromWithJavaIoInputStream:", "LOkioBuffer;", 0x1, 11, 12, 6, -1, -1, -1 },
    { "readFromWithJavaIoInputStream:withLong:", "LOkioBuffer;", 0x1, 11, 13, 6, -1, -1, -1 },
    { "readFromWithJavaIoInputStream:withLong:withBoolean:", "V", 0x2, 11, 14, 6, -1, -1, -1 },
    { "completeSegmentByteCount", "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readByte", "B", 0x1, -1, -1, -1, -1, -1, -1 },
    { "getByteWithLong:", "B", 0x1, 15, 1, -1, -1, -1, -1 },
    { "readShort", "S", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readInt", "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readLong", "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readShortLe", "S", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readIntLe", "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readLongLe", "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readDecimalLong", "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readHexadecimalUnsignedLong", "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readByteString", "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readByteStringWithLong:", "LOkioByteString;", 0x1, 16, 1, 2, -1, -1, -1 },
    { "selectWithOkioOptions:", "I", 0x1, 17, 18, -1, -1, -1, -1 },
    { "selectPrefixWithOkioOptions:", "I", 0x0, 19, 18, -1, -1, -1, -1 },
    { "readFullyWithOkioBuffer:withLong:", "V", 0x1, 20, 21, 2, -1, -1, -1 },
    { "readAllWithOkioSink:", "J", 0x1, 22, 23, 6, -1, -1, -1 },
    { "readUtf8", "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readUtf8WithLong:", "LNSString;", 0x1, 24, 1, 2, -1, -1, -1 },
    { "readStringWithJavaNioCharsetCharset:", "LNSString;", 0x1, 25, 26, -1, -1, -1, -1 },
    { "readStringWithLong:withJavaNioCharsetCharset:", "LNSString;", 0x1, 25, 27, 2, -1, -1, -1 },
    { "readUtf8Line", "LNSString;", 0x1, -1, -1, 2, -1, -1, -1 },
    { "readUtf8LineStrict", "LNSString;", 0x1, -1, -1, 2, -1, -1, -1 },
    { "readUtf8LineWithLong:", "LNSString;", 0x0, 28, 1, 2, -1, -1, -1 },
    { "readUtf8CodePoint", "I", 0x1, -1, -1, 2, -1, -1, -1 },
    { "readByteArray", "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readByteArrayWithLong:", "[B", 0x1, 29, 1, 2, -1, -1, -1 },
    { "readWithByteArray:", "I", 0x1, 30, 31, -1, -1, -1, -1 },
    { "readFullyWithByteArray:", "V", 0x1, 20, 31, 2, -1, -1, -1 },
    { "readWithByteArray:withInt:withInt:", "I", 0x1, 30, 32, -1, -1, -1, -1 },
    { "clear", "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { "skipWithLong:", "V", 0x1, 33, 1, 2, -1, -1, -1 },
    { "writeWithOkioByteString:", "LOkioBuffer;", 0x1, 34, 35, -1, -1, -1, -1 },
    { "writeUtf8WithNSString:", "LOkioBuffer;", 0x1, 36, 37, -1, -1, -1, -1 },
    { "writeUtf8WithNSString:withInt:withInt:", "LOkioBuffer;", 0x1, 36, 38, -1, -1, -1, -1 },
    { "writeUtf8CodePointWithInt:", "LOkioBuffer;", 0x1, 39, 40, -1, -1, -1, -1 },
    { "writeStringWithNSString:withJavaNioCharsetCharset:", "LOkioBuffer;", 0x1, 41, 42, -1, -1, -1, -1 },
    { "writeStringWithNSString:withInt:withInt:withJavaNioCharsetCharset:", "LOkioBuffer;", 0x1, 41, 43, -1, -1, -1, -1 },
    { "writeWithByteArray:", "LOkioBuffer;", 0x1, 34, 31, -1, -1, -1, -1 },
    { "writeWithByteArray:withInt:withInt:", "LOkioBuffer;", 0x1, 34, 32, -1, -1, -1, -1 },
    { "writeAllWithOkioSource:", "J", 0x1, 44, 45, 6, -1, -1, -1 },
    { "writeWithOkioSource:withLong:", "LOkioBufferedSink;", 0x1, 34, 46, 6, -1, -1, -1 },
    { "writeByteWithInt:", "LOkioBuffer;", 0x1, 47, 40, -1, -1, -1, -1 },
    { "writeShortWithInt:", "LOkioBuffer;", 0x1, 48, 40, -1, -1, -1, -1 },
    { "writeShortLeWithInt:", "LOkioBuffer;", 0x1, 49, 40, -1, -1, -1, -1 },
    { "writeIntWithInt:", "LOkioBuffer;", 0x1, 50, 40, -1, -1, -1, -1 },
    { "writeIntLeWithInt:", "LOkioBuffer;", 0x1, 51, 40, -1, -1, -1, -1 },
    { "writeLongWithLong:", "LOkioBuffer;", 0x1, 52, 1, -1, -1, -1, -1 },
    { "writeLongLeWithLong:", "LOkioBuffer;", 0x1, 53, 1, -1, -1, -1, -1 },
    { "writeDecimalLongWithLong:", "LOkioBuffer;", 0x1, 54, 1, -1, -1, -1, -1 },
    { "writeHexadecimalUnsignedLongWithLong:", "LOkioBuffer;", 0x1, 55, 1, -1, -1, -1, -1 },
    { "writableSegmentWithInt:", "LOkioSegment;", 0x0, 56, 40, -1, -1, -1, -1 },
    { "writeWithOkioBuffer:withLong:", "V", 0x1, 34, 21, -1, -1, -1, -1 },
    { "readWithOkioBuffer:withLong:", "J", 0x1, 30, 21, -1, -1, -1, -1 },
    { "indexOfWithByte:", "J", 0x1, 57, 58, -1, -1, -1, -1 },
    { "indexOfWithByte:withLong:", "J", 0x1, 57, 59, -1, -1, -1, -1 },
    { "indexOfWithOkioByteString:", "J", 0x1, 57, 35, 6, -1, -1, -1 },
    { "indexOfWithOkioByteString:withLong:", "J", 0x1, 57, 60, 6, -1, -1, -1 },
    { "indexOfElementWithOkioByteString:", "J", 0x1, 61, 35, -1, -1, -1, -1 },
    { "indexOfElementWithOkioByteString:withLong:", "J", 0x1, 61, 60, -1, -1, -1, -1 },
    { "rangeEqualsWithLong:withOkioByteString:", "Z", 0x1, 62, 63, -1, -1, -1, -1 },
    { "rangeEqualsWithLong:withOkioByteString:withInt:withInt:", "Z", 0x1, 62, 64, -1, -1, -1, -1 },
    { "rangeEqualsWithOkioSegment:withInt:withOkioByteString:withInt:withInt:", "Z", 0x2, 62, 65, -1, -1, -1, -1 },
    { "flush", "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { "close", "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { "timeout", "LOkioTimeout;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "segmentSizes", "LJavaUtilList;", 0x0, -1, -1, -1, 66, -1, -1 },
    { "md5", "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "sha1", "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "sha256", "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "digestWithNSString:", "LOkioByteString;", 0x2, 67, 37, -1, -1, -1, -1 },
    { "isEqual:", "Z", 0x1, 68, 69, -1, -1, -1, -1 },
    { "hash", "I", 0x1, 70, -1, -1, -1, -1, -1 },
    { "description", "LNSString;", 0x1, 71, -1, -1, -1, -1, -1 },
    { "clone", "LOkioBuffer;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "snapshot", "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "snapshotWithInt:", "LOkioByteString;", 0x1, 72, 40, -1, -1, -1, -1 },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "DIGITS", "[B", .constantValue.asLong = 0, 0x1a, -1, 73, -1, -1 },
    { "REPLACEMENT_CHARACTER", "I", .constantValue.asInt = OkioBuffer_REPLACEMENT_CHARACTER, 0x18, -1, -1, -1, -1 },
    { "head_", "LOkioSegment;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "size_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "require", "J", "LJavaIoEOFException;", "request", "copyTo", "LJavaIoOutputStream;", "LJavaIoIOException;", "LJavaIoOutputStream;JJ", "LOkioBuffer;JJ", "writeTo", "LJavaIoOutputStream;J", "readFrom", "LJavaIoInputStream;", "LJavaIoInputStream;J", "LJavaIoInputStream;JZ", "getByte", "readByteString", "select", "LOkioOptions;", "selectPrefix", "readFully", "LOkioBuffer;J", "readAll", "LOkioSink;", "readUtf8", "readString", "LJavaNioCharsetCharset;", "JLJavaNioCharsetCharset;", "readUtf8Line", "readByteArray", "read", "[B", "[BII", "skip", "write", "LOkioByteString;", "writeUtf8", "LNSString;", "LNSString;II", "writeUtf8CodePoint", "I", "writeString", "LNSString;LJavaNioCharsetCharset;", "LNSString;IILJavaNioCharsetCharset;", "writeAll", "LOkioSource;", "LOkioSource;J", "writeByte", "writeShort", "writeShortLe", "writeInt", "writeIntLe", "writeLong", "writeLongLe", "writeDecimalLong", "writeHexadecimalUnsignedLong", "writableSegment", "indexOf", "B", "BJ", "LOkioByteString;J", "indexOfElement", "rangeEquals", "JLOkioByteString;", "JLOkioByteString;II", "LOkioSegment;ILOkioByteString;II", "()Ljava/util/List<Ljava/lang/Integer;>;", "digest", "equals", "LNSObject;", "hashCode", "toString", "snapshot", &OkioBuffer_DIGITS };
  static const J2ObjcClassInfo _OkioBuffer = { "Buffer", "okio", ptrTable, methods, fields, 7, 0x11, 95, 4, -1, -1, -1, -1, -1 };
  return &_OkioBuffer;
}

- (id)copyWithZone:(NSZone *)zone {
  return [self clone];
}

+ (void)initialize {
  if (self == [OkioBuffer class]) {
    OkioBuffer_DIGITS = [IOSByteArray newArrayWithBytes:(jbyte[]){ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' } count:16];
    J2OBJC_SET_INITIALIZED(OkioBuffer)
  }
}

@end

void OkioBuffer_init(OkioBuffer *self) {
  NSObject_init(self);
}

OkioBuffer *new_OkioBuffer_init() {
  J2OBJC_NEW_IMPL(OkioBuffer, init)
}

OkioBuffer *create_OkioBuffer_init() {
  J2OBJC_CREATE_IMPL(OkioBuffer, init)
}

void OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(OkioBuffer *self, JavaIoInputStream *inArg, jlong byteCount, jboolean forever) {
  if (inArg == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"in == null");
  while (byteCount > 0 || forever) {
    OkioSegment *tail = [self writableSegmentWithInt:1];
    jint maxToCopy = (jint) JavaLangMath_minWithLong_withLong_(byteCount, OkioSegment_SIZE - ((OkioSegment *) nil_chk(tail))->limit_);
    jint bytesRead = [inArg readWithByteArray:tail->data_ withInt:tail->limit_ withInt:maxToCopy];
    if (bytesRead == -1) {
      if (forever) return;
      @throw new_JavaIoEOFException_init();
    }
    tail->limit_ += bytesRead;
    self->size_ += bytesRead;
    byteCount -= bytesRead;
  }
}

jboolean OkioBuffer_rangeEqualsWithOkioSegment_withInt_withOkioByteString_withInt_withInt_(OkioBuffer *self, OkioSegment *segment, jint segmentPos, OkioByteString *bytes, jint bytesOffset, jint bytesLimit) {
  jint segmentLimit = ((OkioSegment *) nil_chk(segment))->limit_;
  IOSByteArray *data = segment->data_;
  for (jint i = bytesOffset; i < bytesLimit; ) {
    if (segmentPos == segmentLimit) {
      segment = segment->next_;
      data = ((OkioSegment *) nil_chk(segment))->data_;
      segmentPos = segment->pos_;
      segmentLimit = segment->limit_;
    }
    if (IOSByteArray_Get(nil_chk(data), segmentPos) != [((OkioByteString *) nil_chk(bytes)) getByteWithInt:i]) {
      return false;
    }
    segmentPos++;
    i++;
  }
  return true;
}

OkioByteString *OkioBuffer_digestWithNSString_(OkioBuffer *self, NSString *algorithm) {
  @try {
    JavaSecurityMessageDigest *messageDigest = JavaSecurityMessageDigest_getInstanceWithNSString_(algorithm);
    [((JavaSecurityMessageDigest *) nil_chk(messageDigest)) updateWithByteArray:((OkioSegment *) nil_chk(self->head_))->data_ withInt:self->head_->pos_ withInt:self->head_->limit_ - self->head_->pos_];
    for (OkioSegment *s = ((OkioSegment *) nil_chk(self->head_))->next_; s != self->head_; s = s->next_) {
      [messageDigest updateWithByteArray:((OkioSegment *) nil_chk(s))->data_ withInt:s->pos_ withInt:s->limit_ - s->pos_];
    }
    return OkioByteString_ofWithByteArray_([messageDigest digest]);
  }
  @catch (JavaSecurityNoSuchAlgorithmException *e) {
    @throw new_JavaLangAssertionError_init();
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioBuffer)

@implementation OkioBuffer_$1

- (void)writeWithInt:(jint)b {
  (void) [this$0_ writeByteWithInt:(jbyte) b];
}

- (void)writeWithByteArray:(IOSByteArray *)data
                   withInt:(jint)offset
                   withInt:(jint)byteCount {
  (void) [this$0_ writeWithByteArray:data withInt:offset withInt:byteCount];
}

- (void)flush {
}

- (void)close {
}

- (NSString *)description {
  return JreStrcat("@$", this$0_, @".outputStream()");
}

- (instancetype)initWithOkioBuffer:(OkioBuffer *)outer$ {
  OkioBuffer_$1_initWithOkioBuffer_(self, outer$);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "writeWithInt:", "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { "writeWithByteArray:withInt:withInt:", "V", 0x1, 0, 2, -1, -1, -1, -1 },
    { "flush", "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { "close", "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { "description", "LNSString;", 0x1, 3, -1, -1, -1, -1, -1 },
    { "initWithOkioBuffer:", NULL, 0x0, -1, 4, -1, -1, -1, -1 },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LOkioBuffer;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "write", "I", "[BII", "toString", "LOkioBuffer;", "outputStream" };
  static const J2ObjcClassInfo _OkioBuffer_$1 = { "", "okio", ptrTable, methods, fields, 7, 0x8008, 6, 1, 4, -1, 5, -1, -1 };
  return &_OkioBuffer_$1;
}

@end

void OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer_$1 *self, OkioBuffer *outer$) {
  self->this$0_ = outer$;
  JavaIoOutputStream_init(self);
}

OkioBuffer_$1 *new_OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer *outer$) {
  J2OBJC_NEW_IMPL(OkioBuffer_$1, initWithOkioBuffer_, outer$)
}

OkioBuffer_$1 *create_OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer *outer$) {
  J2OBJC_CREATE_IMPL(OkioBuffer_$1, initWithOkioBuffer_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioBuffer_$1)

@implementation OkioBuffer_$2

- (jint)read {
  if (this$0_->size_ > 0) return [this$0_ readByte] & (jint) 0xff;
  return -1;
}

- (jint)readWithByteArray:(IOSByteArray *)sink
                  withInt:(jint)offset
                  withInt:(jint)byteCount {
  return [this$0_ readWithByteArray:sink withInt:offset withInt:byteCount];
}

- (jint)available {
  return (jint) JavaLangMath_minWithLong_withLong_(this$0_->size_, JavaLangInteger_MAX_VALUE);
}

- (void)close {
}

- (NSString *)description {
  return JreStrcat("@$", this$0_, @".inputStream()");
}

- (instancetype)initWithOkioBuffer:(OkioBuffer *)outer$ {
  OkioBuffer_$2_initWithOkioBuffer_(self, outer$);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "read", "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { "readWithByteArray:withInt:withInt:", "I", 0x1, 0, 1, -1, -1, -1, -1 },
    { "available", "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { "close", "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { "description", "LNSString;", 0x1, 2, -1, -1, -1, -1, -1 },
    { "initWithOkioBuffer:", NULL, 0x0, -1, 3, -1, -1, -1, -1 },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LOkioBuffer;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "read", "[BII", "toString", "LOkioBuffer;", "inputStream" };
  static const J2ObjcClassInfo _OkioBuffer_$2 = { "", "okio", ptrTable, methods, fields, 7, 0x8008, 6, 1, 3, -1, 4, -1, -1 };
  return &_OkioBuffer_$2;
}

@end

void OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer_$2 *self, OkioBuffer *outer$) {
  self->this$0_ = outer$;
  JavaIoInputStream_init(self);
}

OkioBuffer_$2 *new_OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer *outer$) {
  J2OBJC_NEW_IMPL(OkioBuffer_$2, initWithOkioBuffer_, outer$)
}

OkioBuffer_$2 *create_OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer *outer$) {
  J2OBJC_CREATE_IMPL(OkioBuffer_$2, initWithOkioBuffer_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioBuffer_$2)
