//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/okio-1.9.0-sources/okio/GzipSource.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/EOFException.h"
#include "java/io/IOException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/util/zip/CRC32.h"
#include "java/util/zip/Inflater.h"
#include "okio/Buffer.h"
#include "okio/BufferedSource.h"
#include "okio/GzipSource.h"
#include "okio/InflaterSource.h"
#include "okio/Okio.h"
#include "okio/Segment.h"
#include "okio/Source.h"
#include "okio/Timeout.h"

@interface OkioGzipSource () {
 @public
  /*!
   @brief The current section.
   Always progresses forward. 
   */
  jint section_;
  /*!
   @brief Our source should yield a GZIP header (which we consume directly), followed
 by deflated bytes (which we consume via an InflaterSource), followed by a
 GZIP trailer (which we also consume directly).
   */
  id<OkioBufferedSource> source_;
  /*!
   @brief The inflater used to decompress the deflated body.
   */
  JavaUtilZipInflater *inflater_;
  /*!
   @brief The inflater source takes care of moving data between compressed source and
 decompressed sink buffers.
   */
  OkioInflaterSource *inflaterSource_;
  /*!
   @brief Checksum used to check both the GZIP header and decompressed body.
   */
  JavaUtilZipCRC32 *crc_;
}

- (void)consumeHeader;

- (void)consumeTrailer;

/*!
 @brief Updates the CRC with the given bytes.
 */
- (void)updateCrcWithOkioBuffer:(OkioBuffer *)buffer
                       withLong:(jlong)offset
                       withLong:(jlong)byteCount;

- (void)checkEqualWithNSString:(NSString *)name
                       withInt:(jint)expected
                       withInt:(jint)actual;

@end

J2OBJC_FIELD_SETTER(OkioGzipSource, source_, id<OkioBufferedSource>)
J2OBJC_FIELD_SETTER(OkioGzipSource, inflater_, JavaUtilZipInflater *)
J2OBJC_FIELD_SETTER(OkioGzipSource, inflaterSource_, OkioInflaterSource *)
J2OBJC_FIELD_SETTER(OkioGzipSource, crc_, JavaUtilZipCRC32 *)

inline jbyte OkioGzipSource_get_FHCRC();
#define OkioGzipSource_FHCRC 1
J2OBJC_STATIC_FIELD_CONSTANT(OkioGzipSource, FHCRC, jbyte)

inline jbyte OkioGzipSource_get_FEXTRA();
#define OkioGzipSource_FEXTRA 2
J2OBJC_STATIC_FIELD_CONSTANT(OkioGzipSource, FEXTRA, jbyte)

inline jbyte OkioGzipSource_get_FNAME();
#define OkioGzipSource_FNAME 3
J2OBJC_STATIC_FIELD_CONSTANT(OkioGzipSource, FNAME, jbyte)

inline jbyte OkioGzipSource_get_FCOMMENT();
#define OkioGzipSource_FCOMMENT 4
J2OBJC_STATIC_FIELD_CONSTANT(OkioGzipSource, FCOMMENT, jbyte)

inline jbyte OkioGzipSource_get_SECTION_HEADER();
#define OkioGzipSource_SECTION_HEADER 0
J2OBJC_STATIC_FIELD_CONSTANT(OkioGzipSource, SECTION_HEADER, jbyte)

inline jbyte OkioGzipSource_get_SECTION_BODY();
#define OkioGzipSource_SECTION_BODY 1
J2OBJC_STATIC_FIELD_CONSTANT(OkioGzipSource, SECTION_BODY, jbyte)

inline jbyte OkioGzipSource_get_SECTION_TRAILER();
#define OkioGzipSource_SECTION_TRAILER 2
J2OBJC_STATIC_FIELD_CONSTANT(OkioGzipSource, SECTION_TRAILER, jbyte)

inline jbyte OkioGzipSource_get_SECTION_DONE();
#define OkioGzipSource_SECTION_DONE 3
J2OBJC_STATIC_FIELD_CONSTANT(OkioGzipSource, SECTION_DONE, jbyte)

__attribute__((unused)) static void OkioGzipSource_consumeHeader(OkioGzipSource *self);

__attribute__((unused)) static void OkioGzipSource_consumeTrailer(OkioGzipSource *self);

__attribute__((unused)) static void OkioGzipSource_updateCrcWithOkioBuffer_withLong_withLong_(OkioGzipSource *self, OkioBuffer *buffer, jlong offset, jlong byteCount);

__attribute__((unused)) static void OkioGzipSource_checkEqualWithNSString_withInt_withInt_(OkioGzipSource *self, NSString *name, jint expected, jint actual);

@implementation OkioGzipSource

- (instancetype)initWithOkioSource:(id<OkioSource>)source {
  OkioGzipSource_initWithOkioSource_(self, source);
  return self;
}

- (jlong)readWithOkioBuffer:(OkioBuffer *)sink
                   withLong:(jlong)byteCount {
  if (byteCount < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"byteCount < 0: ", byteCount));
  if (byteCount == 0) return 0;
  if (section_ == OkioGzipSource_SECTION_HEADER) {
    OkioGzipSource_consumeHeader(self);
    section_ = OkioGzipSource_SECTION_BODY;
  }
  if (section_ == OkioGzipSource_SECTION_BODY) {
    jlong offset = ((OkioBuffer *) nil_chk(sink))->size_;
    jlong result = [((OkioInflaterSource *) nil_chk(inflaterSource_)) readWithOkioBuffer:sink withLong:byteCount];
    if (result != -1) {
      OkioGzipSource_updateCrcWithOkioBuffer_withLong_withLong_(self, sink, offset, result);
      return result;
    }
    section_ = OkioGzipSource_SECTION_TRAILER;
  }
  if (section_ == OkioGzipSource_SECTION_TRAILER) {
    OkioGzipSource_consumeTrailer(self);
    section_ = OkioGzipSource_SECTION_DONE;
    if (![((id<OkioBufferedSource>) nil_chk(source_)) exhausted]) {
      @throw new_JavaIoIOException_initWithNSString_(@"gzip finished without exhausting source");
    }
  }
  return -1;
}

- (void)consumeHeader {
  OkioGzipSource_consumeHeader(self);
}

- (void)consumeTrailer {
  OkioGzipSource_consumeTrailer(self);
}

- (OkioTimeout *)timeout {
  return [((id<OkioBufferedSource>) nil_chk(source_)) timeout];
}

- (void)close {
  [((OkioInflaterSource *) nil_chk(inflaterSource_)) close];
}

- (void)updateCrcWithOkioBuffer:(OkioBuffer *)buffer
                       withLong:(jlong)offset
                       withLong:(jlong)byteCount {
  OkioGzipSource_updateCrcWithOkioBuffer_withLong_withLong_(self, buffer, offset, byteCount);
}

- (void)checkEqualWithNSString:(NSString *)name
                       withInt:(jint)expected
                       withInt:(jint)actual {
  OkioGzipSource_checkEqualWithNSString_withInt_withInt_(self, name, expected, actual);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithOkioSource:", NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { "readWithOkioBuffer:withLong:", "J", 0x1, 1, 2, 3, -1, -1, -1 },
    { "consumeHeader", "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { "consumeTrailer", "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { "timeout", "LOkioTimeout;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "close", "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { "updateCrcWithOkioBuffer:withLong:withLong:", "V", 0x2, 4, 5, -1, -1, -1, -1 },
    { "checkEqualWithNSString:withInt:withInt:", "V", 0x2, 6, 7, 3, -1, -1, -1 },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "FHCRC", "B", .constantValue.asChar = OkioGzipSource_FHCRC, 0x1a, -1, -1, -1, -1 },
    { "FEXTRA", "B", .constantValue.asChar = OkioGzipSource_FEXTRA, 0x1a, -1, -1, -1, -1 },
    { "FNAME", "B", .constantValue.asChar = OkioGzipSource_FNAME, 0x1a, -1, -1, -1, -1 },
    { "FCOMMENT", "B", .constantValue.asChar = OkioGzipSource_FCOMMENT, 0x1a, -1, -1, -1, -1 },
    { "SECTION_HEADER", "B", .constantValue.asChar = OkioGzipSource_SECTION_HEADER, 0x1a, -1, -1, -1, -1 },
    { "SECTION_BODY", "B", .constantValue.asChar = OkioGzipSource_SECTION_BODY, 0x1a, -1, -1, -1, -1 },
    { "SECTION_TRAILER", "B", .constantValue.asChar = OkioGzipSource_SECTION_TRAILER, 0x1a, -1, -1, -1, -1 },
    { "SECTION_DONE", "B", .constantValue.asChar = OkioGzipSource_SECTION_DONE, 0x1a, -1, -1, -1, -1 },
    { "section_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "source_", "LOkioBufferedSource;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "inflater_", "LJavaUtilZipInflater;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "inflaterSource_", "LOkioInflaterSource;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "crc_", "LJavaUtilZipCRC32;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOkioSource;", "read", "LOkioBuffer;J", "LJavaIoIOException;", "updateCrc", "LOkioBuffer;JJ", "checkEqual", "LNSString;II" };
  static const J2ObjcClassInfo _OkioGzipSource = { "GzipSource", "okio", ptrTable, methods, fields, 7, 0x11, 8, 13, -1, -1, -1, -1, -1 };
  return &_OkioGzipSource;
}

@end

void OkioGzipSource_initWithOkioSource_(OkioGzipSource *self, id<OkioSource> source) {
  NSObject_init(self);
  self->section_ = OkioGzipSource_SECTION_HEADER;
  self->crc_ = new_JavaUtilZipCRC32_init();
  if (source == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == null");
  self->inflater_ = new_JavaUtilZipInflater_initWithBoolean_(true);
  self->source_ = OkioOkio_bufferWithOkioSource_(source);
  self->inflaterSource_ = new_OkioInflaterSource_initWithOkioBufferedSource_withJavaUtilZipInflater_(self->source_, self->inflater_);
}

OkioGzipSource *new_OkioGzipSource_initWithOkioSource_(id<OkioSource> source) {
  J2OBJC_NEW_IMPL(OkioGzipSource, initWithOkioSource_, source)
}

OkioGzipSource *create_OkioGzipSource_initWithOkioSource_(id<OkioSource> source) {
  J2OBJC_CREATE_IMPL(OkioGzipSource, initWithOkioSource_, source)
}

void OkioGzipSource_consumeHeader(OkioGzipSource *self) {
  [((id<OkioBufferedSource>) nil_chk(self->source_)) requireWithLong:10];
  jbyte flags = [((OkioBuffer *) nil_chk([self->source_ buffer])) getByteWithLong:3];
  jboolean fhcrc = ((JreRShift32(flags, OkioGzipSource_FHCRC)) & 1) == 1;
  if (fhcrc) OkioGzipSource_updateCrcWithOkioBuffer_withLong_withLong_(self, [self->source_ buffer], 0, 10);
  jshort id1id2 = [self->source_ readShort];
  OkioGzipSource_checkEqualWithNSString_withInt_withInt_(self, @"ID1ID2", (jshort) (jint) 0x1f8b, id1id2);
  [self->source_ skipWithLong:8];
  if (((JreRShift32(flags, OkioGzipSource_FEXTRA)) & 1) == 1) {
    [self->source_ requireWithLong:2];
    if (fhcrc) OkioGzipSource_updateCrcWithOkioBuffer_withLong_withLong_(self, [self->source_ buffer], 0, 2);
    jint xlen = [((OkioBuffer *) nil_chk([self->source_ buffer])) readShortLe];
    [self->source_ requireWithLong:xlen];
    if (fhcrc) OkioGzipSource_updateCrcWithOkioBuffer_withLong_withLong_(self, [self->source_ buffer], 0, xlen);
    [self->source_ skipWithLong:xlen];
  }
  if (((JreRShift32(flags, OkioGzipSource_FNAME)) & 1) == 1) {
    jlong index = [self->source_ indexOfWithByte:(jbyte) 0];
    if (index == -1) @throw new_JavaIoEOFException_init();
    if (fhcrc) OkioGzipSource_updateCrcWithOkioBuffer_withLong_withLong_(self, [self->source_ buffer], 0, index + 1);
    [self->source_ skipWithLong:index + 1];
  }
  if (((JreRShift32(flags, OkioGzipSource_FCOMMENT)) & 1) == 1) {
    jlong index = [self->source_ indexOfWithByte:(jbyte) 0];
    if (index == -1) @throw new_JavaIoEOFException_init();
    if (fhcrc) OkioGzipSource_updateCrcWithOkioBuffer_withLong_withLong_(self, [self->source_ buffer], 0, index + 1);
    [self->source_ skipWithLong:index + 1];
  }
  if (fhcrc) {
    OkioGzipSource_checkEqualWithNSString_withInt_withInt_(self, @"FHCRC", [self->source_ readShortLe], (jshort) [((JavaUtilZipCRC32 *) nil_chk(self->crc_)) getValue]);
    [self->crc_ reset];
  }
}

void OkioGzipSource_consumeTrailer(OkioGzipSource *self) {
  OkioGzipSource_checkEqualWithNSString_withInt_withInt_(self, @"CRC", [((id<OkioBufferedSource>) nil_chk(self->source_)) readIntLe], (jint) [((JavaUtilZipCRC32 *) nil_chk(self->crc_)) getValue]);
  OkioGzipSource_checkEqualWithNSString_withInt_withInt_(self, @"ISIZE", [self->source_ readIntLe], [((JavaUtilZipInflater *) nil_chk(self->inflater_)) getTotalOut]);
}

void OkioGzipSource_updateCrcWithOkioBuffer_withLong_withLong_(OkioGzipSource *self, OkioBuffer *buffer, jlong offset, jlong byteCount) {
  OkioSegment *s = ((OkioBuffer *) nil_chk(buffer))->head_;
  for (; offset >= (((OkioSegment *) nil_chk(s))->limit_ - s->pos_); s = s->next_) {
    offset -= (s->limit_ - s->pos_);
  }
  for (; byteCount > 0; s = s->next_) {
    jint pos = (jint) (((OkioSegment *) nil_chk(s))->pos_ + offset);
    jint toUpdate = (jint) JavaLangMath_minWithLong_withLong_(s->limit_ - pos, byteCount);
    [((JavaUtilZipCRC32 *) nil_chk(self->crc_)) updateWithByteArray:s->data_ withInt:pos withInt:toUpdate];
    byteCount -= toUpdate;
    offset = 0;
  }
}

void OkioGzipSource_checkEqualWithNSString_withInt_withInt_(OkioGzipSource *self, NSString *name, jint expected, jint actual) {
  if (actual != expected) {
    @throw new_JavaIoIOException_initWithNSString_(NSString_formatWithNSString_withNSObjectArray_(@"%s: actual 0x%08x != expected 0x%08x", [IOSObjectArray newArrayWithObjects:(id[]){ name, JavaLangInteger_valueOfWithInt_(actual), JavaLangInteger_valueOfWithInt_(expected) } count:3 type:NSObject_class_()]));
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioGzipSource)
