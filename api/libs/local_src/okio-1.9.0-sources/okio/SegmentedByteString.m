//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: build/libs_raw/okio-1.9.0-sources/okio/SegmentedByteString.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/OutputStream.h"
#include "java/lang/AssertionError.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/nio/ByteBuffer.h"
#include "java/util/Arrays.h"
#include "okio/Buffer.h"
#include "okio/ByteString.h"
#include "okio/Segment.h"
#include "okio/SegmentedByteString.h"
#include "okio/Util.h"

@interface OkioSegmentedByteString ()

/*!
 @brief Returns the index of the segment that contains the byte at <code>pos</code>.
 */
- (jint)segmentWithInt:(jint)pos;

/*!
 @brief Returns a copy as a non-segmented byte string.
 */
- (OkioByteString *)toByteString;

- (id)writeReplace;

@end

__attribute__((unused)) static jint OkioSegmentedByteString_segmentWithInt_(OkioSegmentedByteString *self, jint pos);

__attribute__((unused)) static OkioByteString *OkioSegmentedByteString_toByteString(OkioSegmentedByteString *self);

@implementation OkioSegmentedByteString

- (instancetype)initWithOkioBuffer:(OkioBuffer *)buffer
                           withInt:(jint)byteCount {
  OkioSegmentedByteString_initWithOkioBuffer_withInt_(self, buffer, byteCount);
  return self;
}

- (NSString *)utf8 {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) utf8];
}

- (NSString *)base64 {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) base64];
}

- (NSString *)hex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) hex];
}

- (OkioByteString *)toAsciiLowercase {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) toAsciiLowercase];
}

- (OkioByteString *)toAsciiUppercase {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) toAsciiUppercase];
}

- (OkioByteString *)md5 {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) md5];
}

- (OkioByteString *)sha256 {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) sha256];
}

- (NSString *)base64Url {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) base64Url];
}

- (OkioByteString *)substringWithInt:(jint)beginIndex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) substringWithInt:beginIndex];
}

- (OkioByteString *)substringWithInt:(jint)beginIndex
                             withInt:(jint)endIndex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) substringWithInt:beginIndex withInt:endIndex];
}

- (jbyte)getByteWithInt:(jint)pos {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(IOSIntArray_Get(nil_chk(directory_), ((IOSObjectArray *) nil_chk(segments_))->size_ - 1), pos, 1);
  jint segment = OkioSegmentedByteString_segmentWithInt_(self, pos);
  jint segmentOffset = segment == 0 ? 0 : IOSIntArray_Get(directory_, segment - 1);
  jint segmentPos = IOSIntArray_Get(directory_, segment + segments_->size_);
  return IOSByteArray_Get(nil_chk(IOSObjectArray_Get(segments_, segment)), pos - segmentOffset + segmentPos);
}

- (jint)segmentWithInt:(jint)pos {
  return OkioSegmentedByteString_segmentWithInt_(self, pos);
}

- (jint)size {
  return IOSIntArray_Get(nil_chk(directory_), ((IOSObjectArray *) nil_chk(segments_))->size_ - 1);
}

- (IOSByteArray *)toByteArray {
  IOSByteArray *result = [IOSByteArray newArrayWithLength:IOSIntArray_Get(nil_chk(directory_), ((IOSObjectArray *) nil_chk(segments_))->size_ - 1)];
  jint segmentOffset = 0;
  for (jint s = 0, segmentCount = segments_->size_; s < segmentCount; s++) {
    jint segmentPos = IOSIntArray_Get(directory_, segmentCount + s);
    jint nextSegmentOffset = IOSIntArray_Get(directory_, s);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(IOSObjectArray_Get(segments_, s), segmentPos, result, segmentOffset, nextSegmentOffset - segmentOffset);
    segmentOffset = nextSegmentOffset;
  }
  return result;
}

- (JavaNioByteBuffer *)asByteBuffer {
  return [((JavaNioByteBuffer *) nil_chk(JavaNioByteBuffer_wrapWithByteArray_([self toByteArray]))) asReadOnlyBuffer];
}

- (void)writeWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  if (outArg == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"out == null");
  jint segmentOffset = 0;
  for (jint s = 0, segmentCount = ((IOSObjectArray *) nil_chk(segments_))->size_; s < segmentCount; s++) {
    jint segmentPos = IOSIntArray_Get(nil_chk(directory_), segmentCount + s);
    jint nextSegmentOffset = IOSIntArray_Get(directory_, s);
    [outArg writeWithByteArray:IOSObjectArray_Get(segments_, s) withInt:segmentPos withInt:nextSegmentOffset - segmentOffset];
    segmentOffset = nextSegmentOffset;
  }
}

- (void)writeWithOkioBuffer:(OkioBuffer *)buffer {
  jint segmentOffset = 0;
  for (jint s = 0, segmentCount = ((IOSObjectArray *) nil_chk(segments_))->size_; s < segmentCount; s++) {
    jint segmentPos = IOSIntArray_Get(nil_chk(directory_), segmentCount + s);
    jint nextSegmentOffset = IOSIntArray_Get(directory_, s);
    OkioSegment *segment = new_OkioSegment_initWithByteArray_withInt_withInt_(IOSObjectArray_Get(segments_, s), segmentPos, segmentPos + nextSegmentOffset - segmentOffset);
    if (((OkioBuffer *) nil_chk(buffer))->head_ == nil) {
      buffer->head_ = segment->next_ = segment->prev_ = segment;
    }
    else {
      (void) [((OkioSegment *) nil_chk(buffer->head_->prev_)) pushWithOkioSegment:segment];
    }
    segmentOffset = nextSegmentOffset;
  }
  ((OkioBuffer *) nil_chk(buffer))->size_ += segmentOffset;
}

- (jboolean)rangeEqualsWithInt:(jint)offset
            withOkioByteString:(OkioByteString *)other
                       withInt:(jint)otherOffset
                       withInt:(jint)byteCount {
  if (offset < 0 || offset > [self size] - byteCount) return false;
  for (jint s = OkioSegmentedByteString_segmentWithInt_(self, offset); byteCount > 0; s++) {
    jint segmentOffset = s == 0 ? 0 : IOSIntArray_Get(nil_chk(directory_), s - 1);
    jint segmentSize = IOSIntArray_Get(nil_chk(directory_), s) - segmentOffset;
    jint stepSize = JavaLangMath_minWithInt_withInt_(byteCount, segmentOffset + segmentSize - offset);
    jint segmentPos = IOSIntArray_Get(directory_, ((IOSObjectArray *) nil_chk(segments_))->size_ + s);
    jint arrayOffset = offset - segmentOffset + segmentPos;
    if (![((OkioByteString *) nil_chk(other)) rangeEqualsWithInt:otherOffset withByteArray:IOSObjectArray_Get(segments_, s) withInt:arrayOffset withInt:stepSize]) return false;
    offset += stepSize;
    otherOffset += stepSize;
    byteCount -= stepSize;
  }
  return true;
}

- (jboolean)rangeEqualsWithInt:(jint)offset
                 withByteArray:(IOSByteArray *)other
                       withInt:(jint)otherOffset
                       withInt:(jint)byteCount {
  if (offset < 0 || offset > [self size] - byteCount || otherOffset < 0 || otherOffset > ((IOSByteArray *) nil_chk(other))->size_ - byteCount) {
    return false;
  }
  for (jint s = OkioSegmentedByteString_segmentWithInt_(self, offset); byteCount > 0; s++) {
    jint segmentOffset = s == 0 ? 0 : IOSIntArray_Get(nil_chk(directory_), s - 1);
    jint segmentSize = IOSIntArray_Get(nil_chk(directory_), s) - segmentOffset;
    jint stepSize = JavaLangMath_minWithInt_withInt_(byteCount, segmentOffset + segmentSize - offset);
    jint segmentPos = IOSIntArray_Get(directory_, ((IOSObjectArray *) nil_chk(segments_))->size_ + s);
    jint arrayOffset = offset - segmentOffset + segmentPos;
    if (!OkioUtil_arrayRangeEqualsWithByteArray_withInt_withByteArray_withInt_withInt_(IOSObjectArray_Get(segments_, s), arrayOffset, other, otherOffset, stepSize)) return false;
    offset += stepSize;
    otherOffset += stepSize;
    byteCount -= stepSize;
  }
  return true;
}

- (jint)indexOfWithByteArray:(IOSByteArray *)other
                     withInt:(jint)fromIndex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) indexOfWithByteArray:other withInt:fromIndex];
}

- (jint)lastIndexOfWithByteArray:(IOSByteArray *)other
                         withInt:(jint)fromIndex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) lastIndexOfWithByteArray:other withInt:fromIndex];
}

- (OkioByteString *)toByteString {
  return OkioSegmentedByteString_toByteString(self);
}

- (IOSByteArray *)internalArray {
  return [self toByteArray];
}

- (jboolean)isEqual:(id)o {
  if (o == self) return true;
  return [o isKindOfClass:[OkioByteString class]] && [((OkioByteString *) nil_chk(((OkioByteString *) cast_chk(o, [OkioByteString class])))) size] == [self size] && [self rangeEqualsWithInt:0 withOkioByteString:((OkioByteString *) cast_chk(o, [OkioByteString class])) withInt:0 withInt:[self size]];
}

- (NSUInteger)hash {
  jint result = hashCode_;
  if (result != 0) return result;
  result = 1;
  jint segmentOffset = 0;
  for (jint s = 0, segmentCount = ((IOSObjectArray *) nil_chk(segments_))->size_; s < segmentCount; s++) {
    IOSByteArray *segment = IOSObjectArray_Get(segments_, s);
    jint segmentPos = IOSIntArray_Get(nil_chk(directory_), segmentCount + s);
    jint nextSegmentOffset = IOSIntArray_Get(directory_, s);
    jint segmentSize = nextSegmentOffset - segmentOffset;
    for (jint i = segmentPos, limit = segmentPos + segmentSize; i < limit; i++) {
      result = (31 * result) + IOSByteArray_Get(nil_chk(segment), i);
    }
    segmentOffset = nextSegmentOffset;
  }
  return (hashCode_ = result);
}

- (NSString *)description {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) description];
}

- (id)writeReplace {
  return OkioSegmentedByteString_toByteString(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithOkioBuffer:withInt:", NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { "utf8", "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "base64", "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "hex", "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "toAsciiLowercase", "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "toAsciiUppercase", "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "md5", "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "sha256", "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "base64Url", "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "substringWithInt:", "LOkioByteString;", 0x1, 1, 2, -1, -1, -1, -1 },
    { "substringWithInt:withInt:", "LOkioByteString;", 0x1, 1, 3, -1, -1, -1, -1 },
    { "getByteWithInt:", "B", 0x1, 4, 2, -1, -1, -1, -1 },
    { "segmentWithInt:", "I", 0x2, 5, 2, -1, -1, -1, -1 },
    { "size", "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { "toByteArray", "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { "asByteBuffer", "LJavaNioByteBuffer;", 0x1, -1, -1, -1, -1, -1, -1 },
    { "writeWithJavaIoOutputStream:", "V", 0x1, 6, 7, 8, -1, -1, -1 },
    { "writeWithOkioBuffer:", "V", 0x0, 6, 9, -1, -1, -1, -1 },
    { "rangeEqualsWithInt:withOkioByteString:withInt:withInt:", "Z", 0x1, 10, 11, -1, -1, -1, -1 },
    { "rangeEqualsWithInt:withByteArray:withInt:withInt:", "Z", 0x1, 10, 12, -1, -1, -1, -1 },
    { "indexOfWithByteArray:withInt:", "I", 0x1, 13, 14, -1, -1, -1, -1 },
    { "lastIndexOfWithByteArray:withInt:", "I", 0x1, 15, 14, -1, -1, -1, -1 },
    { "toByteString", "LOkioByteString;", 0x2, -1, -1, -1, -1, -1, -1 },
    { "internalArray", "[B", 0x0, -1, -1, -1, -1, -1, -1 },
    { "isEqual:", "Z", 0x1, 16, 17, -1, -1, -1, -1 },
    { "hash", "I", 0x1, 18, -1, -1, -1, -1, -1 },
    { "description", "LNSString;", 0x1, 19, -1, -1, -1, -1, -1 },
    { "writeReplace", "LNSObject;", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "segments_", "[[B", .constantValue.asLong = 0, 0x90, -1, -1, -1, -1 },
    { "directory_", "[I", .constantValue.asLong = 0, 0x90, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOkioBuffer;I", "substring", "I", "II", "getByte", "segment", "write", "LJavaIoOutputStream;", "LJavaIoIOException;", "LOkioBuffer;", "rangeEquals", "ILOkioByteString;II", "I[BII", "indexOf", "[BI", "lastIndexOf", "equals", "LNSObject;", "hashCode", "toString" };
  static const J2ObjcClassInfo _OkioSegmentedByteString = { "SegmentedByteString", "okio", ptrTable, methods, fields, 7, 0x10, 28, 2, -1, -1, -1, -1, -1 };
  return &_OkioSegmentedByteString;
}

@end

void OkioSegmentedByteString_initWithOkioBuffer_withInt_(OkioSegmentedByteString *self, OkioBuffer *buffer, jint byteCount) {
  OkioByteString_initWithByteArray_(self, nil);
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(((OkioBuffer *) nil_chk(buffer))->size_, 0, byteCount);
  jint offset = 0;
  jint segmentCount = 0;
  for (OkioSegment *s = buffer->head_; offset < byteCount; s = s->next_) {
    if (((OkioSegment *) nil_chk(s))->limit_ == s->pos_) {
      @throw new_JavaLangAssertionError_initWithId_(@"s.limit == s.pos");
    }
    offset += s->limit_ - s->pos_;
    segmentCount++;
  }
  self->segments_ = [IOSObjectArray newArrayWithLength:segmentCount type:IOSClass_byteArray(1)];
  self->directory_ = [IOSIntArray newArrayWithLength:segmentCount * 2];
  offset = 0;
  segmentCount = 0;
  for (OkioSegment *s = buffer->head_; offset < byteCount; s = s->next_) {
    (void) IOSObjectArray_Set(self->segments_, segmentCount, ((OkioSegment *) nil_chk(s))->data_);
    offset += s->limit_ - s->pos_;
    if (offset > byteCount) {
      offset = byteCount;
    }
    *IOSIntArray_GetRef(self->directory_, segmentCount) = offset;
    *IOSIntArray_GetRef(self->directory_, segmentCount + self->segments_->size_) = s->pos_;
    s->shared_ = true;
    segmentCount++;
  }
}

OkioSegmentedByteString *new_OkioSegmentedByteString_initWithOkioBuffer_withInt_(OkioBuffer *buffer, jint byteCount) {
  J2OBJC_NEW_IMPL(OkioSegmentedByteString, initWithOkioBuffer_withInt_, buffer, byteCount)
}

OkioSegmentedByteString *create_OkioSegmentedByteString_initWithOkioBuffer_withInt_(OkioBuffer *buffer, jint byteCount) {
  J2OBJC_CREATE_IMPL(OkioSegmentedByteString, initWithOkioBuffer_withInt_, buffer, byteCount)
}

jint OkioSegmentedByteString_segmentWithInt_(OkioSegmentedByteString *self, jint pos) {
  jint i = JavaUtilArrays_binarySearchWithIntArray_withInt_withInt_withInt_(self->directory_, 0, ((IOSObjectArray *) nil_chk(self->segments_))->size_, pos + 1);
  return i >= 0 ? i : ~i;
}

OkioByteString *OkioSegmentedByteString_toByteString(OkioSegmentedByteString *self) {
  return new_OkioByteString_initWithByteArray_([self toByteArray]);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioSegmentedByteString)
